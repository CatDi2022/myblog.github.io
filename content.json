{"meta":{"title":"Cat迪ღBLOG","subtitle":"小迪家","description":"欢迎来到\"我的世界\"","author":"Cat迪","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2022-04-23T15:55:04.000Z","updated":"2022-04-25T14:45:58.332Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-24T02:45:17.000Z","updated":"2022-04-25T14:35:42.948Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2022-04-24T05:02:58.000Z","updated":"2022-04-24T05:02:58.507Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"about","date":"2022-04-24T05:03:43.000Z","updated":"2022-04-24T05:03:44.015Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"photos","date":"2022-04-24T05:04:07.000Z","updated":"2022-04-24T05:04:07.743Z","comments":true,"path":"photos/index.html","permalink":"http://example.com/photos/index.html","excerpt":"","text":""},{"title":"music","date":"2022-04-24T05:04:22.000Z","updated":"2022-04-25T15:45:34.453Z","comments":true,"path":"music/index.html","permalink":"http://example.com/music/index.html","excerpt":"","text":""},{"title":"movies","date":"2022-04-24T05:04:40.000Z","updated":"2022-04-24T05:04:40.340Z","comments":true,"path":"movies/index.html","permalink":"http://example.com/movies/index.html","excerpt":"","text":""},{"title":"books","date":"2022-04-24T05:04:54.000Z","updated":"2022-04-24T05:04:54.753Z","comments":true,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"shuoshuo","date":"2022-04-24T05:05:12.000Z","updated":"2022-04-24T05:05:12.098Z","comments":true,"path":"shuoshuo/index.html","permalink":"http://example.com/shuoshuo/index.html","excerpt":"","text":""},{"title":"mescategories","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-24T12:16:36.837Z","comments":true,"path":"messageboard/index.html","permalink":"http://example.com/messageboard/index.html","excerpt":"","text":""}],"posts":[{"title":"HTML基础整合","slug":"Html基础","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T07:44:20.957Z","comments":true,"path":"2022/04/24/Html基础/","link":"","permalink":"http://example.com/2022/04/24/Html%E5%9F%BA%E7%A1%80/","excerpt":"","text":"「学习笔记」HTML基础 前言勤做笔记不仅可以让自己学的扎实，更重要的是可以让自己少走弯路。有人说:”再次翻开笔记是什么感觉”，我的回答是:”初恋般的感 觉”。或许笔记不一定十全十美，但肯定会让你有种初恋般的怦然心动。💖💖 本章着重复习Html的基础内容，学习Html究竟要学些什么呢？主要是学习各种标签，来搭建网页的“结构”。✨✨ 本篇文章主要由五个章节构成，从WEB标准到初识HTML，接着学习HTML常用标签，最后学习表格列表和表单。💪💪开始充电之旅啦~~~ 认识WEB「网页」主要是由文字、图像和超链接等元素构成，当然除了这些元素，网页中还可以包括音频、视频以及Flash等。 「浏览器」是网页显示、运行的平台。 「浏览器内核」(排版引擎、解释引擎、渲染引擎) 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。 浏览器 内核 备注 IE Trident IE、猎豹安全、360极速浏览器、百度浏览器 firefox Gecko 可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 Safari webkit 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了）。苹果感觉像被别人抢了媳妇，都哭晕在厕所里面了。 chrome Chromium/Blink 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发 Opera blink 现在跟随chrome用blink内核。 Web标准「构成」👉 结构标准，表现标准和行为标准 结构标准用于对网页元素进行整理和分类(HTML) 表现标准用于设置网页元素的版式、颜色、大小等外观属性(CSS) 行为标准用于对网页模型的定义及交互的编写(JavaScript) 「Web标准的优点」👇 易于维护：只需更改CSS文件，就可以改变整站的样式 页面响应快：HTML文档体积变小，响应时间短 可访问性：语义化的HTML（结构和表现相分离的HTML）编写的网页文件，更容易被屏幕阅读器识别 设备兼容性：不同的样式表可以让网页在不同的设备上呈现不同的样式 搜索引擎：语义化的HTML能更容易被搜索引擎解析，提升排名 HTML初识HTML初识「HTML」(Hyper Text Markup Language):超文本标记语言 「所谓超文本，有2层含义：」 因为它可以加入图片、声音、动画、多媒体等内容（超越文本限制 ） 不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本）。 「HTML骨架格式」 1234567891011&lt;!-- 页面中最大的标签 根标签 --&gt;&lt;html&gt; &lt;!-- 头部标签 --&gt; &lt;head&gt; &lt;!-- 标题标签 --&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;!-- 文档的主体 --&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 「团队约定大小写」 HTML标签名、类名、标签属性和大部分属性值统一用小写 「HTML元素标签分类」 常规元素(双标签) 空元素(单标签) 12345常规元素(双标签)&lt;标签名&gt; 内容 &lt;/标签名&gt; 比如&lt;body&gt;我是文字&lt;/body&gt;空元素(单标签)&lt;标签名 /&gt; 比如 &lt;br /&gt;或&lt;br&gt; 「HTML标签关系」 嵌套关系父子级包含关系 并列关系兄弟级并列关系 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位（一个tab是4个空格）。如果是并列关系，最好上下对齐。 文档类型「文档类型」用来说明你用的XHTML或者HTML是什么版本。告诉浏览器按照HTML5标准解析页面。 页面语言langlang指定该html标签内容所用的语言 12&lt;html lang=&quot;en&quot;&gt; en 定义语言为英语 zh-CN定义语言为中文 「lang的作用」 根据根据lang属性来设定不同语言的css样式，或者字体 告诉搜索引擎做精确的识别 让语法检查程序做语言识别 帮助翻译工具做识别 帮助网页阅读程序做识别 字符集「字符集」(Character set)是多个字符的集合,计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。 UTF-8是目前最常用的字符集编码方式 让 html 文件是以 UTF-8 编码保存的， 浏览器根据编码去解码对应的html内容。 1&lt;meta charset=&quot;UTF-8&quot; /&gt; 「meta viewport的用法」 通常viewport是指视窗、视口。浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域。在移动端和pc端视口是不同的，pc端的视口是浏览器窗口区域，而在移动端有三个不同的视口概念：布局视口、视觉视口、理想视口 meta有两个属性name 和 http-equiv name属性的取值 keywords(关键字) 告诉搜索引擎，该网页的关键字 description(网站内容描述) 用于告诉搜索引擎，你网站的主要内容。 viewport(移动端的窗口) robots(定义搜索引擎爬虫的索引方式) robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引 author(作者) generator(网页制作软件） copyright(版权) http-equiv有以下参数 http-equiv相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容 content-Type 设定网页字符集(Html4用法，不推荐) Expires(期限) ,可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 Pragma(cache模式),是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出 Refresh(刷新),自动刷新并指向新页面。 cache-control（请求和响应遵循的缓存机制） 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; HTML标签的语义化 方便代码的阅读和维护，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 「拓展」 标签：规定页面上所有链接的默认 URL 和设置整体链接的打开状态 1234567&lt;head&gt; &lt;base href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt; &lt;base target=&quot;_self&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;&quot;&gt;测试&lt;/a&gt; 跳转到 百度&lt;/body&gt; HTML常用标签常用标签「1. 排版标签」主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。 标题标签h(h1~h6) 段落标签p,可以把 HTML 文档分割为若干段落 水平线标签hr 换行标签br div和span标签:是没有语义的,是我们网页布局最主要的2个盒子。 「2. 排版标签」 b和strong 文字以粗体显示 i和em 文字以斜体显示 s和del 文字以加删除线显示 u和ins 文字以加下划线显示 「3. 标签属性(行内式)」 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。 12&lt;标签名 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …&gt; 内容 &lt;/标签名&gt;&lt;手机 颜色=&quot;红色&quot; 大小=&quot;5寸&quot;&gt; &lt;/手机&gt; 「4. 图像标签img」 注意： 标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 采取 键值对 的格式 key=”value” 的格式 1&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; title=&quot;这是个小蒲公英&quot; /&gt; 「5. 链接标签(重点)」 123&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;target=&quot;_self&quot; 默认窗口弹出方式target=&quot;_blank&quot; 新窗口弹出 属性 作用 href 用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能 target 用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 src 和 href 的区别 一句话概括:src 是引入资源的 href 是跳转url的 src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。 src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。如果我们在文档中添加那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。 注意： 外部链接 需要添加 http:// www.baidu.com 内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。 不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 锚点定位：通过创建锚点链接，用户能够快速定位到目标内容。 123451. 使用相应的id名标注跳转目标的位置。 (找目标) &lt;h3 id=&quot;two&quot;&gt;第2集&lt;/h3&gt; 2. 使用&lt;a href=&quot;#id名&quot;&gt;链接文本&lt;/a&gt;创建链接文本（被点击的） &lt;a href=&quot;#two&quot;&gt; 「6. 注释标签」 123&lt;!-- 注释语句 --&gt; 快捷键是： ctrl + / 或者 ctrl +shift + / 团队约定：注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行 「7. 路径」 「8. 其他知识」 预格式化文本pre标签元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。格式化文本就是 ，按照我们预先写好的文字格式来显示页面， 保留空格和换行等。 特殊字符什么是XHTML XHTML 指「可扩展超文本标签语言」（EXtensible HyperText Markup Language）。 XHTML 的目标是取代 HTML。 XHTML 与 HTML 4.01 几乎是相同的。 XHTML 是更严格更纯净的 HTML 版本。 XHTML 是作为一种 XML 应用被重新定义的 HTML,是严格版本的HTML。例如它要求标签必须小写，标签必须被正确关闭，标签顺序必须正确排列，对于属性都必须使用双引号等。 XHTML 是一个 W3C 标准。 写HTML代码时应注意什么？ 尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置。 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for来让说明文本和相对应的input关联起来。 表格「1. 表格」 现在还是较为常用的一种标签，但不是用来布局，常见显示、展示表格式数据。因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候表格运用是否熟练就显得很重要，一个清爽简约的表格能够把繁杂的数据表现得很有条理。 「2. 创建表格」 1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; table、tr、td，他们是创建表格的基本标签，缺一不可 table用于定义一个表格标签。 tr标签 用于定义表格中的行，必须嵌套在 table标签中。 td 用于定义表格中的单元格，必须嵌套在标签中。 字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。td像一个容器，可以容纳所有的元素。 表头单元格标签th:一般表头单元格位于表格的第一行或第一列，并且文本加粗居中,只需用表头标签替代相应的单元格标签即可。 表格标题caption通常这个标题会被居中且显示于表格之上。caption 标签必须紧随 table 标签之后。这个标签只存在 表格里面才有意义。你是风儿我是沙 123&lt;table&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt;&lt;/table&gt; 「3. 表格属性」 三参为0，平时开发的我们这三个参数 border cellpadding cellspacing 为 0 「4. 合并单元格」,合并的顺序我们按照 先上 后下 先左 后右 的顺序 ,合并完之后需要删除多余的单元格。 跨行合并：rowspan=”合并单元格的个数” 跨列合并：colspan=”合并单元格的个数” 「5. 总结表格」 标签名 定义 说明 表格标签 就是一个四方的盒子 表格行标签 行标签要再table标签内部才有意义 单元格标签 单元格标签是个容器级元素，可以放任何东西 表头单元格标签 它还是一个单元格，但是里面的文字会居中且加粗 表格标题标签 表格的标题，跟着表格一起走，和表格居中对齐 clospan 和 rowspan 合并属性 用来合并单元格的 「6. 表格划分结构」 对于比较复杂的表格，表格的结构也就相对的复杂了，所以又将表格分割成三个部分：题头、正文和脚注。而这三部分分别用:thead,tbody,tfoot来标注， 这样更好的分清表格结构。 注意：\\1.：用于定义表格的头部。用来放标题之类的东西。 内部必须拥有 标签！\\2. ：用于定义表格的主体。放数据本体 。\\3. 放表格的脚注之类。\\4. 以上标签都是放到table标签中。 列表「列表ul」容器里面装载着结构，样式一致的文字或图表的一种形式，叫列表。 列表最大的特点就是整齐 、整洁、 有序，跟表格类似，但是它可组合自由度会更高。 「1. 无序列表 ul」 中只能嵌套，直接在标签中输入其他标签或者文字的做法是不被允许的。 与之间相当于一个容器，可以容纳所有元素。 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 「2. 有序列表 ol」 标签中的type属性值为排序的序列号，不添加type属性时，有序列表默认从数字1开始排序。 常用的type属性值分别为是1，a，A，i，I 中的reversed属性能够让有序列表中的序列倒序排列。 中的start属性值为3，有序列表中的第一个序列号将从3开始排列。 12345&lt;ol type=&quot;A&quot;&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表二&lt;/li&gt; &lt;li&gt;列表三&lt;/li&gt;&lt;/ol&gt; 「2. 自定义列表 dl」 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 表单在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。表单目的是为了收集用户信息。 表单控件： 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。提示信息： 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。表单域： 它相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 「1. input 控件」 1&lt;input type=&quot;属性值&quot; value=&quot;你好&quot;&gt; input 输入的意思 标签为单标签 type属性设置不同的属性值用来指定不同的控件类型 除了type属性还有别的属性 常用属性： 12用户名: &lt;input type=&quot;text&quot; /&gt; 密 码：&lt;input type=&quot;password&quot; /&gt; value属性 value 默认的文本值。有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。 1用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot;&gt; name属性 name表单的名字， 这样，后台可以通过这个name属性找到这个表单。 页面中的表单很多，name主要作用就是用于区别不同的表单。 name属性后面的值，是我们自己定义的。 radio 如果是一组，我们必须给他们命名相同的名字 name 这样就可以多个选其中的一个啦 name属性，我们现在用的较少，但是，当我们学ajax 和后台的时候，是必须的。 12&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;女 checked属性 表示默认选中状态。 较常见于 单选按钮和复选按钮。 123性 别:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女 input 属性小结 属性 说明 作用 type 表单类型 用来指定不同的控件类型 value 表单值 表单里面默认显示的文本 name 表单名字 页面中的表单很多，name主要作用就是用于区别不同的表单。 checked 默认选中 表示那个单选或者复选按钮一开始就被选中了 「2. label标签」 label 标签为 input 元素定义标注（标签）。 label标签主要目的是为了提高用户体验。为用户提高最优秀的服务。 作用：用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。 如何绑定元素呢 第一种用法就是用label标签直接包含input表单， 适合单个表单选择 第二种用法 for 属性规定 label 与哪个表单元素绑定(通过id)。 12345678第一种&lt;label&gt; 用户名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot;&gt; &lt;/label&gt;第二种&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot;&gt; 「3. textarea控件(文本域)」 通过textarea控件可以轻松地创建多行文本输入框. cols=”每行中的字符数” rows=”显示的行数” 我们实际开发不用 123&lt;textarea &gt; 文本内容&lt;/textarea&gt; 文本框和文本域区别 表单 名称 区别 默认值显示 用于场景 input type=”text” 文本框 只能显示一行文本 单标签，通过value显示默认值 用户名、昵称、密码等 textarea 文本域 可以显示多行文本 双标签，默认值写到标签中间 留言板 「4. select下拉列表」 如果有多个选项让用户选择，为了节约空间，我们可以使用select控件定义下拉列表。 在option 中定义selected =” selected “时，当前项即为默认选中项。 我们实际开发会用的比较少 1234567&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; form表单域 收集的用户信息怎么传递给服务器？ 通过form表单域 目的： 在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。 123&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt; 各种表单控件&lt;/form&gt; 常用属性： 每个表单都应该有自己表单域。后面学 ajax 后台交互的时候，必须需要form表单域。 属性 属性值 作用 action url地址 用于指定接收并处理表单数据的服务器程序的url地址。 method get/post 用于设置表单数据的提交方式，其取值为get或post。 name 名称 用于指定表单的名称，以区分同一个页面中的多个表单。 GET 和 POST 的区别 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求大小一般是(1024字节)，http协议并没有限制，而与服务器，操作系统有关，POST理论上来说没有大小限制，http协议规范也没有进行大小限制，但实际上post所能传递的数据量根据取决于服务器的设置和内存大小。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 团队约定： 元素属性值使用双引号语法 元素属性值可以写上的都写上 123推荐&lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;radio&quot; name=&quot;name&quot; checked=&quot;checked&quot; /&gt; 从输入url到页面展示发生了什么(面试) 作者：Twinkle_链接：https://juejin.im/post/6869279683230629896来源：掘金 浏览器的多进程架构从浏览器输入 URL 到页面渲染的整个过程都是由浏览器架构中的各个进程之间的配合完成。 浏览器主进程: 管理子进程、提供服务功能 渲染进程：将HTML、CSS、JS渲染成界面，js引擎v8和排版引擎Blink就在上面，他会为每一个tab页面创建一个渲染进程 GPU进程：本来是负责处理3Dcss的，后来慢慢的UI界面也交给GPU来绘制 网络进程：就是负责网络请求，网络资源加载的进程 插件进程：负责插件的运行的，因为插件很容易崩溃，把它放到独立的进程里不要让它影响别人 浏览器的多进程架构 从用户输入信息到页面展示的不同阶段，是不同的进程在发挥作用，示意图如下：从图中可以看出，整个过程是需要各个进程之间相互配合完成的，过程大致可以描述为： 用户输入url,处理输入信息，主进程开始导航，交给网络进程干活 网络进程发起网络请求，其中有可能会发生重定向 服务器响应URL之后，主进程就要通知渲染进程，你要开始干活了 渲染进程准备好了，要想渲染进程提交数据，这个时间叫做提交文档 渲染进程接受到数据，完成页面渲染。 具体过程 输入url 用户输入url，处理输入信息：如果为非url结构的字符串，交给浏览器默认引擎去搜索改字符串；若为url结构的字符串，浏览器主进程会交给 网络进程 ,开始干活。2.1 查找浏览器缓存网络进程会先看看是否存在本地缓存，如果有就直接返回资源给浏览器进程，无则下一步 DNS-&gt; IP -&gt; TCP2.2 DNS解析网络进程拿到url后，先会进行DNS域名解析得到IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。2.2 建立TCP连接，三次握手接下来就是利用IP地址和服务器建立TCP连接。连接建立之后，向服务器发送请求。服务器响应服务器收到请求信息后，会根据请求信息生成响应行、响应头、响应体，并发给网络进程。网络进程接受了响应信息之后，就开始解析响应头的内容。网络进程解析响应行和响应头信息的过程：3.1 重定向如果响应行状态码为301（永久重定向）和302（临时），那么说明需要重定向到其他url。这时候网络进程会从响应头中的Location字段里读取重定向的地址，并重新发起网络请求。3.2 响应数据处理导航会通过请求头的Content-type字段判断响应体数据的类型。浏览器通过这个来决定如何显示响应体的内容。比如：若为application/octet-stream，则会按照下载类型来处理这个请求，导航结束。若为text/html，这就告诉浏览器服务器返回的是html格式，浏览器会通知渲染进程，你要干活了。准备渲染进程默认情况，每个页面一个渲染进程。但若处于同一站点（同根域名+协议），那么渲染进程就会复用。提交文档渲染进程准备好后，浏览器进程发出“提交文档的消息”，渲染进程接受了消息之后，会跟网络进程简历传输数据的管道。等数据传输完成了，渲染进程会告诉浏览器进程，确认文档提交，这时候浏览器会更新页面，安全状态，url，前进后退的历史。到这里导航结束，进入渲染阶段。注：当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为百度首页的页面。因为需要等待提交文档阶段，页面内容才会被替换。前端HTML基础面试题iframe有哪些缺点？iframe是一种框架，也是一种很常见的网页嵌入方式。「iframe的优点」iframe能够原封不动的把嵌入的网页展现出来。如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。「iframe的缺点」会产生很多页面，不容易管理。iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。label的作用是什么？是怎么用的？例子1: 点击” 用户名:” 就可以定位光标到输入框&lt;form&gt;&lt;label for=&quot;myid &quot;&gt; 用户名:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;myid&quot; /&gt;&lt;/form&gt; 例子2: 点击” 用户名:” 或按键alt+1, 都可以定位光标到输入框&lt;form&gt; &lt;label for=&quot;myid&quot; accesskey=&quot;1&quot;&gt; 用户名:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;myid&quot; tabindex=&quot;1&quot; /&gt;&lt;/form&gt; for 属性功能：表示Label 标签要绑定的HTML 元素，你点击这个标签的时候，所绑定的元素将获取焦点。acesskey 属性功能：表示访问Label 标签所绑定的元素的热键，当您按下热键，所绑定的元素将获取焦点。局限性：accessKey 属性所设置的快捷键不能与浏览器的快捷键冲突，否则将优先激活浏览器的快捷键。HTML5的form如何关闭自动完成功能？ HTML的输入框可以拥有自动完成的功能，当你往输入框输入内容的时候，浏览器会从你以前的同名输入框的历史记录中查找出类似的内容并列在输入框下面，这样就不用全部输入进去了，直接选择列表中的项目就可以了。 但有时候我们希望关闭输入框的自动完成功能，例如当用户输入内容的时候，我们希望使用AJAX技术从数据库搜索并列举而不是在用户的历史记录中搜索。关闭输入框的自动完成功能有3种方法：在IE的Internet选项菜单里的内容–自动完成里面设置设置form的autocomplete为”on”或者”off”来开启或者关闭自动完成功能设置输入框的autocomplete为”on”或者”off”来开启或者关闭该输入框的自动完成功能将 HTML5 看作成开放的网络平台「什么是 HTML5 的基本构件（building block）？」语义 - 提供更准确地描述内容。连接 - 提供新的方式与服务器通信。离线和存储 - 允许网页在本地存储数据并有效地离线运行。多媒体 - 在 Open Web 中，视频和音频被视为一等公民（first-class citizens）。2D/3D 图形和特效 - 提供更多种演示选项。性能和集成 - 提供更快的访问速度和性能更好的计算机硬件。设备访问 - 允许使用各种输入、输出设备。外观 - 可以开发丰富的主题。浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 在浏览器的html头部加上manifest属性，如果是第一次访问浏览器会根据manifest的内容进行下载存储离线内容，如果已经访问过则从离线存储中进行加载，然后在比对服务器如果有新内容在更新离线存储 离线的情况下，浏览器就直接使用离线存储的资源。浏览器的渲染过程？1、将获取的html解析成dom树2、处理css，构成层叠样式表模型CSSOM3、将dom树和CSSOM合并为渲染树4、根据CSSOM将渲染树的节点布局计算5、将渲染树节点样式绘制到页面上 // 注意在渲染的过程中是自上而下渲染，js会阻塞页面的渲染，优先等js执行完成如果在渲染的过程中改变了样式，会造成回流需要重新渲染 link和@import的区别？ 1、从属关系区别：link属于html标签，而@import是css提供的。2、加载顺序区别：页面被加载时，link会同时被加载，而@import引用的css会等到页面被加载完再加载。3、兼容性区别：import只在IE5以上才能识别，而link是html标签，无兼容问题。4、dom可操作性区别：可以通过JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式5、权重区别：如果已经存在相同样式，@import引入的这个样式将被该 CSS 文件本身的样式层叠掉，表现出link方式的样式权重高于@import的权重这样的直观效果。（简而言之，link和@import，谁写在后面，谁的样式就被应用，后面的样式覆盖前面的样式。） src与href的区别？ 1、href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。2、src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指","categories":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"}]},{"title":"Bootstrap框架快速上手","slug":"Bootstrap框架快速上手","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T06:54:19.314Z","comments":true,"path":"2022/04/24/Bootstrap框架快速上手/","link":"","permalink":"http://example.com/2022/04/24/Bootstrap%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"","text":"Bootstrap框架快速上手（CDN引入） 版本 Bootstrap v3.4.0 官方文档讲解较细致，但同时也较繁琐，本篇旨在记录常用样式的用法与注意点，同时参考菜鸟教程整理而成。 视频讲解地址：乐字节念安老师B站直达 Bootstrap下载与使用 英文官网：http://getbootstrap.com/ 中文网站：https://getbootstrap.net/ 进入中文网站，选择版本 v3.4.0 下载完成后 拷贝 dist 文件夹到项目中 由于我们之后可能还会使用 LayUi 等其他插件，所以我们将 dist 改为 Bootstrap，方便辨认 将 jQuery.js 放入我们的 js目录下 因为 jQuery.js 并不属于 Bootstrap，所以我们放在 js 目录下 在 html 中模板为 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--使⽤X-UA-Compatible来设置IE浏览器兼容模式 最新的渲染模式--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!-- viewport表示⽤户是否可以缩放⻚⾯； width指定视区的逻辑宽度； device-width指示视区宽度应为设备的屏幕宽度； initial-scale指令⽤于设置Web⻚⾯的初始缩放⽐例 initial-scale=1则将显示未经缩放的Web⽂档 --&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Bootstrap的HTML标准模板&lt;/title&gt; &lt;!--载入 Bootstrap 的css--&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;!-- 如果要使⽤Bootstrap的js插件，必须先调⼊jQuery --&gt; &lt;script src=&quot;js/jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;!-- 包括所有bootstrap的js插件或者可以根据需要使⽤的js插件调⽤ --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意： 如果要使⽤Bootstrap的js插件，必须先调用 jQuery.js 说明： viewport 标记⽤于指定用户是否可以缩放Web页面 width 和 height 指令分别指定视区的逻辑宽度和⾼度。他们的值要么是以像素为单位的数字，要么是⼀个特殊的标记符号。 width 指令使用 device-width 标记可以指示视区宽度应为设备的屏幕宽度。 height 指令使用 device-height 标记指示视区⾼度为设备的屏幕⾼度。 initial-scale 指令用于设置Web页面的初始缩放比例。默认的初始缩放比例值因智能手机浏览器的不同而有所差异。通常情况下设备会在浏览器中呈现出整个Web页面，设为1.0则将显示未经缩放的Web⽂档。 布局容器.container .container 类用于固定宽度并支持响应式布局的容器（网页两侧留白） 123&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt; .container-fluid .container-fluid 类用于 100% 宽度，占据全部视口 (viewport) 的容器（网页两侧不留白） 123&lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt; 栅格网格系统 Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。 Bootstrap框架中的网格系统就是将容器平分成12份。 123456&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;4列&lt;/div&gt; &lt;div class=&quot;col-md-8&quot;&gt;8列&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 注意： 行（row）必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中 具体内容应该放置在列容器 (column) 之内 ```col-屏幕尺寸-列数 12345678910111213141516171819202122232425262728293031323334 ，其中屏幕尺寸有 - `xs`(xsmall phones) 超小屏(自动) - `sm`(small tablets) 小屏(750px) - `md`(middle desktops) 中屏(970px) - `lg`(larger desktops) 大屏(1170px)```html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 布局容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 行元素 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- 列元素 col-xs-数值 col-sm-数值 col-md-数值 col-lg-数值--&gt; &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: red;&quot;&gt;4列&lt;/div&gt; &lt;div class=&quot;col-md-8&quot; style=&quot;background-color: pink;&quot;&gt;8列&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 列组合列组合简单理解就是更改数字来合并列(原则：列总和数不能超12，大于12则自动换到下一行)，有点类似于表格的 colspan 属性 12345678910&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;4列&lt;/div&gt; &lt;div class=&quot;col-md-8&quot;&gt;8列&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-2&quot;&gt;2列&lt;/div&gt; &lt;div class=&quot;col-md-10&quot;&gt;10列&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列偏移 如果我们不希望相邻的两个列紧靠在一起，但又不想使用 margin 或者其他的技术手段来。这个时候就可以使用列偏移 (offset) 功能来实现。 使用列偏移也非常简单，只需要在列元素上添加类名 &quot;col-md-offset-*&quot; (星号代表要偏移的列组合数)，那么具有这个类名的列就会向右偏移。 例如，你在列元素上添加 &quot;col-md-offset-8&quot; ,表示该列向右移动8个列的宽度(要保证列与偏移列的总数不超过12，不然会导致列 断行|换行 显示) 123456789101112&lt;body&gt; &lt;!-- 布局容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 行元素 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- 列元素 --&gt; &lt;div class=&quot;col-md-4 &quot; style=&quot;background-color: red;&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;col-md-2 col-md-offset-4&quot; style=&quot;background-color: pink;&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 列排序123456789&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--向右浮动10列距离--&gt; &lt;div class=&quot;col-md-1 col-md-push-10&quot;&gt; 1列 &lt;/div&gt; &lt;!--向右浮动1列距离--&gt; &lt;div class=&quot;col-md-1 col-md-push-1&quot;&gt; 1列 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列排序就是改变列的方向，就是改变左右浮动，并且设置浮动的距离。 在 Bootstrap 框架的网格系统中是通过 添加类名 col-md-push-* 和 col-md-pull-* (其中星号代表移动的列组合数) 左浮动往前 pull ,右浮动往后 push 我们让第二个盒子向右浮动1个列的距离 123456789101112131415&lt;body&gt; &lt;!-- 布局容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 行元素 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- 列元素 --&gt; &lt;div class=&quot;col-md-1 &quot; style=&quot;background-color: red;&quot;&gt;1&lt;/div&gt; &lt;!-- 第二个盒子向右浮动1个列的距离 --&gt; &lt;div class=&quot;col-md-1 col-md-push-1&quot; style=&quot;background-color: pink;&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;col-md-1 &quot; style=&quot;background-color: greenyellow;&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;col-md-1 &quot; style=&quot;background-color:yellow;&quot;&gt;1&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 我们让第二个盒子向右浮动3个列的距离 123456789101112131415&lt;body&gt; &lt;!-- 布局容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 行元素 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- 列元素 --&gt; &lt;div class=&quot;col-md-1 &quot; style=&quot;background-color: red;&quot;&gt;1&lt;/div&gt; &lt;!-- 第二个盒子向右浮动3个列的距离 --&gt; &lt;div class=&quot;col-md-1 col-md-push-3&quot; style=&quot;background-color: pink;&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;col-md-1 &quot; style=&quot;background-color: greenyellow;&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;col-md-1 &quot; style=&quot;background-color:yellow;&quot;&gt;1&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 列嵌套 列嵌套：你可以在一个列中添加一个或者多个行(row) 容器，然后在这个行容器中插入列。 123456789101112131415161718&lt;body&gt; &lt;!-- 布局容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--先分一个8列--&gt; &lt;div class=&quot;col-md-8&quot; style=&quot;background-color: white ;&quot;&gt; &lt;!--再分的8列里面再分3个4列--&gt; &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: red;&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: green;&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: yellow;&quot;&gt;4&lt;/div&gt; &lt;/div&gt; &lt;!--再分一个4列--&gt; &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: blue ;&quot;&gt;4&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 排版标题 Bootstrap 和普通的 HTML 页面一样，定义标题都是使用标签 &lt;h1&gt; ~ &lt;h6&gt; ，只不过 Bootstrap 覆盖了其默认的样式，使用其在所有浏览器下显示的效果一样， 为了让非标题元素和标题使用相同的样式，还特意定义了 .h1 ~ .h6 六个类名。同时后面可以紧跟着一行小的标题 &lt;small&gt;&lt;/small&gt; 或使用 .small 12345&lt;h1&gt;Bootstrap Heading&lt;small&gt;副标题&lt;/small&gt;&lt;/h1&gt;&lt;div class=&quot;h1&quot;&gt; Bootstrap 标题1 &lt;span class = &quot;small&quot;&gt; 副标题 &lt;/span&gt;&lt;/div&gt; 段落 段落是排版中的另一个重要元素之一。 通过 1.lead 来突出强调内容(其作用就是增大文本字号，加粗文本，而且对行高和margin也做相应的处理)。可以使用以下标签给文本做突出样式处理。 &lt;small&gt; ：小号字 &lt;b&gt;&lt;strong&gt;：加粗 &lt;i&gt;&lt;em&gt;: 斜体 123456789&lt;p&gt;以后的你会感谢现在努力的你&lt;/p&gt;&lt;p class=&quot;lead&quot;&gt;以后的你会感谢现在努力的你&lt;/p&gt;&lt;p class=&quot;lead&quot;&gt; &lt;small&gt;以后的&lt;/small&gt;&lt;!-- 小号字 --&gt; &lt;b&gt;你&lt;/b&gt;会 &lt;!-- 加粗 --&gt; &lt;i&gt;感谢&lt;/i&gt;现在 &lt;!-- 斜体 --&gt; &lt;em&gt;努力&lt;/em&gt;的 &lt;!-- 斜体 --&gt; &lt;strong&gt;你&lt;/strong&gt;&lt;!-- 加粗 --&gt;&lt;/p&gt; 强调颜色定义了一套类名，这里称其为强调类名，这些强调嘞都是通过颜色来表示强调，具体说明如下： .text-muted： 提示，使用浅灰色(#999) .text.primary ：主要，使用蓝色(#428bca) .text-success：成功，使用浅绿色(#3c763d) .text-info：通知信息，使用浅蓝色(#31708f) text-warning：警告，使用黄色(#8a6d3n) text-danger：危险，使用褐色(#a94442) 12345678&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;text-muted&quot;&gt;提示效果&lt;/div&gt; &lt;div class=&quot;text-primary&quot;&gt;主要效果&lt;/div&gt; &lt;div class=&quot;text-success&quot;&gt;成功效果&lt;/div&gt; &lt;div class=&quot;text-info&quot;&gt;信息效果&lt;/div&gt; &lt;div class=&quot;text-warning&quot;&gt;警告效果&lt;/div&gt; &lt;div class=&quot;text-danger&quot;&gt;危险效果&lt;/div&gt; &lt;/div&gt; 对齐效果在CSS中常常使用text-align 来实现文本的对齐风格的设置。 其中主要有四种风格 值 说明 left 左对齐 right 右对齐 center 居中对齐 justify 两端对齐 Bootstrap 中通过定义四个类名来控制文本的对齐风格 类名 说明 text-left 左对齐 text-right 右对齐 text-center 居中对齐 text-justify 两端对齐 12345678 &lt;div class=&quot;container&quot;&gt; &lt;p class=&quot;text-left&quot;&gt;我居左&lt;/p&gt; &lt;p class=&quot;text-center&quot;&gt;我居中&lt;/p&gt; &lt;p class=&quot;text-right&quot;&gt;我居右&lt;/p&gt; &lt;p class=&quot;text-justify&quot;&gt;网格系统的实现原理非常简单，仅仅是通过定义容器大小，平分12份(也有平分成24份或32份，但12份是最常见的)，再调整内外边距，最后结合媒体查询，就制作出了强大的响应式网格系统。Bootstrap框架中的网格系统就是将容器平分成12份 &lt;/p&gt;&lt;/div&gt; 列表无序列表排列顺序无关紧要的一列元素。 123&lt;ul&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ul&gt; 有序列表顺序至关重要的一组元素。 123&lt;ol&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ol&gt; 自定义列表123456&lt;dl&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;超文本标记语言&lt;/dd&gt; &lt;dt&gt;CSS&lt;/dt&gt; &lt;dd&gt;层叠样式表是一种样式表语言&lt;/dd&gt;&lt;/dl&gt; 水平定义列表在原有的基础加入了一些样式，使用样式class=&quot;dl-horizontal&quot; 制作水平定义列表，当标题宽度超过 160px 时，将会显示三个省略号。 12345678&lt;div class=&quot;container&quot;&gt; &lt;dl class=&quot;dl-horizontal&quot;&gt; &lt;dt&gt;HTML 超文本标记语言&lt;/dt&gt; &lt;dd&gt;HTML称为超文本标记语言，是一种标识性的语言。&lt;/dd&gt; &lt;dt&gt;测试标题不能超过160px的宽度,否则2个点&lt;/dt&gt; &lt;dd&gt;我在写一个水平定义列表的效果，我在写一个水平定义列表的效果。&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 去点列表移除了默认的 list-style 样式，也就是去掉了原无序列表前面的点 (去掉项目符号(编号)) 123&lt;ul class=&quot;list-unstyled&quot;&gt; &lt;li&gt;...&lt;/li&gt;&lt;/ul&gt; 内联列表给列表添加class=&quot;list-inline&quot;，把垂直列表换成水平列表，而且去掉项目符号(编号)，将所有元素放置于同一行。也可以说内联列表就是为了制作水平导航而生的。 12345&lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;java学院&lt;/li&gt; &lt;li&gt;在线课堂&lt;/li&gt;&lt;/ul&gt; 代码一般在个人博客上使用的较为频繁，用于显示代码的风格。在 Bootstrap 主要提供了三种代码风格： 使用&lt;code&gt;&lt;/code&gt; 来显示单行内联代码 使用 1&lt;pre&gt;&lt;/pre&gt; 来显示多行块代码 样式pre-scrollable(height，max-height 高度固定为340px，超过则存在滚动条) 使用&lt;kbd&gt;&lt;/kbd&gt; 来显示用户输入代码。如快捷键 单行内联代码1&lt;code&gt;this is a simple code&lt;/code&gt; 快捷键123&lt;p&gt; 使用&lt;kbd&gt;ctrl+s&lt;/kbd&gt;保存&lt;/p&gt; 多行块代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;!-- 1.显示代码原本格式,包括空格和换行 --&gt; &lt;pre&gt; public class HelloWorld &#123; public static void main(String[] args)&#123; System.out.println(&quot;helloworld...&quot;); &#125; &#125; &lt;/pre&gt; &lt;!-- 2.显示html标签的代码需要适应字符实体 小于号（&lt;）要使用硬编码“&amp;lt;”来替代，大于号(&gt;)使用“&amp;gt;”来替代 --&gt; &lt;pre&gt; &lt;h2&gt;Hello World&lt;/h2&gt; &lt;/pre&gt; &lt;pre&gt; &amp;lt;h2&amp;gt;Hello World&amp;lt;/h2&amp;gt; &lt;/pre&gt; &lt;!-- 3.当高度超过，会存在滚动条 --&gt; &lt;pre class=&quot;pre-scrollable&quot;&gt; &lt;ol&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;li&gt;...........&lt;/li&gt; &lt;/ol&gt; &lt;/pre&gt;&lt;/body&gt; 表格Bootstrap 为表格提供了1种基础样式和4种附加样式以及1个支持响应式的表格。在使用Bootstrap得到表格过程种，只需要添加对应的类名就可以得到不同的表格风格。 基础样式 class = &quot;table&quot; ： 基础表格 附加样式 类名 说明 table-striped 斑马线表格 table-bordered 带边框的表格 table-hover 鼠标悬停高亮的表格 table-condensed 紧凑型表格，单元格没内距或者内距较其他表格的内距小 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;table class=&quot;table table-bordered table-striped table-hover table-condensed&quot;&gt; &lt;tr&gt; &lt;th&gt;JavaSE&lt;/th&gt; &lt;th&gt;数据库&lt;/th&gt; &lt;th&gt;JavaScript&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;面向对象&lt;/td&gt; &lt;td&gt;oracle&lt;/td&gt; &lt;td&gt;json&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数组&lt;/td&gt; &lt;td&gt;mysql&lt;/td&gt; &lt;td&gt;ajax&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;面向对象&lt;/td&gt; &lt;td&gt;oracle&lt;/td&gt; &lt;td&gt;json&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数组&lt;/td&gt; &lt;td&gt;mysql&lt;/td&gt; &lt;td&gt;ajax&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; tr、th、td样式提供了五种不同的类名，每种类名控制了行的不同背景颜色 类名 说明 active 将悬停的颜色应用在行或者单元格上 success 表示成功的操作 info 表示信息变化的操作 warning 表示一个警告的操作 danger 表示一个危险的操作 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;table class=&quot;table table-bordered table-striped table-hover table-condensed&quot;&gt; &lt;tr class=&quot;info&quot;&gt; &lt;th&gt;JavaSE&lt;/th&gt; &lt;th&gt;数据库&lt;/th&gt; &lt;th&gt;JavaScript&lt;/th&gt; &lt;/tr&gt; &lt;tr class=&quot;active&quot;&gt; &lt;td&gt;面向对象&lt;/td&gt; &lt;td&gt;oracle&lt;/td&gt; &lt;td&gt;json&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;danger&quot;&gt; &lt;td&gt;数组&lt;/td&gt; &lt;td&gt;mysql&lt;/td&gt; &lt;td&gt;ajax&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;warning&quot;&gt; &lt;td&gt;面向对象&lt;/td&gt; &lt;td&gt;oracle&lt;/td&gt; &lt;td&gt;json&lt;/td&gt; &lt;/tr&gt; &lt;tr class=&quot;success&quot;&gt; &lt;td&gt;数组&lt;/td&gt; &lt;td&gt;mysql&lt;/td&gt; &lt;td&gt;ajax&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 表单表单主要功能是用来和用户做交流的一个网页控件，良好的表单设计能够让网页与用户更好的沟通。表单中常见的元素主要包括： 文本输入框 下拉选择框 单选按钮 复选按钮 文本域和按钮等 表单控件 class=&quot;form-control&quot; 表单元素的样式 class=&quot;input-lg&quot; ：表单控件较大 class=&quot;input-sm&quot; ： 表单控件较小 输入框text 添加class = &quot;form-controll&quot; 123456789101112131415&lt;div class=&quot;container&quot;&gt; &lt;!-- 文本框 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-3&quot;&gt; &lt;!--原格式文本域--&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; /&gt; &lt;!--表单样式文本域--&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;form-control&quot; /&gt; &lt;!--较大文本域--&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;form-control input-lg&quot; /&gt; &lt;!--较小文本域--&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;form-control input-sm&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 下拉选择框select 添加 1class = &quot;form-controll&quot; 多个选择设置multiple=&quot;multuple&quot; 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 原格式下拉框 --&gt; &lt;select&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;hr&gt; &lt;hr&gt; &lt;hr&gt; &lt;!-- 表单样式下拉框 --&gt; &lt;select class=&quot;form-control&quot;&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;hr&gt; &lt;hr&gt; &lt;hr&gt; &lt;!-- 表单样式下拉框提供多个选择 --&gt; &lt;select class=&quot;form-control&quot; multiple=&quot;multuple&quot;&gt; &lt;option &gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/body&gt; 文本域textarea 添加class = &quot;form-controll&quot; 一般都是用栅格来控制文本域的大小 1234567891011121314&lt;div class=&quot;container&quot;&gt; &lt;!-- 占3列的原格式文本域 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-3&quot;&gt; &lt;textarea rows=&quot;3&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;!-- 占6列的文本域 --&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &lt;textarea class=&quot;form-control&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 复选框checkbox 垂直显示(给input标签加)：class=&quot;checkbox&quot; 水平显示(给label标签加)：class=&quot;checkbox-inline&quot; 123456789101112131415161718192021&lt;div class=&quot;container&quot;&gt; &lt;!-- 垂直显示 --&gt; &lt;div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt;&lt;input type=&quot;checkbox&quot; &gt;游戏&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt;&lt;input type=&quot;checkbox&quot; &gt;学习&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 水平显示 --&gt; &lt;div&gt; &lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; &gt;游戏 &lt;/label&gt; &lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; &gt;学习 &lt;/label&gt; &lt;/div&gt;&lt;/div&gt; 单选框radio 垂直显示(给input标签加)：class=&quot;radio&quot; 水平显示(给label标签加)：class=&quot;radio-inline&quot; 123456789101112131415161718192021222324&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!-- 垂直显示 --&gt; &lt;div&gt; &lt;div class=&quot;radio&quot;&gt; &lt;label&gt;&lt;input type=&quot;radio&quot; &gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;radio&quot;&gt; &lt;label&gt;&lt;input type=&quot;radio&quot; &gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 水平显示 --&gt; &lt;div&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; &gt;男 &lt;/label&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; &gt;女 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 按钮①基础样式 基础样式(给button标签加)：class=&quot;btn&quot; 1&lt;button class=&quot;btn&quot;&gt;按钮&lt;/button&gt; ②附加样式 类名 样式 class=&quot;btn btn-default&quot; 默认样式Default class=&quot;btn btn-primary&quot; 首选项Primary class=&quot;btn btn-success&quot; 成功Success class=&quot;btn btn-info&quot; 一般信息Info class=&quot;btn btn-warning&quot; 警告Warning class=&quot;btn btn-danger&quot; 危险Danger class=&quot;btn btn-link&quot; 链接Link 12345678910111213141516171819202122&lt;div class=&quot;container&quot;&gt; &lt;!-- Standard button --&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;（默认样式）Default&lt;/button&gt; &lt;!-- Provides extra visual weight and identifies the primary action in a set of buttons --&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;（首选项）Primary&lt;/button&gt; &lt;!-- Indicates a successful or positive action --&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot;&gt;（成功）Success&lt;/button&gt; &lt;!-- Contextual button for informational alert messages --&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;（一般信息）Info&lt;/button&gt; &lt;!-- Indicates caution should be taken with this action --&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-warning&quot;&gt;（警告）Warning&lt;/button&gt; &lt;!-- Indicates a dangerous or potentially negative action --&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot;&gt;（危险）Danger&lt;/button&gt; &lt;!-- Deemphasize a button by making it look like a link while maintaining button behavior --&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-link&quot;&gt;（链接）Link&lt;/button&gt; &lt;/div&gt; ③多标签支持 多标签支持：使用 a div input 等制作按钮 123456&lt;div class=&quot;container&quot;&gt; &lt;a class=&quot;btn btn-default&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;Link&lt;/a&gt; &lt;button class=&quot;btn btn-default&quot; type=&quot;submit&quot;&gt;Button&lt;/button&gt; &lt;input class=&quot;btn btn-default&quot; type=&quot;button&quot; value=&quot;Input&quot;&gt; &lt;input class=&quot;btn btn-default&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/div&gt; 注意： 虽然按钮类可以应用到 &lt;a&gt; 和 &lt;button&gt; 元素上，但是，导航和导航条组件只支持 &lt;button&gt; 元素。 如果 &lt;a&gt; 元素被作为按钮使用 – 并用于在当前页面触发某些功能 – 而不是用于链接其他页面或链接当前页面中的其他部分，那么，务必为其设置 role=&quot;button&quot; 属性。 我们总结的最佳实践是：强烈建议尽可能使用 &lt;button&gt; 元素来获得在各个浏览器上获得相匹配的绘制效果。 ④设置按钮大小 使用 1.btn-lg 、 1.btn-sm 或 1.btn-xs 就可以获得不同尺寸的按钮 class=&quot;btn-lg&quot; 大按钮 class=&quot;btn-sm&quot; 小按钮 class=&quot;btn-xs&quot; 超小按钮 123456789101112131415161718&lt;div class=&quot;container&quot;&gt; &lt;p&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-lg&quot;&gt;（大按钮）Large button&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-lg&quot;&gt;（大按钮）Large button&lt;/button&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;（默认尺寸）Default button&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;（默认尺寸）Default button&lt;/button&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-sm&quot;&gt;（小按钮）Small button&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-sm&quot;&gt;（小按钮）Small button&lt;/button&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-xs&quot;&gt;（超小尺寸）Extra small button&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-xs&quot;&gt;（超小尺寸）Extra small button&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ⑤按钮禁用 为 &lt;button&gt; 元素添加 disabled=&quot;disabled&quot; 属性，使其表现出禁用状态。 1234&lt;div class=&quot;container&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-lg btn-primary&quot; disabled=&quot;disabled&quot;&gt;Primary button&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-lg&quot; disabled=&quot;disabled&quot;&gt;Button&lt;/button&gt; &lt;/div&gt; 表单布局垂直表单基本的表单结构是 Bootstrap 自带的，个别的表单控件自动接收一些全局样式。下面列出了创建基本表单的步骤： 向父元素&lt;form&gt; 元素 添加 role=&quot;form&quot; 把标签和控件放在一个带有 class=&quot;form-group&quot; 的&lt;div&gt; 中。这是获取最佳间距所必需的 向所有的文本元素 &lt;input&gt; 、&lt;textarea&gt; 、select 添加 class=&quot;form-control&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;body&gt; &lt;form action=&quot;#&quot; class=&quot;form-horizontal&quot; role=&quot;form&quot;&gt; &lt;h2 align=&quot;center&quot;&gt;用户信息表&lt;/h2&gt; &lt;!-- 表单中的表单元素组 --&gt; &lt;!-- 输入框 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;uname&quot; class=&quot;control-label col-md-2&quot;&gt;姓名&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;uname&quot; class=&quot;form-control&quot; placeholder=&quot;请输入姓名&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 输入框 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;upwd&quot; class=&quot;control-label col-md-2&quot;&gt;密码&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;input type=&quot;password&quot; id=&quot;upwd&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 多选框 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;control-label col-md-2&quot;&gt;爱好&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; /&gt;敲代码 &lt;/label&gt; &lt;label class=&quot;checkbox-inline&quot;&gt; &lt;input type=&quot;checkbox&quot; /&gt;跳舞 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 下拉选择框 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;control-label col-md-2&quot;&gt;城市&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;select class=&quot;form-control&quot;&gt; &lt;option&gt;请选择城市&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 文本框 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;remark&quot; class=&quot;control-label col-md-2&quot;&gt;简介&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;textarea id=&quot;remark&quot; class=&quot;form-control&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 按钮 --&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-md-2 col-md-offset-5&quot;&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt; 内联表单 如果需要创建一个表单，它的所有元素是内联的，向左对齐的，标签是并排的，请向 &lt;form&gt; 标签添加 class=&quot;form-inline&quot;。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 内联表单 --&gt; &lt;form action=&quot;#&quot; class=&quot;form-inline&quot; role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;userName&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;userName&quot; class=&quot;form-control&quot; placeholder=&quot;请输入姓名&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;userPwd&quot;&gt;密码&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;userPwd&quot; class=&quot;form-control&quot; placeholder=&quot;请输入姓名&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;userName&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;userName&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;button class=&quot;btn btn-warning&quot;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt; 缩略图字体图标 在我们下载的 Bootstrap 加压文件中有 fonts 文件夹，里面就是我们的字体图标 只需将 fonts 文件夹复制到我们的项目红，我们就可以使用字体图标了 语法： 1&lt;span class=&quot;字体图标类名&quot;&gt; 字体图标 &lt;/span&gt; 字体图标类名地址查看，需要时去复制即可：https://www.runoob.com/try/demo_source/bootstrap3-glyph-icons.htm 缩略图使用 大多数站点都需要在网格中布局图像、视频、文本等。Bootstrap 通过缩略图为此提供了一种简便的方式 使用 Bootstrap 创建缩略图的步骤如下： 在图像周围添加带有 class=&quot;thumbnail&quot; 的 &lt;a&gt; 标签。 这会添加四个像素的内边距（padding）和一个灰色的边框。 当鼠标悬停在图像上时，会动画显示出图像的轮廓。 123456789&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;col-sm-6 col-md-3&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/timg.jpg&quot; alt=&quot;通用的占位符缩略图&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 自定义内容现在我们有了一个基本的缩略图，我们可以向缩略图添加各种 HTML 内容，比如标题、段落或按钮。具体步骤如下： 把带有 class=&quot;thumbnail&quot; 的 &lt;a&gt; 标签改为 &lt;div&gt;。 在该 &lt;div&gt;内，您可以添加任何您想要添加的东西。由于这是一个 &lt;div&gt;，我们可以使用默认的基于 span 的命名规则来调整大小。 如果您想要给多个图像进行分组，请把它们放置在一个无序列表中，且每个列表项向左浮动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div class=&quot;container&quot;&gt; &lt;!-- 第一个缩略图 --&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/timg.jpg&quot; alt=&quot;...&quot;&gt; &lt;h3&gt;高圆圆&lt;/h3&gt; &lt;p&gt;出生于北京市，中国内地影视女演员、模特。&lt;/p&gt; &lt;button class=&quot;btn btn-default&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-heart&quot;&gt;&lt;/span&gt;喜欢 &lt;/button&gt; &lt;button class=&quot;btn btn-info&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-pencil&quot;&gt;&lt;/span&gt;评论 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 第二个缩略图 --&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/timg.jpg&quot; alt=&quot;...&quot;&gt; &lt;h3&gt;高圆圆&lt;/h3&gt; &lt;p&gt;出生于北京市，中国内地影视女演员、模特。&lt;/p&gt; &lt;button class=&quot;btn btn-default&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-heart&quot;&gt;&lt;/span&gt;喜欢 &lt;/button&gt; &lt;button class=&quot;btn btn-info&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-pencil&quot;&gt;&lt;/span&gt;评论 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 第三个缩略图 --&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/timg.jpg&quot; alt=&quot;...&quot;&gt; &lt;h3&gt;高圆圆&lt;/h3&gt; &lt;p&gt;出生于北京市，中国内地影视女演员、模特。&lt;/p&gt; &lt;button class=&quot;btn btn-default&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-heart&quot;&gt;&lt;/span&gt;喜欢 &lt;/button&gt; &lt;button class=&quot;btn btn-info&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-pencil&quot;&gt;&lt;/span&gt;评论 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; .... ....&lt;/div&gt; 面板 面板组件用于把 DOM 组件插入到一个盒子中 创建一个基本的面板，只需要向 &lt;div&gt; 元素添加 class=&quot;panel panel-default&quot; 即可 12345&lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-body&quot;&gt; 这是一个基本的面板 &lt;/div&gt;&lt;/div&gt; 默认的 .panel 组件所做的只是设置基本的边框 border 和 內补 padding 来包含内容 面板 给盒子添加 class=&quot;panel-heading&quot; 可以很简单地向面板添加标题。 给盒子添加 class=&quot;panel-body&quot; 可以向面板添加主题内容 1234567891011121314151617181920&lt;div class=&quot;panel panel-warning&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h2&gt;明星合集&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/timg.jpg&quot; alt=&quot;...&quot;&gt; &lt;h3&gt;高圆圆&lt;/h3&gt; &lt;p&gt;出生于北京市，中国内地影视女演员、模特。&lt;/p&gt; &lt;button class=&quot;btn btn-default&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-heart&quot;&gt;&lt;/span&gt;喜欢&lt;/button&gt; &lt;button class=&quot;btn btn-info&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-pencil&quot;&gt;&lt;/span&gt;评论 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 导航元素标签式的导航菜单 给一个无序列表添加 class=&quot;nav nav-tabs&quot; 给任意一个 li 添加 class=&quot;active&quot;（表示选中这个导航） 12345678910111213&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;标签式的导航菜单&lt;/p&gt; &lt;ul class=&quot;nav nav-tabs&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 胶囊式的导航菜单 给一个无序列表添加 class=&quot;nav nav-pills&quot; 给任意一个 li 添加 class=&quot;active&quot;（表示选中这个导航） 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;p&gt;基本的胶囊式导航菜单&lt;/p&gt; &lt;ul class=&quot;nav nav-pills&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; ①垂直的胶囊式导航菜单 给一个无序列表添加 class=&quot;nav nav-pills&quot; 的同时添加class=&quot;nav-stacked&quot; 给任意一个 li 添加 class=&quot;active&quot;（表示选中这个导航） 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;p&gt;基本的垂直的胶囊式导航菜单&lt;/p&gt; &lt;ul class=&quot;nav nav-pills nav-stacked&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 两端对齐导航 让标签式导航两端对齐：给一个无序列表添加 class=&quot;nav nav-tabs nav-justified&quot; 让胶囊式导航两端对齐：给一个无序列表添加 class=&quot;nav nav-pills nav-justified&quot; 123456789101112131415161718192021&lt;div class=&quot;container&quot;&gt; &lt;p&gt;两端对齐的标签导航元素&lt;/p&gt; &lt;ul class=&quot;nav nav-pills nav-justified&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;hr&gt; &lt;p&gt;两端对齐的胶囊导航元素&lt;/p&gt; &lt;ul class=&quot;nav nav-tabs nav-justified&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;SVN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;VB.Net&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 总结 类 描述 .nav nav-tabs 标签页 .nav nav-pills 胶囊式标签页 .nav nav-pills nav-stacked 胶囊式标签页以垂直方向堆叠排列的 .nav-justified 两端对齐的标签页 分页默认的分页 给一个无序列表添加class=&quot;pagination&quot; 给任意一个 li 添加 class=&quot;active&quot;（表示选中这一页） 123456789101112&lt;div class=&quot;container&quot;&gt; &lt;p&gt;分页导航&lt;/p&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 翻页 给一个无序列表添加class=&quot;pager&quot; 1234567&lt;div class=&quot;container&quot;&gt; &lt;p&gt;翻页导航&lt;/p&gt; &lt;ul class=&quot;pager&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Next&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 插件我们在使用 Bootstrap 插件时 引入 Bootstrap 的核心 CSS 文件 引入 jquery 的核心 js 文件,需要在 bootstrap 的 js 之前引入 引入 Bootstrap 的核心 js 文件 12345678910&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入Bootstrap 的核心CSS文件 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;!-- 引入jquery的核心js文件,需要在bootstrap的js之前引入 --&gt; &lt;script src=&quot;js/jquery-3.4.1.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;!-- 引入Bootstrap 的核心js文件 --&gt; &lt;script src=&quot;bootstrap-3.3.7-dist/js/bootstrap.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/head&gt; 下拉菜单 使用一个 class=&quot;dropdown&quot; 的div 包裹整个下拉框 使用一个 class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; 的按钮作为父菜单 给父菜单后设置一个下拉箭头 使用一个 class=&quot;dropdown-menu&quot; 的 ul 列表作为下拉菜单项 使用 class=&quot;dropdown-header&quot; 的 li 作为分组的标题 使用 class=&quot;driver&quot; 的 li 作为下拉分割线 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;!-- 1.使用一个类名为dropdown 或 btn-group 的div包裹整个下拉框 &lt;div class=&quot;dropdown&quot;&gt;&lt;/div&gt; 默认下拉框向上为 dropup ,向下为 dropdown --&gt; &lt;div class=&quot;dropdown&quot;&gt; &lt;!-- 使用 button 作为父菜单,使用类名: dropdown-toggle 和自定义 data-toggle属性 --&gt; &lt;button class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; 喜欢的频道 &lt;!-- 设置下拉箭头 --&gt; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;!-- 下拉菜单项使用一个 ul 列表,并且定义一个类名为 dropdown-menu --&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;!-- 分组标题: li 添加类名 dropdown-header 来实现分组的功能--&gt; &lt;li class=&quot;dropdown-header&quot;&gt;科普&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;人与自然&lt;/a&gt;&lt;/li&gt; &lt;!-- 分割线: li 添加类名 driver 来实现下拉分割线的功能 --&gt; &lt;li class=&quot;driver&quot;&gt;&lt;/li&gt; &lt;li class=&quot;dropdown-header&quot;&gt;影视&lt;/li&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;快乐大本营&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;暴走大事件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;木鱼水心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 模态框 使用方式一：通过 data 属性：在控制器元素（比如按钮或者链接）上设置属性data-toggle=&quot;modal&quot; ，同时设置 data-target=&quot;#identifier&quot; 或href=&quot;#identifier&quot; 来指定要切换的特定的模态框(带有 id =&quot;identifier&quot; ) 使用方式二：通过 JavaScript：使用这种技术，可以通过简单的一行 JavaScript 来调用带有 id=&quot;identifier&quot; 的模态框： 方式一123456789101112131415161718&lt;!-- 按钮触发模态框 --&gt;&lt;button class=&quot;btn btn-primary btn-lg&quot; data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;&gt;开始演示模态框&lt;/button&gt;&lt;!-- 模态框（Modal） --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;模态框（Modal）标题&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt;在这里添加一些文本&lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;提交更改&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.modal-content --&gt; &lt;/div&gt;&lt;!-- /.modal --&gt;&lt;/div&gt; 方式二调用带有 id=&quot;identifier&quot; 的模态框： 打开模态框：$(&#39;#identifier&#39;).modal(&#39;show&#39;) 关闭模态框：$(&#39;#identifier&#39;).modal(&#39;hide&#39;) 1234567891011121314151617181920212223242526272829303132&lt;/body&gt;&lt;button class=&quot;btn btn-primary btn-lg&quot; id=&quot;btn&quot;&gt;开始演示模态框&lt;/button&gt;&lt;!-- 模态框（Modal） --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;模态框（Modal）标题&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt;在这里添加一些文本&lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;submit_btn&quot;&gt;提交更改&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 绑定按钮的点击事件 $(&quot;#btn&quot;).click(function() &#123; //手动打开模态框 $(&#x27;#myModal&#x27;).modal(&#x27;show&#x27;); &#125;) //关闭模态框 $(&quot;#submit_btn&quot;).click(function() &#123; //手动关闭模态框 $(&#x27;#myModal&#x27;).modal(&#x27;hide&#x27;); &#125;)&lt;/script&gt; 模态框常用改法提供一个模态框的常用改法模板：以添加用户为例(直接复制修改即可) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;/body&gt;&lt;button class=&quot;btn btn-primary btn-lg&quot; id=&quot;btn&quot;&gt;开始演示模态框&lt;/button&gt;&lt;!-- 模态框（Modal） --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;添加用户&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;uname&quot; class=&quot;control-label col-md-2&quot;&gt;姓名&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;uname&quot; class=&quot;form-control&quot; placeholder=&quot;请输入姓名&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;upwd&quot; class=&quot;control-label col-md-2&quot;&gt;密码&lt;/label&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;upwd&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;submit_btn&quot;&gt;提交更改&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /.modal-content --&gt; &lt;/div&gt; &lt;!-- /.modal --&gt;&lt;/div&gt;&lt;script&gt; // 绑定按钮的点击事件 $(&quot;#btn&quot;).click(function() &#123; //手动打开模态框 $(&#x27;#myModal&#x27;).modal(&#x27;show&#x27;); &#125;) //关闭模态框 $(&quot;#submit_btn&quot;).click(function() &#123; //手动关闭模态框 $(&#x27;#myModal&#x27;).modal(&#x27;hide&#x27;); &#125;)&lt;/script&gt;","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://example.com/categories/Bootstrap/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://example.com/tags/Bootstrap/"}]},{"title":"CSS基础笔记(一)","slug":"CSS基础笔记(一)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T07:01:00.214Z","comments":true,"path":"2022/04/24/CSS基础笔记(一)/","link":"","permalink":"http://example.com/2022/04/24/CSS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0(%E4%B8%80)/","excerpt":"","text":"✍目录总览 标签基础选择器🔥标签选择器🔥 标签选择器的作用是为页面中某一类标签指定统一的CSS样式 优点是能快速为页面中同类型的标签统一设置样式 缺点是不能设计差异化样式，只能选择全部的当前标签 规范： 属性值前面，冒号后面，保留一个空格 标签名和大括号中间保留空格 类选择器🔥如果想要差异化选择不同的标签，单独选一个或者几个标签，可以使用类选择器 结构需要用class属性来调用 注意： 类选择器在 HTML 中以 class 属性表示，在CSS中，类选择器以一个点 . 号表示 记忆口诀：样式点定义，结构类调用 类选择器多类名🔥 我们可以给一个标签指定多个类名，简单理解就是一个标签有多个名字 在标签 class 属性中写多个类名 多个类名中间必须用空格分开 这个标签就可以分别具有这些类名的样式 ✍多类名开发中使用场景： 可以把一些标签元素相同的样式(公共的部分)放到一个类里面 这些标签都可以调用这个公共的类，然后再调用自己独有的类 从而节省CSS代码，统一修改也方便 id选择器🔥 id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式 HTML 元素以 id属性 来设置 id 选择器，CSS中 id 选择器 以 “#” 来定义 注意： id 属性只能在每个 HTML 文档中出现一次。 记忆口诀：样式 # 定义，结构 id 调用。只能调用一次，别人切勿使用 区别🔥id选择器和类选择器的区别？ 类选择器（class）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用 id 选择器好比人的身份证号码，全中国是唯一的，不得重复。 id 选择器和类选择器最大的不同在于使用次数上 类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用。 记忆口诀： 样式点定义，结构类调用 样式 # 定义，结构 id 调用 通配符选择器🔥 CSS 中， 通配符使用 * 定义，它表示选取页面中所有元素(标签)。 通配符选择器不需要调用，自动就给所有的元素使用样式 一般是用于清楚元素标签的内外边距 基础选择器总结🔥 基础选择器 作用 特点 使用情况 语法 标签选择器 可以选出所有相同的标签 不能差异化选择 较多 p {color: red} 类选择器 可以选出1个或者多个标签 可以根据需求选择 非常多 .nav {color: red} id 选择器 一次只能选择1个标签 ID 属性只能在每个 HTML 文档中出现一次 一般和 js 搭配 #nav {color: red} 通配符选择器 选择所有的标签 选择的太多，有部分不需要 特殊情况使用 * {color: red} CSS字体属性🔥CSS 字体属性用于定义字体系列、大小、粗细和文字样式(如斜体) font-family🔥 CSS 使用 font-family 属性设置文本的字体系列 各种字体之间必须使用英文状态下的逗号隔开 一般情况下，如果有空格隔开的多个单词组成的字体，加引号 最常见的几个字体： font-size🔥 CSS 使用 font-size 属性设置字体大小 px (像素)大小是我们网页的最常用的单位 谷歌浏览器默认的文字大小为 16px font-weight🔥 wite-space: nowrap(强制一行显示) CSS 使用 font-weight 属性设置字体的粗细 属性值 描述 normal 默认值(不加粗的)，相当于number=400 bold 定义粗体(加粗的)，相当于number=700 bolder 定义特粗体 100-900 400等同于 normal，700等同于 bold，注意这个数字后面不跟单位 实际开发中，我们更喜欢用数字表示粗细 font-style🔥 CSS 使用 font-style 属性设置文字样式 属性值 作用 normal 默认值，浏览器会显示标准的字体样式 italic 浏览器会显示斜体的字体样式 注意：平时我们很少给文字加斜体，反而要给斜体标签( em , i )改为不倾斜字体 字体属性复合写法🔥字体复合属性可以把以上文字样式综合来写，这样写更节约代码，例如： 顺序：文字样式 文字粗细 文字大小 文字字体 使用font属性时，必须按照上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开 不需要设置的属性可以省略(取默认值)，但必须保留font-size 和font-family属性，否则 font 属性将不起作用 字体属性总结🔥 属性 表示 注意点 font-style 字体样式 记住倾斜是 italic，不倾斜是 normal，实际开发最常用 normal font-weight 字体粗细 加粗是 700 或者 bold ，不加粗是 normal 或者 400，记住数字不加单位 font-size 字号 我们通常用的单位是 px ，一定要跟上单位 font-family 字体 实际工作中按照团队约定来写字体 font 字体连写 ①字体连写是有顺序的，不能随意换位置 ② 字体和字号必须同时出现 CSS文本属性🔥CSS 文本属性可以设置文本的 外观，比如文本颜色、对齐文本、装饰文本、文本缩进、行间距的等 color🔥 color 属性用于定义文本的颜色 表示 属性值 预定义的颜色值 red，green，blue，pink等 十六进制 #FF0000, #FF6600，#29D794 RGB代码 rgb（255，0，0） 或rgb(100%，0%，0%) 实际开发中最常用的是十六进制。 text-align🔥 text-align 属性用于设置文本内容的水平对齐方式 属性值 解释 left 左对齐（默认） right 右对齐 center 居中对齐 text-decoration🔥 text-decoration 属性用于装饰文本，可以给文本添加下划线，删除线，上划线等 属性值 描述 none 默认。没有装饰线(最常用) underline 下划线，链接自带下划线（常用） overline 上划线(几乎不用) line-through 删除线 (不常用) 重点记住如何添加下划线，如何删除下划线，其余了解即可。 text-indent🔥 text-indent 属性用于指定文本的第一行缩进，通常是将段落的首行缩进 通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值 em是一个相对单位，就是当前元素(font-size)1个文字的大小 如果当前元素没有设置大小，则会按照父元素的一个文字大小 line-height🔥 line-height 属性用于设置行间的距离(行高)，可以控制文字行与行之间的距离 行间距包括上间距、文本高度、下间距 文本属性总结🔥 属性 表示 注意点 color 文本颜色 通常用十六进制，而且是简写形式 #fff text-align 文本对齐 可以设定文字水平的对齐方式 text-indent 文本缩进 段落首行缩进 text-decoration 文本修饰 记住添加下划线 underline 取消下划线 none line-height 行高 控制行与行之间的距离 CSS复合选择器🔥复合选择器：是由两个或多个基础选择器，通过不同的方式组合而成的 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器 后代选择器🔥 后代选择器又称为包含选择器，可以选择父元素里面的子元素 其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔，当标签发生嵌套时，内层标签就称为外层标签的后代 上述语法表示**选择元素1里面的所有元素2(后代元素)**，例如 元素1 和 元素2 中间用空格隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 子选择器🔥 子元素选择器只能选择作为某元素的最近一级子元素，简单理解就是选亲儿子元素。 上述语法表示选择元素1 里面的所有直接后代(子元素)元素2，例如 元素1 和 元素2 中间用大于号隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2必须是亲儿子，其孙子、重孙之类都不归他管 并集选择器🔥并集选择器可以选择多组标签，同时为它们定义相同的样式。 并集选择器是各选择器通过英文逗号连接而成 任何形式的选择器都可以作为并集选择器的一部分 上述语法表示选择元素1和元素2，例如 元素1 和 元素2 中间用逗号隔开 逗号可以理解为和的意思 并集选择器通常用于集体声明 伪类选择器🔥 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素 伪类选择器书写最大的特点是用冒号(😃表示，比如 :hover、:first-child 伪类选择器很多，比如有链接伪类、结构伪类，这里先记录常用的链接伪类选择器 链接伪类选择器🔥:focus伪类选择器🔥 :focus伪类选择器用于选取获得焦点的表单元素 焦点就是光标，一般情况&lt;input&gt;类表单元素才能获取，因此这个选择器也主要针对表单元素来说 复合选择器总结🔥 选择器 作用 特征 使用情况 隔开符号及用法 后代选择器 用来选择后代元素 可以是子孙后代 较多 符号是空格 .nav a 子代选择器 选择最近一级元素 只选亲儿子 较少 符号是大于 .nav&gt;p 并集选择器 选择某些相同样式的元素 可以用于集团声明 较多 符号是逗号 .nav,.header 链接伪类选择器 选择不同状态的链接 跟链接相关 较多 重点记住a&#123;&#125;和a:hover ，实际开发的写法 :focus选择器 选择获得光标的表单 跟表单相关 较少 input:focus 记住这个写法 CSS元素显示模式🔥块元素🔥 常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt; 标签是最典型的块元素。 块级元素的特点： ①：比较霸道，自己独占一行 ②：高度，宽度，外边距以及内边距都可以控制 ③：宽度默认是容器（父级宽度）的100% ④：是一个容器及盒子，里面可以放行内或块级元素 注意： ①：文字类的元素内不能使用块级元素 ②：&lt;p&gt; 标签主要用于存放文字，因此&lt;p&gt;里面不能放块级元素，特别是不能放&lt;div&gt; ③：同理，&lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能存放其他块级元素。 行内元素🔥 常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等 其中&lt;span&gt;标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 行内元素的特点： ①：相邻行内元素在一行上，一行可以显示多个 ②：高，宽直接设置是无效的 ③：默认宽度就是它本身内容的宽度 ④：行内元素只能容纳文本或其他行内元素 注意： 链接里面不能再放链接 特殊情况链接&lt;a&gt;里面可以放块级元素，但是给&lt;a&gt;转换一下块级模式最安全 行内块元素🔥 在行内元素中有几个特殊的标签 —— &lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，它们同时具有块元素和行内元素的特点 有些资料称它们为行内块元素 特点： ①：和相邻行内元素在一行上，但是他们之间会有空白缝隙。一行可以显示多个(行内元素特点) ②：默认宽度就是它本身内容的宽度(行内元素特点) ③：高度，行高，外边距以及内边距都可以控制(块级元素特点) 元素显示模式总结🔥 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽度高度 容器的100% 容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽度高度 它本身内容的宽度 容纳文本或其他行内元素 行内块元素 一行放多个行内块元素 可以设置宽度高度 它本身内容的宽度 元素显示模式转换🔥 转换为块元素： display:block 转换为行内元素： display:inline 转换为行内块元素: display:inline-block 👉小技巧🔥CSS没有给我们提供文字垂直居中的代码，这里我们可以用一个小技巧来实现单行文字垂直居中 解决方案： 让文字的行高等于盒子的高度，就可以让文字在当前盒子内垂直居中。 简单理解： 行高的上空隙和下空隙把文字挤到中间了 如果是行高小于盒子高度，文字会偏上，如果行高大于盒子高度，则文字偏下 CSS背景🔥通过 CSS 背景属性，可以给页面元素添加背景样式。 背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。 background-color🔥 background-color 属性定义了元素的背景颜色 一般情况下默认颜色是transparent（透明），我们也可以手动指定背景颜色为透明色 background-image🔥 background-image 属性描述了元素的背景图像。 参数值 作用 none 无背景图（默认） url 使用绝对或相地址指定的背景图像 注意：背景图片后面的地址，千万不要忘记加URL，同时里面的路径不要加引号。 background-repeat🔥 background-repeat 属性定义背景图像的平铺 参数值 作用 repeat 背景图像在纵向和横向上平铺(默认的) no-repeat 背景图像不平铺 repeat-x 背景图像在横向上平铺 repeat-y 背景图像在纵向平铺 background-position🔥 background-position 属性可以改变图片在背景中的位置 参数：X坐标 Y坐标 可以使用 方位名词 或者 精确单位 参数值 说明 length 百分数|由浮点数字和单位标识符组成的长度值 position top| center | bottom |left |center |right 方位名词 参数是方位名词 ①：如果指定的两个值都是方位名词，则两个值前后顺序无关，比如left top和top left ②：如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 参数是精准单位 ①：如果参数值是精确坐标，那么第一个肯定是x坐标，第二个一定是y坐标 ②：如果只指定一个数值，那该数值一定是x坐标，另一个默认垂直居中 参数是混合单位 ①：如果指定的两个值是精确单位和方位名词混合使用，则第一个值是x坐标，第二个值是y坐标 background-attachment🔥 background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动 参数 作用 scroll 背景图像是随对象内容滚动 fixed 背景图像固定 背景复合写法🔥 background ： 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置 这是实际开发中，我们更提倡的写法。 背景色半透明🔥CSS3为我们提供了背景颜色半透明的效果 最后一个参数是alpha 透明度 ，取值范围在0~1之间 我们习惯把0.3的 0省略掉，写为background(0,0,0,.3); 注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响 背景总结🔥 属性 作用 值 background-color 背景颜色 预定义的颜色值/十六进制/RGB代码 background-image 背景图片 url(图片路径) background-repeat 是否平铺 repeat/ no-repeat /repeat-x/repeat-y background-position 背景位置 length/position 分别是x 和y坐标 background-attachment 背景附着 scroll(背景滚动) /fixed(背景固定) 背景简写 书写更简单 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 背景色半透明 背景颜色半透明 background : rgba(0,0,0,0.3);后面必须是四个值 背景图片:实际开发常见于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置.","categories":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"CSS基础笔记(三)","slug":"CSS基础笔记(三)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T07:06:24.987Z","comments":true,"path":"2022/04/24/CSS基础笔记(三)/","link":"","permalink":"http://example.com/2022/04/24/CSS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0(%E4%B8%89)/","excerpt":"","text":"✍目录总览 新增选择器🔥CSS3 给我们新增了选择器，可以更加便捷，更加自由的选择目标元素。 属性选择器 结构伪类选择器 伪元素选择器 属性选择器🔥 属性选择器可以根据元素特定的属性来选择元素，这样就可以不用借助于类或者id选择器 选择符 简介 E[att] 选择具有att属性的E元素 E[att=“val”] 选择具有att属性且属性值等于val的E元素 E[att^=“val”] 匹配具有att属性且值以val开头的E元素 E[att$=“val”] 匹配具有att属性且值以val结尾的E元素 E[att*=“val”] 匹配具有att属性且值中含有val的E元素 利用属性选择器就可以不借助于类或者id选择器 属性选择器还可以选择 属性 = 值的某些元素 属性选择器可以选择属性值开头的某些元素 属性选择器可以选择属性值结尾的某些元素 注意：类选择器，属性选择器，伪类选择器，权重为10 结构伪类选择器🔥 结构伪类选择器主要根据文档结构来选择元素 常用于根据父级选择器选择里面的子元素 选择符 简介 E:first-child 匹配父元素中的第一个子元素E E:last-child 匹配父元素中最后一个E元素 E:nth-child(n) 匹配父元素中的第n个子元素E E:first-of-type 指定类型E的第一个 E:last-of-type 指定类型E的最后一个 E:nth-of-type（n） 指定类型E的第n个 ①、E:first-child 和E:last-child②、nth-child(n) nth-child(n)选择某个父级元素的一个或多个特定的子元素（重点） n可以是数字，关键字和公式 n如果是数字，就是选择第n个子元素，里面数字从1开始 n可以是关键字：even 偶数，odd奇数 n可以是公式：常见的公式如下（如果n是公式，则从0开始计算，但是第0个元素或者超出了元素的个数会被忽略） 公式 取值 2n 偶数（等价于even） 2n+1 奇数（等价于odd） 5n 5 10 15 …（5的倍数） n+5 从第5个开始（包含第五个）到最后 -n+5 前5个（包含第5个） ③、E:first-of-type和E:last-of-type E:first-of-type 指定类型E的第一个 E:last-of-type 指定类型E的最后一个 ④、区别 nth-child(n) 123和 nth-of-type(n) 区别? nth-child 对父元素里面所有孩子排序选择(序号是固定的)，先找到第n个孩子，然后看看是否和E匹配 nth-of-type 对父元素里面指定子元素进行排序选择，先去匹配E,然后再根据E 找第n个孩子 ⑤、小结 结构伪类选择器一般用于选择父级里面的第几个孩子 nth-child 对父元素里面所有孩子排序选择（序号是固定的），先找到第n个孩子，然后看看是否和E匹配 nth-of-type 对父元素里面指定子元素进行排序选择，先去匹配E，然后再根据E找第n个孩子 关于nth-child(n)， 我们要知道n是从0开始计算的，要记住常用的公式 如果是无序列表，我们肯定用 nth-child 更多 类选择器，属性选择器，伪类选择器，权重为10 伪元素选择器🔥 伪元素选择器可以帮我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构 选择符 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 注意： before 和 after 创建一个元素，但是是属于行内元素 before和after 都是一个盒子，都作为父元素的孩子 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素 语法： before是放在内容的前面，after是放在了内容的后面 before 和 after 必须有 content 属性 before 在父元素内容的前面创建元素 ，after 在父元素内容的后面插入元素 伪元素选择器 和 标签选择器 一样，权重为1 CSS3盒子模型🔥 CSS3 中可以通过box-sizing 来指定盒模型 有2个值：这样我们计算盒子大小的方式就发生了改变 content-box border-box content-box 第一种情况是 CSS 的盒子模型，盒子大小为 width + padding + border 此种情况盒子大小为 宽度 + 内边距 + 边框，这也是我们之前写盒子所默认的 border-box🔥 第二种情况是 CSS3 的盒子模型，盒子大小为 width 此种情况盒子大小为 宽度，不包括内边距和边框，这样 padding 和 border 就不会撑大盒子了(前提是 padding 和 border 不会超过 width 宽度) 我们可以在以后的 css 通配符中添加 CSS3 盒子模型 C3其他特性滤镜filter filter: CSS属性将模糊或颜色偏移等图形效果应用于元素(图片变模糊) 语法： 模糊处理：blur,数值越大越模糊 calc函数 calc() 此CSS函数让你在声明CSS属性值时执行一些计算（计算盒子宽度 width: calc 函数） 括号里面可以使用 + - * / 来进行计算 transition过渡🔥 过渡（transition) 是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果 过渡动画：是从一个状态渐渐的过渡到另外一个状态 过渡经常和：hover一起搭配使用 要过渡的属性：想要变化的 CSS 属性，宽度高度，背景颜色，内外边距都可以，如果想要所有的属性都变化过渡，写一个all就可以。 花费时间：单位是秒(必须写单位) 比如0.5s 运动曲线：默认是ease(可以省略) 何时开始：单位是秒(必须写单位)，可以设置延迟触发事件，默认是0s(可以省略) 过渡的口诀：谁做过渡给谁加 2D转换🔥转换(transform)是CSS3中具有颠覆性的特征之一，可以实现元素的位移，旋转，缩放等效果 移动：translate 旋转：rotate 缩放：scale 二维坐标系： 2D转换是改变标签在二维平面上的位置和形状的一种技术，先来学习二维坐标系 ①移动translate🔥2D移动是2D转换里面的一种功能，可以改变元素在页面中的位置，类似定位。 语法： 定义2D转换中的移动，沿着X和Y轴移动元素 translate 最大的优点：不会影响到其他元素的位置 translate 中的百分比单位是 相对于自身元素 的 translate:(50%,50%); 对行内标签没有效果 ②旋转rotate🔥2D旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转。 rotate 里面跟度数，单位是 deg 比如 rotate(45deg) 角度为正时，顺时针，负时，为逆时针 默认旋转的中心点是元素的中心点 ③旋转中心点transform-origin🔥2D转换中心点：我们可以设置元素转换的中心点 transform-origin 注意后面的参数x 和 y 用空格隔开 x y 默认转换的中心点是元素的中心点(50% 50%) 还可以给x y 设置 像素或者方位名词(top bottom left right center) 缩放scale🔥缩放：scale,只要给元素添加上了这个属性就能控制它放大还是缩小 注意其中的x和y用逗号分割 transform:scale(1,1): 宽和高都放大一倍，相当于没有放大 transform:scale(2,2)：宽和高都放大了2倍 transform:scale(2)：只写一个参数，第二个参数则和第一个参数一样，相当于 scale(2,2) transform:scale(0.5,0.5)：缩小 sacle缩放最大的优势：可以设置转换中心点缩放，默认以中心点缩放的，而且不影响其他盒子 2D转换综合写法🔥 同时使用多个转换，其格式为: transform:translate() rotate() scale() 移动-旋转-缩放 其顺序会影响转换的效果(先旋转会改变坐标轴方向) 当我们同时有位移和其他属性时候，记得要将位移放到最前面 2D转换总结🔥 转换transform 我们简单理解就是变形 有2D 和 3D 之分 我们暂且学了三个 分别是 位移 旋转 和 缩放 2D 移动 translate(x, y) 最大的优势是不影响其他盒子， 里面参数用%，是相对于自身宽度和高度来计算的 可以分开写比如 translateX(x) 和 translateY(y) 2D 旋转 rotate(度数) 可以实现旋转元素 度数的单位是deg 2D 缩放 sacle(x,y) 里面参数是数字 不跟单位 可以是小数 最大的优势 不影响其他盒子 设置转换中心点 transform-origin : x y; 参数可以百分比、像素或者是方位名词 l当我们进行综合写法，同时有位移和其他属性的时候，记得要将位移放到最前 C3动画🔥动画 animation是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 相比较过渡，动画可以实现更多变化，更多控制，连续自动播放等效果。 制作动画分为两步： 先定义动画 再使用（调用）动画 用keyframs定义动画🔥用 keyframes 定义动画（类似定义类选择器） 0% 是动画的开始，100% 是动画的完成。这样的规则就是动画序列。 在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果 动画是使元素从一种样式逐渐变化为另一种样式的效果。您可以改变任意多的样式任意多的次数。 请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。 @keyframes mymove { from {background-color:red;} to {background-color:blue;} } 使用动画🔥示例需求：我们想页面一打开，一个盒子就从左边走到右边 from to 语法 动画常用属性🔥 属性 描述 @keyframes 规定动画。 animation 所有动画属性的简写属性，除了animation-play-state属性。 animation-name 规定@keyframes动画的名称。（必须的） animation-duration 规定动画完成一个周期所花费的秒或毫秒，默认是0。（必须的） animation-timing-function 规定动画的速度曲线，默认是“ease”。 animation-delay 规定动画何时开始，默认是0。 animation-iteration-count 规定动画被播放的次数，默认是1，还有infinite animation-direction 规定动画是否在下一周期逆向播放，默认是“normal“,alternate逆播放 animation-play-state 规定动画是否正在运行或暂停。默认是”running”,还有”paused”。 animation-fill-mode 规定动画结束后状态，保持forwards回到起始backwards 动画的简写属性 动画简写属性🔥animation：动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态; 简写属性里面不包含 animation-play-state 暂停动画：animation-play-state: puased; 经常和鼠标经过等其他配合使用 想要动画走回来 ，而不是直接跳回来：animation-direction: alternate 盒子动画结束后，停在结束位置： animation-fill-mode : forwards 速度曲线细节 animation-timing-function：规定动画的速度曲线，默认是“ease” 值 描述 linear 动画从头到尾的速度是相同的。匀速 ease 默认。动画以低速开始，然后加快，在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 steps() 指定了时间函数中的间隔数量（步长） 3D转换🔥我们生活的环境是3D的，照片就是3D物体在2D平面呈现的例子. 3D转换的特点： 近大远小。 物体后面遮挡不可见 当我们在网页上构建3D效果的时候参考这些特点就能产出3D效果。 三维坐标系🔥三维坐标系其实就是指立体空间，立体空间是由3个轴共同组成的。 x轴：水平向右 注意： x 右边是正值，左边是负值 y轴：垂直向下 注意： y 下面是正值，上面是负值 z轴：垂直屏幕 注意： 往外面是正值，往里面是负值 3D 转换我们主要学习工作中最常用的 3D 位移 和 3D 旋转 3D位移translate3d🔥3D移动在2D移动的基础上多加了一个可以移动的方向，就是z轴方向 translform:translateX(100px)：仅仅是在x轴上移动 translform:translateY(100px)：仅仅是在Y轴上移动 translform:translateZ(100px)：仅仅是在Z轴上移动（注意：translateZ一般用px单位） transform:translate3d(x,y,z)：其中 x、y、z 分别指要移动的轴的方向的距离 因为z轴是垂直屏幕，由里指向外面，所以默认是看不到元素在z轴的方向上移动 透视perspective🔥透视：在2D平面产生近大远小视觉立体，但是只是效果二维的 如果想要在网页产生3D效果需要透视（理解成3D物体投影在2D平面内） 模拟人类的视觉位置，可认为安排一只眼睛去看 透视我们也称为视距：视距就是人的眼睛到屏幕的距离 距离视觉点越近的在电脑平面成像越大，越远成像越小 透视的单位是像素 透视写在被观察元素的父盒子上面的 d：就是视距，视距就是一个距离人的眼睛到屏幕的距离。 z：就是 z轴，物体距离屏幕的距离，z轴越大（正值） 我们看到的物体就越大 ①translateZ🔥 translform:translateZ(100px)：仅仅是在Z轴上移动。 有了透视，就能看到translateZ 引起的变化了 translateZ：近大远小 translateZ：往外是正值 translateZ：往里是负值 5.4、D旋转rotate3d🔥3D旋转：3D旋转指可以让元素在三维平面内沿着 x轴，y轴，z轴或者自定义轴进行旋转。 transform: rotateX(45deg) ：沿着X轴正方向旋转45度 transform: rotateY(45deg) ：沿着Y轴正方向旋转45度 transform: rotateZ(45deg) ：沿着Z轴正方向旋转45度 transform: rotate3d(x,y,z,deg) ：沿着自定义轴旋转 deg为角度(了解即可) xyz是表示旋转轴的矢量，是标示你是否希望沿着该轴旋转，最后一个标示旋转的角度。 👉左手准则① 左手的手拇指指向 x轴的正方向 其余手指的弯曲方向就是该元素沿着x轴旋转的方向 👉左手准则② 左手的手拇指指向 y轴的正方向 其余手指的弯曲方向就是该元素沿着y轴旋转的方向（正值） 3D呈现transform-style🔥3D呈现：transform-style 控制子元素是否开启三维立体环境 transform-style: flat 子元素不开启3d立体空间 默认的 transform-style: preserve-3d 子元素开启立体空间 代码写给父级，但是影响的是子盒子 这个属性很重要","categories":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"CSS进阶笔记(四)","slug":"CSS进阶笔记(四)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T07:08:33.904Z","comments":true,"path":"2022/04/24/CSS进阶笔记(四)/","link":"","permalink":"http://example.com/2022/04/24/CSS%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0(%E5%9B%9B)/","excerpt":"","text":"✍目录总览 精灵图Sprites🔥 为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术 核心原理：将网页中的一些小背景图像整合到一张大图中，这样服务器只需要一次请求就可以了 精灵图的使用🔥使用精灵图的核心： 精灵技术主要针对于背景图片的使用，就是把多个小背景图片整合到一张大图片中 这个大图片也称为 sprites 精灵图 或者 雪碧图 移动背景图片的位置，此时可以使用 background-position 移动的距离就是这个目标图片的x和y坐标，注意网页中的坐标有所不同（x轴右边走是正值，左边走是负值，y轴下边走是正值，上边走是负值） 一般情况下都是往上往左移动，所以数值是负值 使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。 精灵图的优点很多，但是缺点也很明显 图片文件还是比较大的 图片本身放大和缩小会失真 一旦图片制作完毕想要更换非常复杂 此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont 字体图标iconfont🔥字体图标使用场景： 主要用于显示网页中通用、常用的一些小图标。展示的是图标，本质属于字体 优点： 轻量级：一个图标字体比一系列的图像要小，一旦字体加载了，图标就会马上渲染出来，减少了服务器的请求 灵活性：本质其实是文字，可以很随意的改变颜色，产生阴影，透明效果，旋转等 兼容性：几乎支持所有的浏览器 步骤： 字体图标的下载 字体图标的引入(引入到我们html页面中) 字体图标的追加(以后添加新的小图标) 字体图标的下载🔥 icomoon字库 外网，不需要登录即可下载 http://icomoon.io 点击 IcoMoon App 选择需要的图标 点击Generate Font 点击 下载 阿里iconfont字库 免费，但是需要登录 http://www.iconfont.cn/ 字体图标的引入🔥我们以 icomoon 字库网为例，将下载包解压，解压之后的文件如图： 把下载包里面的 fonts 文件夹放入页面根目录下 在CSS样式中全局声明字体：简单理解把这些字体通过css引入到我们页面中 右键打开 style.css，这里我演示用notepad++打开，复制如图代码引入我们自己的CSS文件中 html标签内添加小图标 我们打开解压文件中的 demo.html ，复制想要的图标，粘贴进我们的 &lt;span&gt;&lt;/span&gt;标签中 给标签定义字体 注意：标签中的 font-family 的值和我们之前引入字体图标的font-family 必须一样，这里均为 icomoon 完成，所以我们的整体代码为： 测试效果为： 字体图标的追加🔥 如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标到原来的字体文件中。 以 icomoon字库 网为例，点击网站内import icons 把压缩包里面的 selection.json 重新上传，然后选中自己想要新的图标，重新下载压缩包，并替换原来的文件即可。 字体文件格式不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件。 .ttf 格式、.woff 格式、.eot 格式、.svg 格式，不同浏览器支持不同的格式 字体图标总结 如果遇到一些结构和样式比较简单的小图标，就用字体图标 如果遇到一些结构和样式复杂一点的小图片，就用精灵图 界面样式🔥所谓的界面样式，就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 表单轮廓 防止表单域拖拽 鼠标样式cursor🔥鼠标样式cursor 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状 属性值 描述 default 小白，默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 轮廓线outline🔥轮廓线outline： 给表单添加 outline:0; 或者outline: none;样式后，就可以去掉默认的蓝色边框 防止拖拽文本域防止拖拽文本域resize vertical-align🔥vertical-align: 使用场景：经常用于设置图片或者**表单（行内块元素）**和**文字垂直对齐**。 官方解释：用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效 值 描述 baseline 默认，元素放置在父元素的基线上 top 把元素的顶端与行中最高元素的顶端对齐（顶线对齐） middle 把此元素放置在父元素的中部（中线对齐） bottom 把元素的顶端与行中最低的元素的顶端对齐（底线对齐） 图片、表单和文字对齐🔥图片、表单都属于行内块元素，默认的 vertical-align 是基线对齐。 此时可以给图片、表单这些行内块元素的 vertical-align 属性设置为 middle 就可以让文字和图片垂直居中对齐了。 图片底侧空白缝隙解决🔥 bug：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐（给图片加边框就可以看见） 主要解决办法有两种： 给图片添加 vertical-align : middle | top |bottom 等 把图片转换为块级元素 display:block;，因为块级元素不会有vertical-align 属性 溢出文字省略显示🔥单行文本溢出省略号显示🔥必须满足三个条件： 多行文本溢出显示省略号显示多行文本溢出显示省略号，有较大的兼容性问题，适合于webKit浏览器或移动端(移动端大部分是webKit内核) 更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。 常见布局技巧🔥margin负值的运用🔥 两个盒子加边框1px，浮动，贴紧会出现 1 + 1 = 2px 给右边盒子添加margin-left: -1px 正数向右边走，负数向左边走 当我们有多个盒子时的解决办法： 让每个盒子 margin 往左侧移动 -1px 正好压住相邻盒子边框 鼠标经过某个盒子的时候，提高当前盒子的层级即可 如果没有定位，则加相对定位(保留位置) 如果有定位，则加 z-index 文字围绕浮动元素🔥巧妙运用浮动元素不会压住文字的特性 行内块巧妙运用🔥","categories":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"CSS进阶笔记(五)","slug":"CSS进阶笔记(五)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T07:12:08.525Z","comments":true,"path":"2022/04/24/CSS进阶笔记(五)/","link":"","permalink":"http://example.com/2022/04/24/CSS%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B0(%E4%BA%94)/","excerpt":"","text":"✍、目录总览 移动Web开发浏览器现状 国内的 UC 和 QQ，百度等手机浏览器都是根据 Webkit 修改过来的内核，国内尚无自主研发的内核。 总结：兼容移动端主流浏览器，处理 Webkit 内核浏览器即可。 手机屏幕现状 移动端设备屏幕尺寸非常多，碎片化严重。 Android设备有多种分辨率：480x800, 480x854, 540x960, 720x1280，1080x1920等，还有传说中的2K，4k屏。 近年来iPhone的碎片化也加剧了，其设备的主要分辨率有：640x960, 640x1136, 750x1334, 1242x2208等。 作为开发者无需关注这些分辨率，因为我们常用的尺寸单位是 px 。 视口viewport 视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口 我们只需要关注理想视口 布局视口layout viewport 一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。 iOS, Android基本都将这个视口分辨率设置为 980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。 视觉视口 visual viewport 字面意思，它是用户正在看到的网站的区域。注意：是网站的区域。 我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。 理想视口 ideal viewport🔥 为了使网站在移动端有最理想的浏览和阅读宽度而设定 理想视口，对设备来讲，是最理想的视口尺寸 需要手动添写meta视口标签通知浏览器操作 meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽(乔布斯提出的哟) 总结 视口就是浏览器显示页面内容的屏幕区域 视口分为布局视口、视觉视口和理想视口 我们移动端布局想要的是理想视口就是手机屏幕有多宽，我们的布局视口就有多宽 想要理想视口，我们需要给我们的移动端页面添加 meta视口标签 meta视口标签 属性 解释说明 width 宽度设置的是viewport宽度，可以设置device-width特殊值(宽度是设备宽度) initial-scale 初始缩放比，大于0的数字 maximum-scale 最大缩放比，大于0的数字 minimum-scale 最小缩放比，大于0的数字 user-scalable 用户是否可以缩放，yes或no（1或0） 标准的viewport设置 视口宽度和设备保持一致 视口的默认缩放比例1.0 不允许用户自行缩放 最大允许的缩放比例1.0 最小允许的缩放比例1.0 二倍图物理像素和物理像素比 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果6\\7\\8 是 750* 1334 我们开发时候的1px 不是一定等于1个物理像素的 PC端页面，1个px 等于1个物理像素的，但是移动端就不尽相同 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比 PC端 和 早前的手机屏幕 / 普通手机屏幕: 1CSS像素 = 1 物理像素的 Retina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。由于 Retina 的出现，对于一张 50px * 50px 的图片,在手机 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊。 例如：我们需要一个 50*50 像素(css像素)的图片，直接放到我们的手机里面会放大2倍变成 100 * 100，这样就会模糊。 解决办法：我们直接放一个 100 * 100 图片，然后手动的把这个图片缩小为 50 * 50。这样将图放到手机里面，手机自动放大2倍变成 100 * 100，这样就不会造成图片模糊 我们准备的图片，比我们实际需要的大小大2倍，这种方式就是二倍图 背景缩放 background-size我们的图片需要进行放大处理，那么我们的背景图片也是需要进行缩放处理。 单位： 长度|百分比|cover|contain cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 多倍图切图cutterman 移动端开发选择 单独制作移动端页面(主流)，通常情况下，网址域名前面加 m(mobile) 可以打开移动端。 m.taobao.com m.jd.com m.suning.com 通过判断设备，如果是移动设备打开，则跳到移动端页面。 响应式页面兼容移动端(其次) 移动端浏览器 移动端浏览器基本以 webkit 内核为主，因此我们就考虑webkit兼容性问题。 我们可以放心使用 H5 标签和 CSS3 样式。 同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可 CSS初始化 normalize.css移动端 CSS 初始化推荐使用 normalize.css 官网地址：http://necolas.github.io/normalize.css/ CSS3盒子模型 box-sizing 传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding CSS3盒子模型： 盒子的宽度 = CSS中设置的宽度width，里面包含了 border 和 padding 也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了 移动端可以全部CSS3 盒子模型 PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型 移动端常见布局 流式布局(百分比布局) 流式布局，就是百分比布局，也称非固定像素布局。 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。 max-width:; min-width:; 最大值和最小值范围 flex布局 传统布局 flex弹性布局 兼容性好 操作方便，布局极为简单，移动端应用很广泛 布局繁琐 PC 端浏览器支持情况较差 局限性，不能再移动端很好的布局 IE 11或更低版本，不支持或仅部分支持 建议： 如果是PC端页面布局，我们还是传统布局。 如果是移动端或者不考虑兼容性问题的PC端页面布局，我们还是使用flex弹性布局 初体验 搭建HTML结构 CSS样式 span 直接给宽度和高度，背景颜色，还有蓝色边框 给 div 只需要添加 display: flex 即可 flex布局原理flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 =flex布局 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 上述例子 div 就是 flex父容器。 上述例子 span 就是 子容器 flex项目 子容器可以横向排列也可以纵向排列 总结 flex 布局原理：就是通过给父盒子添加 flex 属性，来控制子盒子的位置和排列方式。 flex布局常见父项属性以下有 6 个属性是对父元素设置的 flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-content：设置侧轴上的子元素的排列方式（多行） align-items：设置侧轴上的子元素排列方式（单行） flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap flex-direction设置主轴方向主轴和侧轴：在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有：行和列、x轴和y轴 默认主轴方向就是 x 轴方向，水平向右 默认侧轴方向就是 y 轴方向，水平向下 flex-direction 属性决定主轴的方向（即项目的排列方向） 注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的 属性值 说明 row 默认值从左到右 row-reverse 从右到左 column 从上到下 column-reverse 从下到上 justify-content 设置主轴上的子元素排列方式 justify-content 属性定义了项目在主轴上的对齐方式 注意： 使用这个属性之前一定要确定好主轴是哪个 属性值 说明 flex-start 默认值从头部开始，如果主轴是x轴，则从左到右 flex-end 从尾部开始排列 center 在主轴居中对齐(如果主轴是 x 轴则水平居中) space-around 平分剩余空间 space-between 先两边贴边，再平分剩余空间🔥 flex-wrap 设置子元素是否换行默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，flex布局中默认是不换行的。 意思就是如果按照我们设置的盒子大小，一行只能装 3 个盒子，但是我们有 5 个盒子，那么 flex 布局默认会给我们塞上去，自动缩小盒子大小。 属性值 说明 nowrap 默认值，不换行 wrap 换行 align-items 设置侧轴上的子元素排列方式(单行)该属性是控制子项在侧轴（默认是y轴）上的排列方式 在子项为单项（单行）的时候使用 属性值 说明 flex-start 从上到下 flex-end 从下到上 center 挤在一起居中(垂直居中) stretch 拉伸(默认值) align-content 设置侧轴上的子元素的排列方式(多行)设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。 属性值 说明 flex-start 默认值在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 center 在侧轴中间显示 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴先分布在两头，再平分剩余空间 stretch 设置子项元素高度平分父元素高度 align-content 和 align-items 区别 align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸 align-content 适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、 下对齐、居中、拉伸以及平均分配剩余空间等属性值。 总结就是单行找 align-items 多行找 align-content flex-flowflex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性 flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-content：设置侧轴上的子元素的排列方式（多行） align-items：设置侧轴上的子元素排列方式（单行） flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap flex布局子项常见属性 flex 子项目占的份数 align-self 控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序） flex属性flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。 align-self 控制子项自己在侧轴上的排列方式 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 order属性定义项目的排列顺序数值越小，排列越靠前，默认为0。 注意：和 z-index 不一样。 背景颜色渐变background: -webkit-linear-gradient(left,red,blue); 必须添加浏览器前缀 rem适配布局我们来看几个问题： 页面布局文字能否随着屏幕大小变化而变化？ 流式布局和flex布局主要针对于宽度布局，那高度如何设置？ 怎么样让屏幕发生变化的时候元素高度和宽度等比例缩放？ rem基础 rem (root em)是一个相对单位，类似于em，em是父元素字体大小。 不同的是rem的基准是相对于html元素的字体大小。 比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px rem的优势：父元素文字大小可能不一致， 但是整个页面只有一个html，可以很好来控制整个页面的元素大小 媒体查询媒体查询（Media Query）是CSS3新语法。 使用 @media 查询，可以针对不同的媒体类型定义不同的样式 @media 可以针对不同的屏幕尺寸设置不同的样式 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果手机、Android手机，平板等设备都用得到多媒体查询 语法如下： 用 @media 开头 注意@符号 mediatype 媒体类型 关键字 and not only media feature 媒体特性 必须有小括号包含 上面代码的意思是在我们屏幕上页面处于 500px-800px 之间，页面背景颜色显示为 pink 色。页面小于 500px，背景颜色显示为 purple 色 mediatype查询类型将不同的终端设备划分成不同的类型，称为媒体类型 值 解释说明 all 用于所有设备 print 用于打印机和打印预览 scree 用于电脑屏幕、平板电脑、智能手机等 关键字关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。 and：可以将多个媒体特性连接到一起，相当于“且”的意思。 not：排除某个媒体类型，相当于“非”的意思，可以省略。 only：指定某个特定的媒体类型，可以省略。 媒体特性每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。注意他们要加小括号包含。 值 解释 width 定义输出设备中页面可见区域的宽度 min-width 定义输出设备中页面最小可见区域宽度 max-width 定义输出设备中页面最大可见区域宽度 注意： 为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁 媒体查询+rem实现元素动态大小变化 rem单位是跟着html来走的，有了rem页面元素可以设置不同大小尺寸 媒体查询可以根据不同设备宽度来修改样式 媒体查询+rem 就可以实现不同设备宽度，实现页面元素大小的动态变化 上述代码的意思是：屏幕尺寸小于320px， div 大小为 0.5*50 = 25px，屏幕尺寸大于 320px 小于 640px， div 大小为 0.5 * 100 = 50px 引入资源 当样式比较繁多的时候，我们可以针对不同的媒体使用不同 stylesheets（样式表）。 原理，就是直接在link中判断设备的尺寸，然后引用不同的css文件。 LessCSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。 CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的。 不方便维护及扩展，不利于复用。 CSS 没有很好的计算能力 非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目。 Less （Leaner Style Sheets 的缩写） 是一门 CSS 扩展语言，也成为CSS预处理器。 做为 CSS 的一种形式的扩展，它并没有减少 CSS 的功能，而是在现有的 CSS 语法上，为CSS加入程序式语言的特性。 它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，Less 可以让我们用更少的代码做更多的事情。 Less中文网址： http://lesscss.cn/ Less 是一门 CSS 预处理语言，它扩展了CSS的动态特性。 Less安装安装：(如果使用vscode无需安装less) 查看版本： 我们首先新建一个后缀名为less的文件， 在这个less文件里面书写less语句。 Less变量变量命名规范 必须有@为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用。 Less编译我们需要把我们的 less文件，编译生成为css文件，这样我们的html页面才能使用。 我们可以在 vscode 安装 Easy LESS 插件来把 less 文件编译为 css。安装完毕插件，重新加载下 vscode。只要保存一下Less文件，会自动生成CSS文件。 Less嵌套我们经常用到选择器的嵌套 如果遇见 （交集|伪类|伪元素选择器） 内层选择器的前面没有 &amp; 符号，则它被解析为父选择器的后代 如果有 &amp; 符号，它就被解析为父元素自身或父元素的伪类 Less运算任何数字、颜色或者变量都可以参与运算。就是Less提供了加（+）、减（-）、乘（*）、除（/）算术运算。 注意： 乘号（*）和除号（/）的写法 运算符中间左右有个空格隔开 1px + 5 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果就取该单位 rem适配方案 让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。 使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。 实际开发中适配方案： 按照设计稿与设备宽度的比例，动态计算并设置 html 根标签的 font-size 大小；（媒体查询） CSS 中，设计稿元素的宽、高、相对位置等取值，按照同等比例换算为 rem 为单位的值； rem 适配方案技术使用 rem实际开发适配方案一rem + 媒体查询 + less 技术 一般情况下，我们以一套或两套效果图适应大部分的屏幕，放弃极端屏或对其优雅降级，牺牲一些效果。现在基本以750为准。 动态设置 html 标签 font-size 大小 假设设计稿是750px 假设我们把整个屏幕划分为15等份（划分标准不一可以是20份也可以是10等份） 每一份作为html字体大小，这里就是50px 那么在320px设备的时候，字体大小为320/15 就是 21.33px 用我们页面元素的大小 除以不同的 html 字体大小会发现他们比例还是相同的 比如我们以 750为标准设计稿 一个100*100像素的页面元素 在 750屏幕下， 就是 100 / 50 转换为rem 是 2rem * 2 rem 比例是 1比1 320屏幕下， html 字体大小为 21.33 则 2rem = 42.66px 此时宽和高都是 42.66 但是 宽和高的比例还是 1比1 但是已经能实现不同屏幕下 页面元素盒子等比例缩放的效果 元素大小取值方法 最后的公式： 页面元素的rem值 = 页面元素值（px） / （屏幕宽度 / 划分的份数） 屏幕宽度/划分的份数 就是 html font-size 的大小 或者： 页面元素的rem值 = 页面元素值（px） / html font-size 字体大小","categories":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"CSS基础班笔记(二)","slug":"CSS基础笔记(二)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T07:04:10.793Z","comments":true,"path":"2022/04/24/CSS基础笔记(二)/","link":"","permalink":"http://example.com/2022/04/24/CSS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0(%E4%BA%8C)/","excerpt":"","text":"✍目录总览 CSS三大特性🔥层叠性🔥 相同选择器设置相同的样式，此时一个样式就会覆盖另一个冲突的样式。 层叠性主要解决样式冲突的问题 层叠性原则： 样式冲突，遵循的原则是就近原则 继承性🔥 CSS中的继承：子标签会继承父标签里面的某些样式 如文本颜色和字号等 特殊： 行高的继承 1.5的意思：让里面所有的子元素的行高是当前文字大小的1.5倍 优先级🔥– 当同一个元素指定多个选择器，就会有优先级的产生 选择器相同，则执行层叠性 选择器不同，则按权重 选择器 权重 继承或者 * 0，0，0，0 元素选择器（标签选择器） 0，0，0，1 类选择器，伪类选择器 0，0，1，0 ID选择器 0，1，0，0 行内样式style=”” 1，0，0，0 ！important重要的 无穷大 类选择器权重为10 伪类选择器权重为10 ID选择器权重为100 优先级注意点🔥 等级判断是从左到右，如果某一位数值相同，则判断下一位数值 继承的权重是0 权重可以叠加，但是永远不会有进位 权重的叠加🔥 权重叠加：如果是复合选择器，则会有权重的叠加，需要计算权重 div ul li———-&gt; 0,0,0,3 .nav ul li ————–&gt;0,0,1,2 a:hover —————-&gt;0,0,1,1 /* 伪类选择器*/ .nav a——————–&gt;0,0,1,1 盒子模型🔥页面布局要学习三大核心 盒子模型 浮动 定位 盒子模型的组成： border(边框) content(内容) padding(内边距) margin(外边距) 边框border🔥 CSS 边框属性允许你指定一个元素边框的样式和颜色 边框由三部分组成：边框宽度（粗细） 边框样式 边框颜色 属性 作用 border-width 定义边框粗细，单位是px border-style 边框的样式 border-color 边框颜色 border-style🔥边框样式 border-style可以设置如下值： none:没有边框即忽略所有边框的宽度（默认值） solid :边框为单实线（最为常用的） dashed: 边框为虚线 dotted: 边框为点线 边框简写：没有顺序 边框分开写法： border-collapse border-collapse 属性控制浏览器绘制表格边框的方式，它控制相邻单元格的边框 border-coppapse 表格的细线边框 表示相邻边框合并在一起 collapse 单词是合并的意思 边框会影响盒子实际大小🔥边框会额外增加盒子的实际大小，因此我们有两种方案解决： 测量盒子大小的时候，不量边框 如果测量的时候包含了边框，则需要 width/height 减去边框宽度 内边距padding🔥padding 属性用于设置内边距,即盒子边框与内容之间的距离 属性 作用 padding-left 左内边距 padding-right 右内边距 padding -top 上内边距 padding-bottom 下内边距 padding属性(简写属性)可以有一到四个值 值的个数 表达意思 padding : 5px; 1个值，代表上下左右都有5像素内边距 padding :5px 10px; 2个值，代表上下内边距是5像素，左右内边距是10像素 padding: 5px 10px 20px; 3个值，代表上内边距5像素，左右内边距10像素，下内边距20像素 padding :5px 10px 20px 30px 4个值，上是5像素，右是10像素，下20像素，左是30像素，顺时针 以上四种情况，我们实际开发都会遇到。 影响盒子大小🔥 padding会影响盒子大小的情况 当我们给盒子指定 padding 值之后，发生了2件事情： 内容和边框有了距离，添加了内边距 padding影响了盒子实际大小 也就是说，如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子 解决方案： 如果保证盒子跟效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可 但是，有时候 padding 影响盒子是有好处的，比如我们要做导航： 因为每个导航栏里面的字数不一样多,我们可以不用给每个盒子宽度了,直接给 padding 最合适. 不影响盒子大小🔥 padding不会影响盒子大小的情况 如果盒子本身没有指定width/height属性，则此时padding不会撑开盒子大小 外边距margin🔥 margin（外边距）属性用于设置外边距，即控制盒子和盒子之间的距离 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin 简写方式代表的意义跟 padding 完全一致 外边距典型应用🔥外边距可以让块级盒子水平居中，但是必须满足两个条件 盒子必须制定了宽度(width) 盒子左右的外边距都设置为 auto 左右的外边距都设置为 auto 有三种写法： 注意： 以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align: center 即可。 外边距合并🔥使用 margin 定义块级元素的垂直外边距时，可能会出现外边距的合并。 主要有两种情况： 相邻块元素垂直外边距的合并 嵌套块元素垂直外边距的塌陷 ①相邻块元素垂直外边距的合并🔥当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。 解决方案： 尽量只给一个盒子添加 margin 值 ②嵌套块元素垂直外边距的塌陷🔥对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值 解决方案： 可以为父元素定义上边框 可以为父元素定义上内边距 可以为父元素添加 overflow: hidden 还有其他方法，比如浮动、固定、绝对定位的盒子不会有塌陷问题。后面会进行总结。 ③清除内外边距🔥网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。 注意： 行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了 👉PS基本操作🔥因为网页美工大部分效果图都是利用 PS（Photoshop）来做的，所以以后我们大部分切图工作都是在 PS 里面完成。 文件➡打开 ：可以打开我们要测量的图片 Ctrl+R：可以打开标尺，或者 视图➡标尺 右击标尺，把里面的单位改为像素 ==Ctrl+ 加号(+)==可以放大视图， ==Ctrl+ 减号(-)==可以缩小视图 按住空格键，鼠标可以变成小手，拖动 PS 视图 用选区拖动 可以测量大小 Ctrl+ D 可以取消选区，或者在旁边空白处点击一下也可以取消选区 👉新知识点🔥去掉 li 前面的小圆点 👉PS切图PS 有很多的切图方式：图层切图、切片切图、PS 插件切图等。 👉图层切图最简单的切图方式：右击图层 ➡导出 PNG 切片。 👉切片切图 利用切片选中图片 利用切片工具手动划出 导出选中的图片 文件菜单➡存储为 web 设备所用的格式➡选择我们要的图片格式➡存储 👉PS插件切图🔥Cutterman 是一款运行在 Photoshop 中的插件，能够自动将你需要的图层进行输出，以替代传统的手工 “导出 web 所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 官网：Cutterman官网 注意：Cutterman 插件要求你的 PS 必须是完整版，不能是绿色版，所以大家需要安装完整版本 圆角边框🔥 在 CSS3 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。 border-radius 属性用于设置元素的外边框圆角。 radius半径（圆的半径） 原理:(椭）圆与边框的交集形成圆角效果 参数值可以是数值或百分比的形式 如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为50% 如果是一个矩形，设置为高度的一半就可以 该属性是一个简写属性，可以跟四个值，分别代表左上角，右上角，右下角，左下角 盒子阴影CSS3 中新增了盒子阴影，我们可以使用 box-shadow 属性为盒子添加阴影。 语法 box-shadow: h-shadow v-shadow blur spread color inset; 值 描述 h-shadow 必需。水平阴影的位置，允许负值 v-shadow 必需。垂直阴影的位置，允许负值 blur 可选。模糊距离。 spread 可选，阴影的尺寸。 color 可选，阴影的颜色。 inset 可选，将外部阴影（outset）改为内部阴影 模糊距离：影子的虚实 阴影尺寸：影子的大小 box-shadow: 10px 10px 5px #888888; 注意： 默认的是外阴影（outset），但是不可以在后面写这个单词，否则导致阴影无效 盒子阴影不占用空间，不会影响其他盒子排列 👉开发中阴影常用🔥原先盒子没有影子，当我们鼠标经过盒子就添加阴影效果 文字阴影在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本。 值 描述 h-shadow 必需。水平阴影的位置，允许负值 v-shadow 必需。垂直阴影的位置，允许负值 blur 可选。模糊距离 color 可选，阴影的颜色。 传统网页布局的三种方式🔥网页布局的本质➡用 CSS 来摆放盒子。 把盒子摆放到相应位置 CSS 提供了三种传统布局方式： 普通流（标准流） 浮动 定位 标准流🔥所谓 的标准流，就是标签按照规定好默认方式排列 块级元素会独占一行，从上向下顺序排列。 常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。 常用元素：span、a、i、em 等 以上都是标准流布局，我们前面学习的就是标准流，标准流是最基 本的布局方式。 这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局 自然就完成了。 注意：实际开发中，一个页面基本都包含了这三种布局方式（后面 移动端学习新的布局方式） 。 浮动🔥 提问：如何让多个块级盒子(div)水平排列成一行？ 比较难，虽然转换为行内块元素可以实现一行显示，但是他们之间会有大的空白缝隙，很难控制。 提问：如何实现两个盒子的左右对齐？ 总结： 有很多的布局效果，标准流没有办法完成，此时就可以利用 浮动完成布局。 因为浮动可以改变元素标签默认的排列方式. 浮动的典型应用🔥 浮动最典型的应用：可以让多个块级元素一行内排列显示。 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。 什么是浮动？ float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘 语法： 属性值 描述 none 元素不浮动 left 元素向左浮动 right 元素向右浮动 网页布局的第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动 网页布局第二准则：先设置盒子大小，之后设置盒子的位置。 浮动的特性🔥设置了浮动（float）的元素的最重要的特性： 脱标：浮动元素会脱离标准流 浮动的盒子不再保留原先的位置 如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列 浮动的元素是相互贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。 浮动元素会具有行内块元素特性 任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后都具有行内块元素相似的特性。 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定 如果行内元素有了浮动，则不需要转换块级\\行内块元素就可以直接给高度和宽度 浮动的盒子中间是没有缝隙的，是紧挨着一起的 浮动元素经常和标准流父级搭配使用🔥为了约束浮动元素位置, 我们网页布局一般采取的策略是: 先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置 浮动的注意点🔥 先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置 一个元素浮动了，理论上其余兄弟元素也要浮动 一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流 清除浮动🔥我们前面浮动元素有一个标准流的父元素, 他们有一个共同的特点, 都是有高度的.但是, 所有的父盒子都必须有高度吗? 理想中的状态, 让子盒子撑开父亲. 有多少孩子,我父盒子就有多高. 但是不给父盒子高度会有问题吗?..… 为什么要清除浮动 由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子。 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响 理想中的状态，让子盒子撑开父亲，有多少孩子，我父盒子就有多高 清除浮动的本质🔥 清除浮动的本质是清除浮动元素造成的影响 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了。 语法： 属性值 描述 left 不允许左侧有浮动元素(清除左侧浮动的影响) right 不允许右侧有浮动元素(清除右侧浮动的影响) both 同时清除左右两侧浮动的影响 我们实际工作中，几乎只用clear:both 清除浮动的策略是：闭合浮动 只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子。 清除浮动的方法🔥 额外标签法也称为隔墙法，是W3C推荐的做法 父级添加 overflow 属性 父级添加 after 伪元素 父级添加双伪元素 ①额外标签法 额外标签法会在浮动元素末尾添加一个空的标签,例如： 例如&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;，或者其他标签（如&lt;/br&gt;等） 注意：要求这个新的空标签必须是块级元素 优点：通俗易懂，书写方便 缺点：添加许多无意义的标签，结构化较差 实际工作可能会遇到,但是不常用 ②overflow 可以给父级添加overflow属性，将其属性值设置为hidden,auto或scroll 优点：代码简洁 缺点：无法显示溢出的部分 ③after伪元素法🔥:after 方式是额外标签法的升级版。也是给父元素添加 优点：没有增加标签，结构更简单 缺点：需要照顾低版本浏览器 代表网站：百度、淘宝、网易等 ④双伪元素🔥 也是给父元素添加 优点：代码更简洁 缺点：需要照顾低版本浏览器 代表网站：小米、腾讯等 浮动总结🔥 为什么需要清除浮动？ ①：父级没高度 ②：子盒子浮动了 ③：影响下面布局了，我们就应该清除浮动了。 清除浮动方式 优点 缺点 额外标签法(隔墙法) 通俗易懂，书写方便 添加许多无意义的标签，结构化较差 父级overflow:hidden; 书写简单 溢出隐藏 父级after伪元素 结构语义化正确 由于IE6-7不支持：after，兼容性问题 父级双伪元素 结构语义化正确 由于IE6-7不支持：after，兼容性问题 定位🔥提问：以下情况使用标准流或者浮动能实现吗？ 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子。 当我们滚动窗口的时候，盒子是固定屏幕某个位置的。 以上效果，标准流或浮动都无法快速实现，此时需要定位来实现 浮动可以让多个块级盒子一行没有缝隙的排列显示，经常用于横向排列盒子 定位则是可以让盒子自由的在某个盒子内移动位置或固定屏幕中某个位置，并且可以压住其他盒子 定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子 定位的组成🔥定位 = 定位模式 +边偏移 定位模式用于指定一个元素在文档中的定位方式 边偏移则决定了该元素的最终位置 定位模式 定位模式决定元素的定位方式 ，它通过 CSS 的 position 属性来设置，其值可以分为四个 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 边偏移 边偏移就是定位的盒子移动到最终位置。 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素的上边线的距离 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素的下边线的距离 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离 静态定位static(了解) 静态定位是元素的默认定位方式，无定位的意思 静态定位按照标准流特性摆放位置，它没有边偏移 相对定位relative🔥 相对定位是元素在移动位置的时候，是相对于它原来的位置来说的 特点： 它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置） 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待。（不脱标，继续保留原来位置） 因此，相对定位并没有脱标，它最典型的应用是给绝对定位当爹的。 绝对定位absolute🔥 绝对定位是元素在移动位置的时候，是相对于它的祖先元素来说的 特点： 如果没有祖先元素，或者祖先元素没定位，则以浏览器为准进行定位(Document 文档) 如果祖先元素父级有定位(相对、绝对、固定定位)，则以最近一级的有定位祖先元素为参考点移动位置 绝对定位不再占用原先的位置（脱标） 所以绝对定位是脱离标准流的 ①绝对定位盒子水平居中🔥 加了绝对定位的盒子不能通过margin: 0 auto水平居中 但是可以通过以下计算方法实现水平和垂直居中 left:50% ； 让盒子的左侧移动到父级元素的水平中心位置 margin-left: -100px; 让盒子向左移动自身宽度的一半 子绝父相🔥意思：子级使用绝对定位，父级则需要相对定位 ①：子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。 ②：父盒子需要加定位限制子盒子在父盒子内显示 ③：父盒子布局时，需要占有位置，因此父亲只能是相对定位。 总结：因为父级需要占有位置，因此是相对定位，子盒子不要占有位置，则是绝对定位 固定定位fixed🔥固定定位是元素固定于浏览器的可视区的位置 主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变 特点🔥 ： 以浏览器的可视窗口为参照点移动元素 跟父元素没有任何关系 不随滚动条滚动 固定定位不再占有原先的位置(脱标) 固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。 👉固定定位小技巧🔥固定定位小技巧： 固定在版心右侧位置 小算法： 让固定定位的盒子 left: 50%. 走到浏览器可视区（也可以看做版心） 的一半位置。 让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走 版心宽度的一半位置 就可以让固定定位的盒子贴着版心右侧对齐了。 粘性定位sticky(了解)粘性定位可以被认为是相对定位和固定定位的混合 特点： 以浏览器的可视窗口为参照点移动元素（固定定位特点） 粘性定位占有原先的位置（相对定位的特点） 必须添加top，left，right，bottom其中一个才有效 跟页面滚动搭配使用。 兼容性较差，IE 不支持。 定位模式总结🔥 定位模式 是否脱标 移动位置 是否常用 static静态定位 否 不能使用边偏移 很少 relative相对定位 否（占有位置） 相对于自身位置移动 常用 absolute绝对定位 是（不占有位置） 带有定位的父级 常用 fixed固定定位 是（不占有位置） 浏览器可视区 常用 sticky 否（占有位置） 浏览器可视区 当前阶段少 一定要记住相对定位，固定定位，绝对定位的两个大特点：1.是否占有位置（脱标否）2.以谁为基准点移动 重点学会子绝父相（儿子绝对定位，父亲必须相对定位） 定位叠放次序z-index🔥 在使用定位布局时候，可能会出现盒子重叠的情况 此时，可以用 z-index 来控制盒子的前后次序(z轴) 数值可以是正整数，负整数或者0，默认是auto，数值越大，盒子越靠上 如果属性值相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有 z-index 属性 定位的扩展🔥 ✍绝对定位的盒子居中 加了绝对定位的盒子不能通过 margin: 0 auto 水平居中，但是可以通过以下计算方法实现水平和垂直居中 ①：left: 50%; 让盒子的左侧移动到父级元素的水平中心位置 ②：margin-left: -100px; 让盒子向左移动自身宽度的一半 ✍定位特殊特性 绝对定位和固定定位也和浮动类似。 ①：行内元素添加绝对或者固定定位，可以直接设置高度和宽度 ②：块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。 ✍脱标的盒子不会触发外边距塌陷 浮动元素、绝对定位(固定定位)元素都不会触发外边距合并的问题。 ✍绝对定位(固定定位)会完全压住盒子 ①：浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片） ②：但是绝对定位（固定定位） 会压住下面标准流所有的内容。 ③：浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素 网页布局总结🔥通过盒子模型，清楚知道大部分html标签是一个盒子 通过CSS浮动、定位 可以让每个盒子排列成为网页 一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法 标准流 可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。 浮动 可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局。 定位 定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。 六、元素的隐藏与显示🔥类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ 本质：让一个元素在页面中隐藏或者显示出来 display显示隐藏🔥display属性用于设置一个元素应如何显示 display隐藏元素后，不再占有原来的位置 后面应用及其广泛，搭配 JS 可以做很多的网页特效。 visibility显示隐藏🔥visibility属性用于指定一个元素应可见还是隐藏 visibility 隐藏元素后，继续占有原来的位置。 如果隐藏元素想要原来位置， 就用 visibility：hidden 如果隐藏元素不想要原来位置， 就用 display：none (用处更多 重点） overflow溢出显示隐藏🔥overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。 但是如果有定位的盒子， 请慎用 overflow:hidden 因为它会隐藏多余的部分。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"CSS基础知识汇总","slug":"CSS基础知识汇总","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T07:41:41.647Z","comments":true,"path":"2022/04/24/CSS基础知识汇总/","link":"","permalink":"http://example.com/2022/04/24/CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/","excerpt":"","text":"CSS构造块1. HTML的局限性 HTML满足不了设计者的需求，可以将网页结构与样式相分离，这样就可以在不更改网页结构的前提下，更换网站的样式。 操作html属性不方便 HTML里面添加样式带来的是无尽的臃肿和繁琐 2. CSS网页的美容师 让我们的网页更加丰富多彩，布局更加灵活自如。 CSS最大的贡献：让HTML从样式中脱离，实现了HTML专注去做结构呈现，样式交给CSS 3. CSS CSS(Cascading Style Sheets)通常称为CSS样式表或层叠样式表(级联样式表)。 作用 主要用于设置HTML页面中的文本内容(字体、大小、对齐方式等)\\图片的外形(宽高、边框样式、边距等)以及版面的布局和外观显示样式。 CSS以HTML为基础，提供了丰富的功能，如字体、样式、背景的控制及整体排版等，而且可以针对不同的浏览器设置不同的样式。 4. CSS注释 1/* 这是注释 */ 引入CSS样式表1.行内式(内联样式) 通过标签的style属性来设置元素的样式 style其实就是标签的属性 样式属性和值中间是: 多组属性值直接用;隔开 只能控制当前的标签和以及嵌套在其中的字标签，造成代码冗余。 **缺点:**没有实现样式和结构相分离。 123&lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt;例如：&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;青春不常在，抓紧谈恋爱&lt;/div&gt; 「2.内部样式表(内嵌样式表)」 也称为内嵌式，将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义。 style标签一般位于head标签中，当然理论上他可以放在HTML文档的任何地方。 type=”text/css” 在html5中可以省略。 只能控制当前的页面 **缺点:**没有彻底分离结构与样式 123456789&lt;head&gt;&lt;style type=&quot;text/CSS&quot;&gt; 选择器（选择的标签） &#123; 属性1: 属性值1; 属性2: 属性值2; 属性3: 属性值3; &#125;&lt;/style&gt;&lt;/head&gt; 「3.外部样式表(外链式)」 也称链入式，是将所有的样式放在一个或多个以.css为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中。 rel:定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 href:定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。 1&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; 「4.团队约定-代码风格」 12345678910111213141516171819/*1.紧凑格式 (Compact)*/h3 &#123; color: deeppink;font-size: 20px;&#125;// 2.一种是展开格式（推荐）h3 &#123; color: deeppink; font-size: 20px; &#125;/* 团队约定-代码大小写*//* 样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。*//* 推荐 */h3&#123; color: pink;&#125; /* 不推荐 */H3&#123; COLOR: PINK;&#125; CSS基础选择器CSS选择器作用找到指定的HTML页面元素，选择标签。 CSS基础选择器「1. 标签选择器」 标签选择器（元素选择器）是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。 作用：可以把某一类标签全部选择出来。 优点：快速为网页中同类型的标签统一样式 缺点：不能设计差异化样式。 1标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 「2. 类选择器」 类选择器使用”.”(英文点号)进行标识，后面紧跟类名。 语法：类名选择器 123456.类名 &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;&lt;p class=&#x27;类名&#x27;&gt;&lt;/p&gt; 优点：可以为元素对象定义单独或相同的样式。可以选择一个或者多个标签。 注意：类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的) 长名称或词组可以使用中横线来为选择器命名。 不要纯数字、中文等命名， 尽量使用英文字母来表示。 多类名选择器：各个类名中间用空格隔开。 「3. id选择器」id选择器使用#进行标识，后面紧跟id名 元素的id值是唯一的，只能对应于文档中某一个具体的元素。 12#id名 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;&lt;p id=&quot;id名&quot;&gt;&lt;/p&gt; 「4. 通配符选择器」 通配符选择器用*号表示，* 就是选择所有的标签。它是所有选择器中作用范围最广的，能匹配页面中所有的元素。 注意：会匹配页面所有的元素，降低页面响应速度，不建议随便使用 1* &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 例如下面代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 1234* &#123; margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/&#125; 「5. 基础选择器总结」 选择器 作用 缺点 使用情况 用法 标签选择器 可以选出所有相同的标签，比如p 不能差异化选择 较多 p { color：red;} 类选择器 可以选出1个或者多个标签 可以根据需求选择 非常多 .nav { color: red; } id选择器 一次只能选择器1个标签 只能使用一次 不推荐使用 #nav {color: red;} 通配符选择器 选择所有的标签 选择的太多，有部分不需要 不推荐使用 * {color: red;} 「6. 团队约定-选择器」 尽量少用通配符选择器 *。 尽量少用ID选择器 不使用无具体语义定义的标签选择器。 123456789/* 推荐 */.jdc &#123;&#125;li &#123;&#125;p&#123;&#125;/* 不推荐 */*&#123;&#125;#jdc &#123;&#125;div&#123;&#125; 因为div 没有语义，我们尽量少用 复合选择器复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的 「1. 后代选择器」又称为包含选择器 用来选择元素或元素组的子孙后代 其写法就是把外层标签写在前面，内层标签写在后面，中间用「空格」分隔，先写父亲爷爷，再写儿子孙子。 子孙后代都可以这么选择。或者说，它能选择任何包含在内 的标签。 123父级 子级&#123;属性:属性值;属性:属性值;&#125;.class h3 &#123;color:red;font-size:16px;&#125; 当标签发生嵌套时，内层标签就成为外层标签的后代。 子孙后代都可以这么选择。或者说，它能选择任何包含在内的标签。 「2. 子元素选择器」 子元素选择器只能选择作为某元素子元素(亲儿子)的元素。 其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接 这里的子,指的是亲儿子。不包含孙子 重孙子之类。 1.class&gt;h3 &#123;color:red;font-size:14px;&#125; 「3. 交集选择器」 其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。 123交集选择器是并且的意思,即...又...的意思比如： p.one 选择的是： 类名为 .one 的段落标签。 /*用的相对来说比较少，不建议使用。*/ 「4. 并集选择器」如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简洁。并集选择器（CSS选择器分组）是各个选择器通过,连接而成的，通常用于集体声明。 任何形式的选择器（包括标签选择器、class类选择器 id选择器等），都可以作为并集选择器的一部分。 并集选择器通常用于集体声明 ，逗号隔开的，所有选择器都会执行后面样式，逗号可以理解为和的意思。 123456比如 .one, p , #test &#123;color: #F00;&#125; 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 「5. 链接伪类选择器」 用于向某些选择器添加特殊的效果。写的时候，他们的顺序尽量不要颠倒,按照lvha的顺序。否则可能引起错误。 链接伪类，是利用交集选择器. a:link 未访问的链接 a:visited 已访问的链接 a:hover 鼠标移动到链接上 a:active 选定的链接 实际工作中，很少写全四个状态，一般写法如下：123456789a &#123; /* a是标签选择器 所有的链接 */ font-weight: 700; font-size: 16px; color: gray; text-decoration: none; /* 清除链接默认的下划线*/&#125;a:hover &#123; /* :hover 是链接伪类选择器 鼠标经过 */ color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */&#125; 【:fouce选择器】 「6. 复合选择器总结」 选择器 作用 特征 使用情况 隔开符号及用法 后代选择器 用来选择元素后代 是选择所有的子孙后代 较多 符号是空格 .nav a 子代选择器 选择 最近一级元素 只选亲儿子 较少 符号是&gt; .nav&gt;p 交集选择器 选择两个标签交集的部分 既是 又是 较少 没有符号 p.one 并集选择器 选择某些相同样式的选择器 可以用于集体声明 较多 符号是逗号 .nav, .header 链接伪类选择器 给链接更改状态 较多 重点记住 a{} 和 a:hover 实际开发的写法 CSS字体样式font字体「1. font-size」 font-size属性用于设置字号(字体大小) 谷歌浏览器默认的文字大小为16px 不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给body指定整个页面文字的大小。 1p &#123; font-size:20px; &#125; 单位 相对长度单位、绝对长度单位 「2. font-family」 font-family属性用于设置哪一种字体。 1p &#123; font-family:&quot;微软雅黑&quot;;&#125; 指定多个字体，如果浏览器不支持第一个字体就会尝试下一个直到找到合适的字体，如果都没有，以电脑默认字体为准。 1p &#123;font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;&#125; CSS Unicode字体 在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。 xp 系统不支持 类似微软雅黑的中文。 解决方案：英文来替代。比如font-family:&quot;Microsoft Yahei&quot;。在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。 1font-family: &quot;\\5FAE\\8F6F\\96C5\\9ED1&quot;; 表示设置字体为“微软雅黑”。 「3. font-weight」 属性值 描述 normal 默认值（不加粗的） bold 定义粗体（加粗的） 100~900 400 等同于 normal，而 700 等同于 bold (数字表示粗细用的多) 「4. font-weight」 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： 属性 作用 normal 默认值，浏览器会显示标准的字体样式 font-style: normal; italic 浏览器会显示斜体的字体样式。 「5. font:综合设置字体样式」 1选择器 &#123; font: font-style font-weight font-size/line-height font-family;&#125; 注意：使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开 其中不需要设置的属性可以省略(取默认值),但必须保留font-size和font-family属性，否则font属性将不起作用。 「6. font总结」 属性 表示 注意点 font-size 字号 我们通常用的单位是px 像素，一定要跟上单位 font-family 字体 实际工作中按照团队约定来写字体 font-weight 字体粗细 记住加粗是 700 或者 bold 不加粗 是 normal 或者 400 记住数字不要跟单位 font-style 字体样式 记住倾斜是 italic 不倾斜 是 normal 工作中我们最常用 normal font 字体连写 1. 字体连写是有顺序的 不能随意换位置 2. 其中字号 和 字体 必须同时出现 CSS外观属性1. color color属性用于定义文本的颜色其取值方式有以下3种： 实际工作中，用16进制的写法是最多的，且我们更喜欢简写方式比如#f0代表红色。 表示表示 属性值 预定义的颜色值 red，green，blue，pink 十六进制 #FF0000，#FF6600，#29D794 RGB代码 rgb(255,0,0)或rgb(100%,0%,0%) 2.text-align text-align属性用于设置文本内容的水平对齐方式，相当于html中的align对齐属性。 注意：是让盒子里面的文本内容水平居中， 而不是让盒子居中对齐 其可用属性值如下： 属性 解释 left 左对齐（默认值） right 右对齐 center 居中对齐 3. line-heightline-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。 line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 12一般情况下，行距比字号大7--8像素左右就可以了。line-height: 24px; 行高测量行高测量方法： 行高测量方法行高我们利用最多的一个地方是：可以让单行文本在盒子中垂直居中对齐。 文字的行高等于盒子的高度。行高 = 上距离 + 内容高度 + 下距离上距离和下距离总是相等的，因此文字看上去是垂直居中的。 行高与高度的三种关系 如果 行高 等 高度 文字会 垂直居中 如果行高 大于 高度 文字会 偏下 如果行高小于高度 文字会 偏上 12345/*line-height 要设置在font属性下面，否则无效，例如：*/height: 80px;text-align: center;font: normal bold 30px &quot;宋体&quot;;line-height: 80px; 可以使用display:flex;布局方式让文字水平垂直居中 123display: flex;align-items: center; /* 侧轴对齐方式*/justify-content: center; /* 主轴对齐方式 */ 4. text-indent text-indent属性用于设置首行文本的缩进 其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值。 建议使用em作为设置单位。 1em 就是一个字的宽度。如果是汉字的段落，1em 就是一个汉字的宽度 123456p &#123; /*行间距*/ line-height: 25px; /*首行缩进2个字 em 1个em 就是1个字的大小*/ text-indent: 2em; &#125; 5. text-decoration文本的装饰 text-decoration,通常我们用于给链接修改装饰效果 值 描述 none 默认。定义标准的文本。取消下划线（最常用） underline 定义文本下的一条线。下划线 也是我们链接自带的（常用） overline 定义文本上的一条线。（不用） line-through 定义穿过文本下的一条线。（不常用） 「6. CSS外观属性总结」 属性 表示 注意点 color 颜色 我们通常用 十六进制 比如 而且是简写形式 #fff line-height 行高 控制行与行之间的距离 text-align 水平对齐 可以设定文字水平的对齐方式 text-indent 首行缩进 通常我们用于段落首行缩进2个字的距离 text-indent: 2em; text-decoration 文本修饰 记住 添加 下划线 underline 取消下划线 none 标签显示模式(display)标签显示模式是标签以什么方式进行显示。HTML标签一般分为块标签和行内标签两种类型，它们也称为块元素和行内元素。 标签显示模式转换 display 块转行内：display:inline; 行内转块：display:block; 块、行内元素转换为行内块：display: inline-block; 1. 块级元素(block-level) 块级元素的特点 独占一行 高度，宽度，外边距以及内边距都可以控制。 宽度默认是容器(父级宽度)的100% 是一个容器及盒子，里面可以放行内或者块级元素 注意：只有文字才能组成段落，因此p标签里面不能放块级元素，特别是p不能放div。同理，还有h1~h6，dt,它们都是文字类块级标签，里面不能放其他块级元素。 2. 行内元素(inline-level) 有的地方也称为内联元素 行内元素的特点 相邻行内元素在一行上，一行可以显示多个。 高度、宽度直接设置是无效的。 默认高度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 注意 链接里面不能再放链接 特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。 3. 行内块元素(inline-block) 行内块元素的特点 和相邻行内元素(行内块)在一行上，但是之间会有空白缝隙。一行可以显示多个 默认宽度就是它本身内容的宽度。 高度，行高，外边距以及内边距都可以控制。 三种模式总结 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽度高度 容器的100% 容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽度高度 它本身内容的宽度 容纳文本或则其他行内元素 行内块元素 一行放多个行内块元素 可以设置宽度和高度 它本身内容的宽度 CSS背景(background)1. 背景颜色 1background-color: 颜色值; 默认的值是 transparent 透明的 2. 背景图片(image) 1234语法：background-image : none | url (url) ;例如:background-image: url(images/1.png); 3. 背景平铺（repeat） 1background-repeat : repeat | no-repeat | repeat-x | repeat-y 参数 作用 repeat 背景图像在纵向和横向上平铺（默认的） no-repeat 背景图像不平铺 repeat-x 背景图像在横向上平铺 repeat-y 背景图像在纵向平铺 4. 背景位置(position) 12background-position : length || lengthbackground-position : position || position 参数 值 length 百分数 | 由浮点数字和单位标识符组成的长度值 position top | center | bottom | left | center | right 方位名词 注意： 必须先指定background-image属性 position 后面是x坐标和y坐标。可以使用方位名词或者 精确单位。 如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left top和top left效果一致 如果只指定了一个方位名词，另一个值默认居中对齐。 如果position 后面是精确坐标， 那么第一个，肯定是 x 第二个一定是y 如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中 如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标 背景简写： background：属性的值的书写顺序官方没有强制的标准。为了可读性，建议如下写： background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 12/* 有背景图片背景颜色可以不用写*/background: transparent url(image.jpg) repeat-y scroll center top ; 5. 背景半透明(CSS3) 12background: rgba(0, 0, 0, 0.3);background: rgba(0, 0, 0, .3); 等同于background-color: rgba(0, 0, 0, .3) 最后一个参数是alpha 透明度 取值范围 0~1之间 我们习惯把0.3 的 0 省略掉 这样写 background: rgba(0, 0, 0, .3); 注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响 低于IE 9的版本不支持 盒子半透明 opacity 设置opacity元素的所有后代元素会随着一起具有透明性，一般用于调整图片或者模块的整体不透明度 1opacity: .2; 6. 背景总结 属性 作用 值 background-color 背景颜色 预定义的颜色值/十六进制/RGB代码 background-image 背景图片 url(图片路径) background-repeat 是否平铺 repeat/no-repeat/repeat-x/repeat-y background-position 背景位置 length/position 分别是x 和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法 background-attachment 背景固定还是滚动 scroll/fixed 背景简写 更简单 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 他们没有顺序 背景透明 让盒子半透明 background: rgba(0,0,0,0.3); 后面必须是 4个值 CSS三大特性1. CSS 层叠性 -概念： 所谓层叠性是指多种CSS样式的叠加 是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 -原则： 样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。 样式不冲突，不会层叠。 2. CSS 继承性 -概念： 子标签会继承父标签的某些样式，如文本颜色和字号。 想要设置一个可继承的属性，只需将它应用于父元素即可。 -注意： 恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。 子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性） 3. CSS 优先级(CSS特殊性) -概念：定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时， 选择器相同，则执行层叠性 选择器不同，就会出现优先级的问题。 -权重计算公式： 标签选择器 计算权重公式 继承或者 * 0,0,0,0 每个元素（标签选择器） 0,0,0,1 每个类，伪类 0,0,1,0 每个ID 0,1,0,0 每个行内样式 style=”” 1,0,0,0 每个!important 最重要的 ∞ 无穷大 值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性） div { color: pink !important; } -权重叠加： 1234div ul li ------&gt; 0,0,0,3.nav ul li ------&gt; 0,0,1,2a:hover -----—&gt; 0,0,1,1.nav a ------&gt; 0,0,1,1 -继承的权重是0： 我们修改样式，一定要看该标签有没有被选中 如果选中了，那么以上面的公式来计权重。谁大听谁的。 如果没有选中，那么权重是0，因为继承的权重为0. 盒子模型css学习三大重点： css 盒子模型 、 浮动 、 定位 网页布局的本质 首先利用CSS设置好盒子的大小，然后摆放盒子的位置。 最后把网页元素比如文字图片等等，放入盒子里面。 盒子模型(Box Model) 盒子模型就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 盒子模型由元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。 盒子里面的文字和图片等元素是 内容区域 盒子的厚度 我们称为为盒子的边框 盒子内容与边框的距离是内边距 盒子与盒子之间的距离是外边距 W3c标准盒子模型 标准 w3c 盒子模型的范围包括 margin、border、padding、content 当设置为box-sizing: content-box;时，将采用标准模式解析计算，也是默认模式； 1内盒尺寸计算(元素实际大小) 宽度：Element Height = content height + padding + border （Height为内容高度） 高度：Element Width = content width + padding + border （Width为内容宽度） 盒子的实际大小：内容的宽度和高度 + 内边距 + 边框 IE盒子模型 IE 盒子模型的 content 部分包含了 border 和 pading 当设置为box-sizing: border-box时，将采用怪异模式解析计算； 盒子边框(border) 属性 作用 border-width 定义边框粗细，单位是px border-style 边框的样式 border-color 边框颜色 边框的样式： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 1234边框综合设置border : border-width || border-style || border-color border: 1px solid red; 没有顺序要求 盒子边框写法总结表： 很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。 上边框 下边框 左边框 右边框 border-top-style:样式; border-bottom-style:样式; border-left-style:样式; border-right-style:样式; border-top-width:宽度; border- bottom-width:宽度; border-left-width:宽度; border-right-width:宽度; border-top-color:颜色; border- bottom-color:颜色; border-left-color:颜色; border-right-color:颜色; border-top:宽度 样式 颜色; border-bottom:宽度 样式 颜色; border-left:宽度 样式 颜色; border-right:宽度 样式 颜色; 表格的细线边框： 通过表格的cellspacing=&quot;0&quot;,将单元格与单元格之间的距离设置为0， 但是两个单元格之间的边框会出现重叠，从而使边框变粗 通过css属性：table{ border-collapse:collapse; } collapse 单词是合并的意思,border-collapse: collapse;表示相邻边框合并在一起。 1234567891011121314&lt;style&gt; table &#123; width: 500px; height: 300px; border: 1px solid red; &#125; td &#123; border: 1px solid red; text-align: center; &#125; table, td &#123; border-collapse: collapse; /*合并相邻边框*/ &#125;&lt;/style&gt; 内边距(padding)padding属性用于设置内边距。是指边框与内容之间的距离。 设置 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 padding简写 值的个数 表达意思 1个值 padding：上下左右内边距; 2个值 padding: 上下内边距 左右内边距 ； 3个值 padding：上内边距 左右内边距 下内边距； 4个值 padding: 上内边距 右内边距 下内边距 左内边距 ； 当我们给盒子指定padding值之后， 发生了2件事情： 内容和边框 有了距离，添加了内边距。 盒子会变大 解决措施：通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小。 padding不影响盒子大小情况：👉如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。 外边距（margin）margin属性用于设置外边距。margin就是控制盒子和盒子之间的距离 设置 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin值的简写 （复合写法）代表意思 跟 padding 完全相同。 块级盒子水平居中 盒子必须指定宽度（width） 然后就给左右的外边距都设置为auto 实际工作中常用这种方式进行网页布局，示例代码如下： 1.header &#123; width: 960px; margin: 0 auto;&#125; 常见的写法，以下下三种都可以👇👇。 margin-left: auto; margin-right: auto; margin: auto; margin: 0 auto; 文字居中和盒子居中区别👇👇 盒子内的文字水平居中是 text-align: center; 而且还可以让 行内元素和行内块居中对齐 块级盒子水平居中 左右margin 改为 auto 插入图片和背景图片区别👇👇 插入图片我们用的最多 比如产品展示类 移动位置只能靠盒模型 padding margin 背景图片我们一般用于小图标背景或者超大背景图片、背景图片，移动位置只能通过 background-position 清除元素的默认内外边距👇👇 行内元素为了照顾兼容性,尽量只设置左右内外边距，不要设置上下内外边距。 1234* &#123; padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */&#125; 外边距合并使用margin定义块元素的「垂直外边距」时，可能会出现外边距的合并。 (1). 相邻块元素垂直外边距的合并 当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom 下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和 「取两个值中的较大者」这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 「解决方案：尽量给只给一个盒子添加margin值」。 (2). 嵌套块元素垂直外边距的合并（塌陷） 对于两个嵌套关系的块元素，如果父元素没有上内边距及边框 父元素的上外边距会与子元素的上外边距发生合并 合并后的外边距为两者中的较大者 「解决方案：」 可以为父元素定义上边框。 可以为父元素定义上内边距 可以为父元素添加overflow: hidden。 还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。 盒子模型布局稳定性优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin） 1width &gt; padding &gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 CSS3 新增1234567圆角边框：border-radius:length;border-top-left-radius 定义了左上角的弧度border-top-right-radius 定义了右上角的弧度border-bottom-right-radius 定义了右下角的弧度border-bottom-left-radius 定义了左下角的弧度 其中每一个值可以为 数值或百分比的形式。 技巧：让一个正方形 变成圆圈 1border-radius: 50%; 如果要在四个角上一一指定，可以使用以下规则👇👇： 1border-radius: 左上角 右上角 右下角 左下角; 四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。 三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角 两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角 一个值：四个圆角值相同 12盒子阴影(box-shadow)：box-shadow: offset-x offset-y [blur [spread]] [color] [inset] 值 描述 offset-x 阴影的水平偏移量。正数向右偏移，负数向左偏移。 offset-y 阴影的垂直偏移量。正数向下偏移，负数向上偏移。 blur 可选。阴影模糊距离，不能取负数。 spread 可选。阴影大小 color 可选。阴影的颜色 inset 可选。表示添加内阴影，默认为外阴影 12345678div &#123; width: 200px; height: 200px; border: 10px solid red; /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4); */ /* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色 内/外阴影； */ box-shadow: 0 15px 30px rgba(0, 0, 0, .4); &#125; 浮动浮动「1. CSS布局的三种机制」 网页布局的核心——就是用CSS来摆放盒子。 CSS 提供了3种机制来设置盒子的摆放位置，分别是普通流（标准流）、浮动和定位，其中： A. 普通流（标准流） 块级元素会独占一行，从上向下顺序排列； 常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行； 常用元素：span、a、i、em等 B. 浮动 让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。 C. 定位 将盒子定在浏览器的某一个位置——CSS 离不开定位，特别是后面的 js 特效。 「2. 什么是浮动」 ​ 元素的浮动是指设置了浮动属性的元素会 脱离标准普通流的控制,不占位置，脱标 移动到指定位置。 作用 让多个盒子(div)水平排列成一行，使得浮动称为布局的重要手段。 可以实现盒子的左右对齐等等。 浮动最早是用来控制图片，实现文字环绕图片效果。 float属性会改变元素的display属性，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。生成的块级框和我们前面的行内块极其相似。 语法1选择器 &#123; float: 属性值; &#125; 属性值 描述 none 元素不浮动（默认值） left 元素向左浮动 right 元素向右浮动 浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。**建议:**如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题 浮动(float)小结 特点 说明 浮 加了浮动的盒子「是浮起来」的，漂浮在其他标准流盒子的上面。 漏 加了浮动的盒子「是不占位置的」，它原来的位置「漏给了标准流的盒子」。 特 「特别注意」：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙 清除浮动因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子。总结： 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响 准确地说，并不是清除浮动，而是清除浮动后造成的影响 清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 清除浮动的方法1选择器 &#123; clear: 属性值; &#125; clear 清除 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 实际工作中,几乎只用clear: both 1).额外标签法(隔墙法) 是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 ，或则其他标签br等亦可。 优点：通俗易懂，书写方便 缺点：添加许多无意义的标签，结构化较差。 2).父级添加overflow属性方法 1可以给父级添加： overflow为 hidden| auto| scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 3).使用after伪元素清除浮动:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了 12345678910111213.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden;&#125; /* IE6、7 专有 */.clearfix &#123; *zoom: 1;&#125; 优点：符合闭合浮动思想 结构语义化正确 缺点：由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 4).使用双伪元素清除浮动 12345678910111213.clearfix:before,.clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 清除浮动总结1什么时候用清除浮动呢？ 父级没高度 子盒子浮动了 影响下面布局了，我们就应该清除浮动了。 清除浮动的方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差。 父级overflow:hidden; 书写简单 溢出隐藏 父级after伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 父级双伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 CSS属性书写顺序建议遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … 1234567891011121314151617.jdc &#123; display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, &#x27;Helvetica Neue&#x27;, Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;&#125; 定位(position)1. 定位详解 将盒子「定」在某一个「位」置 自由的漂浮在其他盒子(包括标准流和浮动)的上面。 所以，我们脑海应该有三种布局机制的上下顺序👇👇标准流在最底层 (海底) ——- 浮动 的盒子 在 中间层 (海面) ——- 定位的盒子 在 最上层 （天空） 定位是用来布局的，它有两部分组成：定位 = 定位模式 + 边偏移在 CSS 中，通过 top、bottom、left 和 right 属性定义元素的「边偏移」：（方位名词） 边偏移属性 示例 描述 top top: 80px 「顶端」偏移量，定义元素相对于其父元素「上边线的距离」。 bottom bottom: 80px 「底部」偏移量，定义元素相对于其父元素「下边线的距离」。 left left: 80px 「左侧」偏移量，定义元素相对于其父元素「左边线的距离」。 right right: 80px 「右侧」偏移量，定义元素相对于其父元素「右边线的距离」 2. 定位模式(position)在 CSS 中，通过 position 属性定义元素的「定位模式」，语法如下： 1选择器 &#123; position: 属性值; &#125; 值 语义 static 「静态」定位 relative 「相对」定位 absolute 「绝对」定位 fixed 「固定」定位 3. 静态定位(static) 静态定位是元素的默认定位方式，无定位的意思。它相当于border里面的none，不要定位的时候用。 静态定位 按照标准流特性摆放位置。它没有边偏移。 静态定位在布局时几乎不用 4. 相对定位(relative) 相对定位是元素相对于它原来在标准流中的位置来说的。 相对于自己原来在标准流中位置来移动的 原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。 5. 绝对定位(absolute) 绝对定位是元素以带有定位的父级元素来移动位置 完全脱表–完全不占位置； 父元素没有定位，则以浏览器为准定位(Document文档)。 父元素有定位 定位口诀–子绝父相6. 固定定位(fixed) 固定定位是绝对定位的一种特殊形式; 完全脱标–完全不占位置； 只认浏览器的可视窗口–浏览器可视窗口+边偏移属性来设置元素的位置 跟父元素没有任何关系；单独使用 不随滚动条滚动 定位(position)的扩展绝对定位的盒子居中 绝对定位/固定定位的盒子不能通过设置margin: auto设置水平居中 在使用绝对定位时要向实现水平居中，可以按照下面的方法： left : 50%:让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;让盒子向左移动自身宽度的一半。 同理垂直居中。 堆叠顺序（z-index）在使用「定位」布局时，可能会「出现盒子重叠的情况」。 加了定位的盒子，默认「后来者居上」， 后面的盒子会压住前面的盒子。 应用 z-index 层叠等级属性可以「调整盒子的堆叠顺序」。如下图所示： z-index的特性如下: 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位 z-index只能用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 定位改变display属性前面提过， display 是 显示模式， 可以通过以下方式改变显示模式: 可以用inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。 所以说， 一个行内的盒子，如果加了「浮动」、「固定定位」和「绝对定位」，不用转换，就可以给这个盒子直接设置宽度和高度等。 定位小结 定位模式 是否脱标占有位置 移动位置基准 模式转换（行内块） 使用情况 静态static 不脱标，正常模式 正常模式 不能 几乎不用 相对定位relative 不脱标，占有位置 相对自身位置移动 不能 基本单独使用 绝对定位absolute 完全脱标，不占有位置 相对于定位父级移动位置 能 要和定位父级元素搭配使用 固定定位fixed 完全脱标，不占有位置 相对于浏览器移动位置 能 单独使用，不需要父级 注意： 边偏移 需要和 定位模式 联合使用，单独使用无效； top 和 bottom 不要同时使用； left 和 right 不要同时使用。 CSS高级技巧元素的显示与隐藏 **目的:**让一个元素在页面中消失或者显示出来 **场景:**类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ display 显示（重点）display设置或检索对象是否显示或如何显示。 display: none 隐藏对象 特点：隐藏之后，不再保留位置。 display: block 除了转换为块级元素之外，同时还有显示元素的意思。 实际开发场景：配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 可见性设置或检索是否显示对象 123visibility：visible ; 对象可视visibility：hidden; 对象隐藏 特点：隐藏之后，继续保留原有位置。 overflow 溢出检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。 显示与隐藏总结 属性 区别 用途 display 隐藏对象，不保留位置 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 隐藏对象，保留位置 使用较少 overflow 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 CSS用户界面样式所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 表单轮廓等。 防止表单域拖拽 鼠标样式设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 属性值 描述 default 小白 默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 1234567&lt;ul&gt; &lt;li style=&quot;cursor:default&quot;&gt;我是小白&lt;/li&gt; &lt;li style=&quot;cursor:pointer&quot;&gt;我是小手&lt;/li&gt; &lt;li style=&quot;cursor:move&quot;&gt;我是移动&lt;/li&gt; &lt;li style=&quot;cursor:text&quot;&gt;我是文本&lt;/li&gt; &lt;li style=&quot;cursor:not-allowed&quot;&gt;我是文本&lt;/li&gt;&lt;/ul&gt; 轮廓线 outline是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 1outline : outline-color ||outline-style || outline-width 但是我们都不关心可以设置多少，我们平时都是去掉的。最直接的写法是 ： outline: 0; 或者 outline: none; 防止拖拽文本域resize 1&lt;textarea style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt; 2.4 用户界面样式总结 属性 用途 用途 鼠标样式 更改鼠标样式cursor 样式很多，重点记住 pointer 轮廓线 表单默认outline outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用 防止拖拽 主要针对文本域resize 防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none vertical-align 垂直对齐 有宽度的块级元素居中对齐，是margin: 0 auto; 让文字居中对齐，是 text-align: center; vertical-align 垂直对齐，它只针对于「行内元素」或者「行内块元素」 12设置或检索对象内容的垂直对其方式。vertical-align : baseline |top |middle |bottom 注意： vertical-align 不影响块级元素中的内容对齐，它只针对于「行内元素」或者「行内块元素」， 特别是行内块元素， 通常用来控制图片/表单与文字的对齐。 3.1 图片、表单和文字对齐我们可以通过vertical-align 控制图片和文字的垂直关系了。默认的图片会和文字基线对齐。 3.2 去除图片底侧空白缝隙原因：图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。 就是图片底侧会有一个空白缝隙。 解决方法： 给img vertical-align:middle | top| bottom等等。 让图片不要和基线对齐。 给img 添加 display：block; 转换为块级元素就不会存在问题了。 溢出的文字省略号显示white-space white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 123white-space:normal ；默认处理方式white-space:nowrap ； 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。 text-overflow 文字溢出 设置或检索是否使用一个省略标记（…）标示对象内文本的溢出 123text-overflow : clip ；不显示省略标记（...），而是简单的裁切 text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...） 「注意」： 一定要首先强制一行内显示，再次和overflow属性 搭配使用 总结三步曲123456/*1. 先强制一行内显示文本*/ white-space: nowrap;/*2. 超出的部分隐藏*/ overflow: hidden;/*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; CSS精灵技术（sprite)CSS精灵技术（也称CSS Sprites、CSS雪碧）。 图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。 然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。 为什么需要精灵技术：为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。 精灵技术讲解CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。 这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。 我们需要使用CSS的: background-image、 background-repeat background-position属性进行背景定位， 其中最关键的是使用background-position 属性精确地定位。 精灵技术使用的核心总结首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。 精确测量，每个小背景图片的大小和 位置。 给盒子指定小背景图片时， 背景定位基本都是 负值。 滑动门 滑动门出现的背景制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？ 为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。最常见于各种导航栏的滑动门。 核心技术核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： 123456789101112131415161718192021222324252627282930313233343536&lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span&gt;导航栏内容&lt;/span&gt; &lt;/a&gt;&lt;/li&gt;* &#123; padding:0; margin:0; &#125; body&#123; background: url(images/wx.jpg) repeat-x; &#125; .father &#123; padding-top:20px; &#125; li &#123; padding-left: 16px; height: 33px; float: left; line-height: 33px; margin:0 10px; background: url(./images/to.png) no-repeat left ; &#125; a &#123; padding-right: 16px; height: 33px; display: inline-block; color:#fff; background: url(./images/to.png) no-repeat right ; text-decoration: none; &#125; li:hover, li:hover a &#123; background-image:url(./images/ao.png); &#125; 总结： a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 CSS 三角形12345678910111213141516div &#123; width: 0; height: 0; line-height:0； font-size: 0; border-top: 10px solid red; border-right: 10px solid green; border-bottom: 10px solid blue; border-left: 10px solid #000; &#125; 我们用css 边框可以模拟三角效果 宽度高度为0 我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了 为了照顾兼容性 低版本的浏览器，加上 font-size: 0; line-height: 0;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"JavaScript提高班之ES6(七)","slug":"JavaScript提高班之ES6(七)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T08:37:59.053Z","comments":true,"path":"2022/04/24/JavaScript提高班之ES6(七)/","link":"","permalink":"http://example.com/2022/04/24/JavaScript%E6%8F%90%E9%AB%98%E7%8F%AD%E4%B9%8BES6(%E4%B8%83)/","excerpt":"","text":"JavaScript提高班之ES6(七)✍JavaScript帝国之行🔥✍目录总览 1、严格模式 JavaScript 除了提供正常模式外，还提供了严格模式 ES5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，即在严格的条件下运行 JS 代码 严格模式在IE10 以上版本的浏览器才会被支持，旧版本浏览器会被忽略 严格模式对正常的JavaScript语义做了一些更改： 消除了Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全 提高编译器效率，增加运行速度 禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class, enum, export, extends, import, super 不能做变量名 1.1、开启严格模式 严格模式可以应用到整个脚本或个别函数中。 因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况 1.1.2、为脚本开启严格模式 为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句 &quot;use strict&quot; 或&#39;use strict&#39; 1234&lt;script&gt; &#x27;user strict&#x27;; console.log(&quot;这是严格模式。&quot;);&lt;/script&gt; 因为&quot;use strict&quot;加了引号，所以老版本的浏览器会把它当作一行普通字符串而忽略。 有的 script 基本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他 script 脚本文件。 1234567&lt;script&gt; (function ()&#123; &#x27;use strict&#x27;; var num = 10; function fn() &#123;&#125; &#125;)(); &lt;/script&gt; 1.1.2、为函数开启严格模式 若要给某个函数开启严格模式，需要把&quot;use strict&quot;或&#39;use strict&#39;声明放在函数体所有语句之前 123456789101112131415161718192021222324&lt;body&gt; &lt;!-- 为整个脚本(script标签)开启严格模式 --&gt; &lt;script&gt; &#x27;use strict&#x27;; // 下面的js 代码就会按照严格模式执行代码 &lt;/script&gt; &lt;script&gt; (function() &#123; &#x27;use strict&#x27;; &#125;)(); &lt;/script&gt; &lt;!-- 为某个函数开启严格模式 --&gt; &lt;script&gt; // 此时只是给fn函数开启严格模式 function fn() &#123; &#x27;use strict&#x27;; // 下面的代码按照严格模式执行 &#125; function fun() &#123; // 里面的还是按照普通模式执行 &#125; &lt;/script&gt;&lt;/body&gt; 将&quot;use strict&quot; 放在函数体的第一行，则整个函数以 “严格模式”运行。 2、严格模式中的变化 严格模式对JavaScript的语法和行为，都做了一些改变 2.1、变量规定 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量 严格模式禁止这种用法，变量都必须先用var 命令声明，然后再使用 严禁删除已经声明变量，例如，``delete x` 语法是错误的 123456789101112&lt;body&gt; &lt;script&gt; &#x27;use strict&#x27;; // 1. 我们的变量名必须先声明再使用 // num = 10; // console.log(num); var num = 10; console.log(num); // 2.我们不能随意删除已经声明好的变量 // delete num; &lt;/script&gt;&lt;/body&gt; 2.2、严格模式下this指向问题 以前在全局作用域函数中的this指向window对象 严格模式下全局作用域中函数中的this 是 undefined 以前构造函数时不加 new 也可以调用，当普通函数，this指向全局对象 严格模式下，如果构造函数不加 new 调用，this指向的是 undefined ，如果给它赋值，会报错 new 实例化的构造函数指向创建的对象实例 定时器this 还是指向window 事件、对象还是指向调用者 123456789101112131415161718192021222324&lt;body&gt; &lt;script&gt; &#x27;use strict&#x27;; //3. 严格模式下全局作用域中函数中的 this 是 undefined。 function fn() &#123; console.log(this); // undefined。 &#125; fn(); //4. 严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错. function Star() &#123; this.sex = &#x27;男&#x27;; &#125; // Star(); var ldh = new Star(); console.log(ldh.sex); //5. 定时器 this 还是指向 window setTimeout(function() &#123; console.log(this); &#125;, 2000); &lt;/script&gt;&lt;/body&gt; 2.3、函数变化 函数不能有重名的参数 函数必须声明在顶层，新版本的JavaScript会引入“块级作用域”（ES6中已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数 123456789101112&lt;body&gt; &lt;script&gt; &#x27;use strict&#x27;; // 6. 严格模式下函数里面的参数不允许有重名 function fn(a, a) &#123; console.log(a + a); &#125;; // fn(1, 2); function fn() &#123;&#125; &lt;/script&gt;&lt;/body&gt; 3、高阶函数 高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出 接收函数作为参数 123456789101112131415&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; // 高阶函数- 函数可以作为参数传递 function fn(a, b, callback) &#123; console.log(a + b); callback &amp;&amp; callback(); &#125; fn(1, 2, function() &#123; console.log(&#x27;我是最后调用的&#x27;); &#125;); &lt;/script&gt;&lt;/body&gt; 将函数作为返回值 12345&lt;script&gt; function fn()&#123; return function() &#123;&#125; &#125;&lt;/script&gt; 此时 fn 就是一个高阶函数 函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数 同理函数也可以作为返回值传递回来 4、闭包4.1、变量作用域变量根据作用域的不同分为两种：全局变量和局部变量 函数内部可以使用全局变量 函数外部不可以使用局部变量 当函数执行完毕，本作用域内的局部变量会销毁。 4.2、什么是闭包闭包指有权访问另一个函数作用域中的变量的函数 简单理解：一个作用域可以访问另外一个函数内部的局部变量 1234567891011121314&lt;body&gt; &lt;script&gt; // 闭包（closure）指有权访问另一个函数作用域中变量的函数。 // 闭包: 我们fn2 这个函数作用域 访问了另外一个函数 fn1 里面的局部变量 num function fn1() &#123; // fn1就是闭包函数 var num = 10; function fn2() &#123; console.log(num); //10 &#125; fn2(); &#125; fn1(); &lt;/script&gt;&lt;/body&gt; 4.3、在chrome中调试闭包 打开浏览器，按 F12 键启动 chrome 调试工具。 设置断点。 找到 Scope 选项（Scope 作用域的意思）。 当我们重新刷新页面，会进入断点调试，Scope 里面会有两个参数（global 全局作用域、local 局部作用域）。 当执行到 fn2() 时，Scope 里面会多一个 Closure 参数 ，这就表明产生了闭包。 4.4、闭包的作用 延伸变量的作用范围 12345678910111213141516&lt;body&gt; &lt;script&gt; // 闭包（closure）指有权访问另一个函数作用域中变量的函数。 // 一个作用域可以访问另外一个函数的局部变量 // 我们fn 外面的作用域可以访问fn 内部的局部变量 // 闭包的主要作用: 延伸了变量的作用范围 function fn() &#123; var num = 10; return function() &#123; console.log(num); &#125; &#125; var f = fn(); f(); &lt;/script&gt;&lt;/body&gt; 4.5、闭包练习4.5.1、点击li输出索引号123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;榴莲&lt;/li&gt; &lt;li&gt;臭豆腐&lt;/li&gt; &lt;li&gt;鲱鱼罐头&lt;/li&gt; &lt;li&gt;大猪蹄子&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 闭包应用-点击li输出当前li的索引号 // 1. 我们可以利用动态添加属性的方式 var lis = document.querySelector(&#x27;.nav&#x27;).querySelectorAll(&#x27;li&#x27;); for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].index = i; lis[i].onclick = function() &#123; // console.log(i); console.log(this.index); &#125; &#125; // 2. 利用闭包的方式得到当前小li 的索引号 for (var i = 0; i &lt; lis.length; i++) &#123; // 利用for循环创建了4个立即执行函数 // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量 (function(i) &#123; // console.log(i); lis[i].onclick = function() &#123; console.log(i); &#125; &#125;)(i); &#125; &lt;/script&gt;&lt;/body&gt; 4.5.2、定时器中的闭包12345678910111213141516171819&lt;body&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;榴莲&lt;/li&gt; &lt;li&gt;臭豆腐&lt;/li&gt; &lt;li&gt;鲱鱼罐头&lt;/li&gt; &lt;li&gt;大猪蹄子&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 闭包应用-3秒钟之后,打印所有li元素的内容 var lis = document.querySelector(&#x27;.nav&#x27;).querySelectorAll(&#x27;li&#x27;); for (var i = 0; i &lt; lis.length; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(lis[i].innerHTML); &#125;, 3000) &#125;)(i); &#125; &lt;/script&gt;&lt;/body&gt; 5、递归如果一个函数在内部可以调用其本身，那么这个函数就是递归函数 简单理解： 函数内部自己调用自己，这个函数就是递归函数 由于递归很容易发生”栈溢出”错误，所以必须要加退出条件 return 1234567891011121314151617&lt;body&gt; &lt;script&gt; // 递归函数 : 函数内部自己调用自己, 这个函数就是递归函数 var num = 1; function fn() &#123; console.log(&#x27;我要打印6句话&#x27;); if (num == 6) &#123; return; // 递归里面必须加退出条件 &#125; num++; fn(); &#125; fn(); &lt;/script&gt;&lt;/body&gt; 6、浅拷贝和深拷贝 浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用 深拷贝拷贝多层，每一级别的数据都会拷贝 Object.assign(target,....sources) ES6新增方法可以浅拷贝 6.1、浅拷贝12345678910111213141516// 浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用var obj = &#123; id: 1, name: &#x27;andy&#x27;, msg: &#123; age: 18 &#125;&#125;;var o = &#123;&#125;for(var k in obj)&#123; // k是属性名，obj[k]是属性值 o[k] = obj[k];&#125;console.log(o);// 浅拷贝语法糖Object.assign(o,obj); 6.2、深拷贝1234567891011121314151617181920212223242526272829303132// 深拷贝拷贝多层，每一级别的数据都会拷贝var obj = &#123; id: 1, name: &#x27;andy&#x27;, msg: &#123; age: 18 &#125; color: [&#x27;pink&#x27;,&#x27;red&#x27;]&#125;;var o = &#123;&#125;;// 封装函数function deepCopy(newobj,oldobj)&#123; for(var k in oldobj)&#123; // 判断属性值属于简单数据类型还是复杂数据类型 // 1.获取属性值 oldobj[k] var item = oldobj[k]; // 2.判断这个值是否是数组 if(item instanceof Array)&#123; newobj[k] = []; deepCopy(newobj[k],item) &#125;else if (item instanceof Object)&#123; // 3.判断这个值是否是对象 newobj[k] = &#123;&#125;; deepCopy(newobj[k],item) &#125;else &#123; // 4.属于简单数据类型 newobj[k] = item; &#125; &#125;&#125;deepCopy(o,obj); 7、 正则表达式正则表达式是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。 正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 7.1、特点 实际开发，一般都是直接复制写好的正则表达式 但是要求会使用正则表达式并且根据自身实际情况修改正则表达式 7.2、创建正则表达式在JavaScript中，可以通过两种方式创建正则表达式 通过调用 RegExp 对象的构造函数创建 通过字面量创建 7.2.1、通过调用 RegExp 对象的构造函数创建通过调用 RegExp 对象的构造函数创建 1var 变量名 = new RegExp(/表达式/); 7.2.2、通过字面量创建通过字面量创建 1var 变量名 = /表达式/; 注释中间放表达式就是正则字面量 7.2.3、测试正则表达式 test test()正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false,其参数是测试字符串 1regexObj.test(str) regexObj 写的是正则表达式 str 我们要测试的文本 就是检测str文本是否符合我们写的正则表达式规范 示例 123456789101112131415&lt;body&gt; &lt;script&gt; // 正则表达式在js中的使用 // 1. 利用 RegExp对象来创建 正则表达式 var regexp = new RegExp(/123/); console.log(regexp); // 2. 利用字面量创建 正则表达式 var rg = /123/; // 3.test 方法用来检测字符串是否符合正则表达式要求的规范 console.log(rg.test(123)); console.log(rg.test(&#x27;abc&#x27;)); &lt;/script&gt;&lt;/body&gt; 7.3、正则表达式中的特殊在字符7.3.1、边界符正则表达式中的边界符(位置符)用来提示字符所处的位置，主要有两个字符 边界符 说明 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 如果^ 和 $ 在一起，表示必须是精确匹配 1234567891011121314// 边界符 ^ $var rg = /abc/; //正则表达式里面不需要加引号，不管是数字型还是字符串型// /abc/只要包含有abc这个字符串返回的都是trueconsole.log(rg.test(&#x27;abc&#x27;));console.log(rg.test(&#x27;abcd&#x27;));console.log(rg.test(&#x27;aabcd&#x27;));var reg = /^abc/;console.log(reg.test(&#x27;abc&#x27;)); //trueconsole.log(reg.test(&#x27;abcd&#x27;)); // trueconsole.log(reg.test(&#x27;aabcd&#x27;)); // falsevar reg1 = /^abc$/// 以abc开头，以abc结尾，必须是abc 7.3.2、字符类 字符类表示有一系列字符可供选择，只要匹配其中一个就可以了 所有可供选择的字符都放在方括号内 ①[] 方括号1/[abc]/.test(&#x27;andy&#x27;); // true 后面的字符串只要包含 abc 中任意一个字符,都返回true ②[-]方括号内部 范围符1/^[a-z]$/.test() 方括号内部加上 - 表示范围，这里表示 a - z 26个英文字母都可以 ③[^] 方括号内部 取反符 ^1/[^abc]/.test(&#x27;andy&#x27;) // false 方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 注意和边界符 ^ 区别，边界符写到方括号外面 ④字符组合1/[a-z1-9]/.test(&#x27;andy&#x27;) // true 方括号内部可以使用字符组合，这里表示包含 a 到 z的26个英文字母和1到9的数字都可以 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;script&gt; //var rg = /abc/; 只要包含abc就可以 // 字符类: [] 表示有一系列字符可供选择，只要匹配其中一个就可以了 var rg = /[abc]/; // 只要包含有a 或者 包含有b 或者包含有c 都返回为true console.log(rg.test(&#x27;andy&#x27;)); console.log(rg.test(&#x27;baby&#x27;)); console.log(rg.test(&#x27;color&#x27;)); console.log(rg.test(&#x27;red&#x27;)); var rg1 = /^[abc]$/; // 三选一 只有是a 或者是 b 或者是c 这三个字母才返回 true console.log(rg1.test(&#x27;aa&#x27;)); console.log(rg1.test(&#x27;a&#x27;)); console.log(rg1.test(&#x27;b&#x27;)); console.log(rg1.test(&#x27;c&#x27;)); console.log(rg1.test(&#x27;abc&#x27;)); console.log(&#x27;------------------&#x27;); var reg = /^[a-z]$/; // 26个英文字母任何一个字母返回 true - 表示的是a 到z 的范围 console.log(reg.test(&#x27;a&#x27;)); console.log(reg.test(&#x27;z&#x27;)); console.log(reg.test(1)); console.log(reg.test(&#x27;A&#x27;)); // 字符组合 var reg1 = /^[a-zA-Z0-9_-]$/; // 26个英文字母(大写和小写都可以)任何一个字母返回 true console.log(reg1.test(&#x27;a&#x27;)); console.log(reg1.test(&#x27;B&#x27;)); console.log(reg1.test(8)); console.log(reg1.test(&#x27;-&#x27;)); console.log(reg1.test(&#x27;_&#x27;)); console.log(reg1.test(&#x27;!&#x27;)); console.log(&#x27;----------------&#x27;); // 如果中括号里面有^ 表示取反的意思 千万和 我们边界符 ^ 别混淆 var reg2 = /^[^a-zA-Z0-9_-]$/; console.log(reg2.test(&#x27;a&#x27;)); console.log(reg2.test(&#x27;B&#x27;)); console.log(reg2.test(8)); console.log(reg2.test(&#x27;-&#x27;)); console.log(reg2.test(&#x27;_&#x27;)); console.log(reg2.test(&#x27;!&#x27;)); &lt;/script&gt;&lt;/body&gt; 7.3.3、量词符量词符用来设定某个模式出现的次数 量词 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;script&gt; // 量词符: 用来设定某个模式出现的次数 // 简单理解: 就是让下面的a这个字符重复多少次 // var reg = /^a$/; // * 相当于 &gt;= 0 可以出现0次或者很多次 // var reg = /^a*$/; // console.log(reg.test(&#x27;&#x27;)); // console.log(reg.test(&#x27;a&#x27;)); // console.log(reg.test(&#x27;aaaa&#x27;)); // + 相当于 &gt;= 1 可以出现1次或者很多次 // var reg = /^a+$/; // console.log(reg.test(&#x27;&#x27;)); // false // console.log(reg.test(&#x27;a&#x27;)); // true // console.log(reg.test(&#x27;aaaa&#x27;)); // true // ? 相当于 1 || 0 // var reg = /^a?$/; // console.log(reg.test(&#x27;&#x27;)); // true // console.log(reg.test(&#x27;a&#x27;)); // true // console.log(reg.test(&#x27;aaaa&#x27;)); // false // &#123;3 &#125; 就是重复3次 // var reg = /^a&#123;3&#125;$/; // console.log(reg.test(&#x27;&#x27;)); // false // console.log(reg.test(&#x27;a&#x27;)); // false // console.log(reg.test(&#x27;aaaa&#x27;)); // false // console.log(reg.test(&#x27;aaa&#x27;)); // true // &#123;3, &#125; 大于等于3 var reg = /^a&#123;3,&#125;$/; console.log(reg.test(&#x27;&#x27;)); // false console.log(reg.test(&#x27;a&#x27;)); // false console.log(reg.test(&#x27;aaaa&#x27;)); // true console.log(reg.test(&#x27;aaa&#x27;)); // true // &#123;3,16&#125; 大于等于3 并且 小于等于16 var reg = /^a&#123;3,6&#125;$/; console.log(reg.test(&#x27;&#x27;)); // false console.log(reg.test(&#x27;a&#x27;)); // false console.log(reg.test(&#x27;aaaa&#x27;)); // true console.log(reg.test(&#x27;aaa&#x27;)); // true console.log(reg.test(&#x27;aaaaaaa&#x27;)); // false &lt;/script&gt;&lt;/body&gt; 7.3.4、用户名验证功能需求： 如果用户名输入合法, 则后面提示信息为 : 用户名合法,并且颜色为绿色 如果用户名输入不合法, 则后面提示信息为: 用户名不符合规范, 并且颜色为绿色 分析： 用户名只能为英文字母,数字,下划线或者短横线组成, 并且用户名长度为 6~16位. 首先准备好这种正则表达式模式 /$[a-zA-Z0-9-_]{6,16}^/ 当表单失去焦点就开始验证. 如果符合正则规范, 则让后面的span标签添加 right 类. 如果不符合正则规范, 则让后面的span标签添加 wrong 类. 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;input type=&quot;text&quot; class=&quot;uname&quot;&gt; &lt;span&gt;请输入用户名&lt;/span&gt; &lt;script&gt; // 量词是设定某个模式出现的次数 var reg = /^[a-zA-Z0-9_-]&#123;6,16&#125;$/; // 这个模式用户只能输入英文字母 数字 下划线 短横线但是有边界符和[] 这就限定了只能多选1 // &#123;6,16&#125; 中间不要有空格 // console.log(reg.test(&#x27;a&#x27;)); // console.log(reg.test(&#x27;8&#x27;)); // console.log(reg.test(&#x27;18&#x27;)); // console.log(reg.test(&#x27;aa&#x27;)); // console.log(&#x27;-------------&#x27;); // console.log(reg.test(&#x27;andy-red&#x27;)); // console.log(reg.test(&#x27;andy_red&#x27;)); // console.log(reg.test(&#x27;andy007&#x27;)); // console.log(reg.test(&#x27;andy!007&#x27;)); var uname = document.querySelector(&#x27;.uname&#x27;); var span = document.querySelector(&#x27;span&#x27;); uname.onblur = function() &#123; if (reg.test(this.value)) &#123; console.log(&#x27;正确的&#x27;); span.className = &#x27;right&#x27;; span.innerHTML = &#x27;用户名格式输入正确&#x27;; &#125; else &#123; console.log(&#x27;错误的&#x27;); span.className = &#x27;wrong&#x27;; span.innerHTML = &#x27;用户名格式输入不正确&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 7.4、括号总结 大括号 量词符 里面面表示重复次数 中括号 字符集合 匹配方括号中的任意字符 小括号 表示优先级 1234567// 中括号 字符集合 匹配方括号中的任意字符var reg = /^[abc]$/;// a || b || c// 大括号 量词符 里面表示重复次数var reg = /^abc&#123;3&#125;$/; // 它只是让c 重复3次 abccc// 小括号 表示优先级var reg = /^(abc)&#123;3&#125;$/; //它是让 abc 重复3次 在线测试正则表达式：https://c.runoob.com/ 7.5、预定义类预定义类指的是 某些常见模式的简写写法 预定类 说明 \\d 匹配0-9之间的任一数字，相当于[0-9] \\D 匹配所有0-9以外的字符，相当于[ ^ 0-9] \\w 匹配任意的字母、数字和下划线,相当于[A-Za-z0-9_ ] \\W 除所有字母、数字、和下划线以外的字符，相当于[ ^A-Za-z0-9_ ] \\s 匹配空格（包括换行符，制表符，空格符等），相当于[\\t\\t\\n\\v\\f] \\S 匹配非空格的字符，相当于[ ^ \\t\\r\\n\\v\\f] 7.5.1、表单验证分析： 1.手机号码: /^1[3|4|5|7|8][0-9]&#123;9&#125;$/ 2.QQ: [1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始) 3.昵称是中文: ^[\\u4e00-\\u9fa5]&#123;2,8&#125;$ 12345678&lt;body&gt; &lt;script&gt; // 座机号码验证: 全国座机号码 两种格式: 010-12345678 或者 0530-1234567 // 正则里面的或者 符号 | // var reg = /^\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;$/; var reg = /^\\d&#123;3,4&#125;-\\d&#123;7,8&#125;$/; &lt;/script&gt;&lt;/body&gt; 7.6、正则表达式中的替换7.6.1、replace 替换replace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式 1stringObject.replace(regexp/substr,replacement) 第一个参数: 被替换的字符串或者正则表达式 第二个参数：替换为的字符串 返回值是一个替换完毕的新字符串 1234// 替换 replacevar str = &#x27;andy和red&#x27;;var newStr = str.replace(&#x27;andy&#x27;,&#x27;baby&#x27;);var newStr = str.replace(/andy/,&#x27;baby&#x27;); 7.6.2、正则表达式参数1/表达式/[switch] switch按照什么样的模式来匹配，有三种 g: 全局匹配 i:忽略大小写 gi: 全局匹配 + 忽略大小写 ​","categories":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"JavaScript进阶班之BOM技术(五)","slug":"JavaScript进阶班之BOM技术(五)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T08:30:14.977Z","comments":true,"path":"2022/04/24/JavaScript进阶班之BOM技术(五)/","link":"","permalink":"http://example.com/2022/04/24/JavaScript%E8%BF%9B%E9%98%B6%E7%8F%AD%E4%B9%8BBOM%E6%8A%80%E6%9C%AF(%E4%BA%94)/","excerpt":"","text":"✍目录总览 BOM概述 BOM = Browser Object Model 👉浏览器对象模型 它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性 BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA, DOM 的标准化组织是 W3C, BOM最初是Netscape 浏览器标准的一部分 DOM BOM 文档对象模型 浏览器对象模型 DOM 就是把 文档 当作一个对象来看待 把 浏览器当作一个对象来看待 DOM 的顶级对象是 document BOM 的顶级对象是 window DOM 主要学习的是操作页面元素 BOM 学习的是浏览器窗口交互的一些对象 DOM 是 W3C 标准规范 BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差 BOM的构成 BOM 比 DOM 更大。它包含 DOM。 window 对象是浏览器的顶级对象，它具有双重角色 它是 JS 访问浏览器窗口的一个接口 它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法 在调用的时候可以省略 window，前面学习的对话框都属于 window 对象方法，如 alert()、prompt()等。 注意：window下的一个特殊属性 window.name 1234567891011121314// 定义在全局作用域中的变量会变成window对象的属性var num = 10;console.log(window.num);// 10// 定义在全局作用域中的函数会变成window对象的方法function fn() &#123; console.log(11);&#125;console.log(fn());// 11var name = 10; //不要用这个name变量,window下有一个特殊属性window.nameconsole.log(window.num); window 对象的常见事件窗口加载事件window.onload是窗口（页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像，脚本文件，CSS文件等），就调用的处理函数。 123456window.onload = function()&#123; &#125;;// 或者window.addEventListener(&quot;load&quot;,function()&#123;&#125;); 注意： 有了window.onload就可以把JS代码写到页面元素的上方 因为onload是等页面内容全部加载完毕，再去执行处理函数 window.onload 传统注册事件方式，只能写一次 如果有多个，会以最后一个window.onload为准 如果使用addEventListener 则没有限制 1document.addEventListener(&#x27;DOMContentLoaded&#x27;,function()&#123;&#125;) 接收两个参数： DOMCountentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等 如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded事件比较合适。 区别 load等页面内容全部加载完毕，包括页面dom元素，图片，flash，css等 DOMContentLoaded 是DOM加载完毕，不包含图片 flash css 等就可以执行，加载速度比load更快一些 123456789101112131415161718192021222324252627&lt;script&gt; // window.onload = function() &#123; // var btn = document.querySelector(&#x27;button&#x27;); // btn.addEventListener(&#x27;click&#x27;, function() &#123; // alert(&#x27;点击我&#x27;); // &#125;) // &#125; // window.onload = function() &#123; // alert(22); // &#125; window.addEventListener(&#x27;load&#x27;, function() &#123; var btn = document.querySelector(&#x27;button&#x27;); btn.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;点击我&#x27;); &#125;) &#125;) window.addEventListener(&#x27;load&#x27;, function() &#123; alert(22); &#125;) document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123; alert(33); &#125;) // load 等页面内容全部加载完毕，包含页面dom元素 图片 flash css 等等 // DOMContentLoaded 是DOM 加载完毕，不包含图片 falsh css 等就可以执行 加载速度比 load更快一些&lt;/script&gt; 调整窗口大小事件window.onresize 是调整窗口大小加载事件，当触发时就调用的处理函数 1234window.onresize = function() &#123;&#125;// 或者window.addEventListener(&#x27;resize&#x27;,function()&#123;&#125;); 只要窗口大小发生像素变化，就会触发这个事件 我们经常利用这个事件完成响应式布局。window.innerWidth 当前屏幕的宽度 12345678910111213141516171819&lt;body&gt; &lt;script&gt; window.addEventListener(&#x27;load&#x27;, function() &#123; var div = document.querySelector(&#x27;div&#x27;); window.addEventListener(&#x27;resize&#x27;, function() &#123; console.log(window.innerWidth); console.log(&#x27;变化了&#x27;); if (window.innerWidth &lt;= 800) &#123; div.style.display = &#x27;none&#x27;; &#125; else &#123; div.style.display = &#x27;block&#x27;; &#125; &#125;) &#125;) &lt;/script&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 定时器window 对象给我们提供了两个定时器 setTimeout() setInterval() setTimeout()定时器setTimeout()方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。 1window.setTimeout(调用函数,[延迟的毫秒数]); 注意： window可以省略 这个调用函数 可以直接写函数 或者写函数名 或者采取字符串 ‘函数名()’ （不推荐） 延迟的毫秒数省略默认是0，如果写，必须是毫秒 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符 setTimeout() 这个调用函数我们也称为回调函数 callback 普通函数是按照代码顺序直接调用，而这个函数，需要等待事件，事件到了才会去调用这个函数，因此称为回调函数。 123456789101112131415161718192021&lt;body&gt; &lt;script&gt; // 1. setTimeout // 语法规范： window.setTimeout(调用函数, 延时时间); // 1. 这个window在调用的时候可以省略 // 2. 这个延时时间单位是毫秒 但是可以省略，如果省略默认的是0 // 3. 这个调用函数可以直接写函数 还可以写 函数名 还有一个写法 &#x27;函数名()&#x27; // 4. 页面中可能有很多的定时器，我们经常给定时器加标识符 （名字) // setTimeout(function() &#123; // console.log(&#x27;时间到了&#x27;); // &#125;, 2000); function callback() &#123; console.log(&#x27;爆炸了&#x27;); &#125; var timer1 = setTimeout(callback, 3000); var timer2 = setTimeout(callback, 5000); // setTimeout(&#x27;callback()&#x27;, 3000); // 我们不提倡这个写法 &lt;/script&gt;&lt;/body&gt; clearTimeout()停止定时器 clearTimeout()方法取消了先前通过调用 setTimeout()建立的定时器 1window.clearTimeout(timeoutID) 注意： window可以省略 里面的参数就是定时器的标识符 123456789101112&lt;body&gt; &lt;button&gt;点击停止定时器&lt;/button&gt; &lt;script&gt; var btn = document.querySelector(&#x27;button&#x27;); var timer = setTimeout(function() &#123; console.log(&#x27;爆炸了&#x27;); &#125;, 5000); btn.addEventListener(&#x27;click&#x27;, function() &#123; clearTimeout(timer); &#125;) &lt;/script&gt;&lt;/body&gt; setInterval()定时器 setInterval()方法重复调用一个函数，每隔这个时间，就去调用一次回调函数 1window.setInterval(回调函数,[间隔的毫秒数]); window可以省略 这个回调函数: 可以直接写函数 或者写函数名 或者采取字符 ‘函数名()’ 第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次 123456789101112&lt;body&gt; &lt;script&gt; // 1. setInterval // 语法规范： window.setInterval(调用函数, 延时时间); setInterval(function() &#123; console.log(&#x27;继续输出&#x27;); &#125;, 1000); // 2. setTimeout 延时时间到了，就去调用这个回调函数，只调用一次 就结束了这个定时器 // 3. setInterval 每隔这个延时时间，就去调用这个回调函数，会调用很多次，重复调用这个函数 &lt;/script&gt;&lt;/body&gt; clearInterval()停止定时器 clearInterval ( ) 方法取消了先前通过调用 setInterval() 建立的定时器 注意： window可以省略 里面的参数就是定时器的标识符 123456789101112131415161718&lt;body&gt; &lt;button class=&quot;begin&quot;&gt;开启定时器&lt;/button&gt; &lt;button class=&quot;stop&quot;&gt;停止定时器&lt;/button&gt; &lt;script&gt; var begin = document.querySelector(&#x27;.begin&#x27;); var stop = document.querySelector(&#x27;.stop&#x27;); var timer = null; // 全局变量 null是一个空对象 begin.addEventListener(&#x27;click&#x27;, function() &#123; timer = setInterval(function() &#123; console.log(&#x27;ni hao ma&#x27;); &#125;, 1000); &#125;) stop.addEventListener(&#x27;click&#x27;, function() &#123; clearInterval(timer); &#125;) &lt;/script&gt;&lt;/body&gt; this指向 this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁 现阶段，我们先了解一下几个this指向 全局作用域或者普通函数中this指向全局对象window(注意定时器里面的this指向window) 方法调用中谁调用this指向谁 构造函数中this指向构造函数实例 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; // this 指向问题 一般情况下this的最终指向的是那个调用它的对象 // 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window） console.log(this); function fn() &#123; console.log(this); &#125; window.fn(); window.setTimeout(function() &#123; console.log(this); &#125;, 1000); // 2. 方法调用中谁调用this指向谁 var o = &#123; sayHi: function() &#123; console.log(this); // this指向的是 o 这个对象 &#125; &#125; o.sayHi(); var btn = document.querySelector(&#x27;button&#x27;); // btn.onclick = function() &#123; // console.log(this); // this指向的是btn这个按钮对象 // &#125; btn.addEventListener(&#x27;click&#x27;, function() &#123; console.log(this); // this指向的是btn这个按钮对象 &#125;) // 3. 构造函数中this指向构造函数的实例 function Fun() &#123; console.log(this); // this 指向的是fun 实例对象 &#125; var fun = new Fun(); &lt;/script&gt;&lt;/body&gt; JS执行机制JS是单线程 JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 一个问题以下代码执行的结果是什么？ 12345console.log(1);setTimeout(function() &#123; console.log(3);&#125;,1000);console.log(2); 那么以下代码执行的结果又是什么？ 12345console.log(1);setTimeout(function() &#123; console.log(3);&#125;,0);console.log(2); 同步和异步 为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程 于是，JS 中出现了同步和异步。 同步 : 前一个任务结束后再执行后一个任务 异步 ： 在做这件事的同时，你还可以去处理其他事情 同步任务 同步任务都在主线程上执行，形成一个 执行栈 异步任务 JS中的异步是通过回调函数实现的 异步任务有以下三种类型 普通事件，如click,resize等 资源加载，如load,error等 定时器，包括setInterval,setTimeout等 异步任务相关回调函数添加到任务队列中 先执行执行栈中的同步任务 异步任务(回调函数)放入任务队列中 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 此时再来看我们刚才的问题： 12345console.log(1);setTimeout(function() &#123; console.log(3);&#125;,1000);console.log(2); 执行的结果和顺序为 1、2、3 12345console.log(1);setTimeout(function() &#123; console.log(3);&#125;,0);console.log(2); 执行的结果和顺序为 1、2、3 123456789// 3. 第三个问题console.log(1);document.onclick = function() &#123; console.log(&#x27;click&#x27;);&#125;console.log(2);setTimeout(function() &#123; console.log(3)&#125;, 3000) 同步任务放在执行栈中执行，异步任务由异步进程处理放到任务队列中，执行栈中的任务执行完毕会去任务队列中查看是否有异步任务执行，由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。 location对象 window 对象给我们提供了一个 location属性用于获取或者设置窗体的url，并且可以解析url。因为这个属性返回的是一个对象，所以我们将这个属性也称为 location 对象。 url==统一资源定位符（uniform resouce locator）==是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 url 的一般语法格式为： 123protocol://host[:port]/path/[?query]#fragmenthttp://www.itcast.cn/index.html?name=andy&amp;age=18#link 组成 说明 protocol 通信协议 常用的http,ftp,maito等 host 主机(域名) www.itheima.com port 端口号，可选 path 路径 由零或多个&#39;/&#39;符号隔开的字符串 query 参数 以键值对的形式，通过&amp;符号分隔开来 fragment 片段 #后面内容 常见于链接 锚点 location对象属性 location对象属性 返回值 location.href 获取或者设置整个URL location.host 返回主机（域名）www.baidu.com location.port 返回端口号，如果未写返回空字符串 location.pathname 返回路径 location.search 返回参数 location.hash 返回片段 #后面内容常见于链接 锚点 重点记住： href和search 需求：5s之后跳转页面 123456789101112131415161718&lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; var btn = document.querySelector(&#x27;button&#x27;); var div = document.querySelector(&#x27;div&#x27;); var timer = 5; setInterval(function() &#123; if (timer == 0) &#123; location.href = &#x27;http://www.itcast.cn&#x27;; &#125; else &#123; div.innerHTML = &#x27;您将在&#x27; + timer + &#x27;秒钟之后跳转到首页&#x27;; timer--; &#125; &#125;, 1000); &lt;/script&gt;&lt;/body&gt; location对象方法 location对象方法 返回值 location.assign() 跟href一样，可以跳转页面（也称为重定向页面） location.replace() 替换当前页面，因为不记录历史，所以不能后退页面 location.reload() 重新加载页面，相当于刷新按钮或者 f5 ，如果参数为true 强制刷新 ctrl+f5 12345678910111213&lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; var btn = document.querySelector(&#x27;button&#x27;); btn.addEventListener(&#x27;click&#x27;, function() &#123; // 记录浏览历史，所以可以实现后退功能 // location.assign(&#x27;http://www.itcast.cn&#x27;); // 不记录浏览历史，所以不可以实现后退功能 // location.replace(&#x27;http://www.itcast.cn&#x27;); location.reload(true); &#125;) &lt;/script&gt;&lt;/body&gt; 获取URL参数我们简单写一个登录框，点击登录跳转到 index.html 123456&lt;body&gt; &lt;form action=&quot;index.html&quot;&gt; 用户名： &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt; 接下来我们写 index.html 123456789101112131415&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; console.log(location.search); // ?uname=andy // 1.先去掉？ substr(&#x27;起始的位置&#x27;，截取几个字符); var params = location.search.substr(1); // uname=andy console.log(params); // 2. 利用=把字符串分割为数组 split(&#x27;=&#x27;); var arr = params.split(&#x27;=&#x27;); console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;] var div = document.querySelector(&#x27;div&#x27;); // 3.把数据写入div中 div.innerHTML = arr[1] + &#x27;欢迎您&#x27;; &lt;/script&gt;&lt;/body&gt; 这样我们就能获取到路径上的URL参数 navigator对象 navigator 对象包含有关浏览器的信息，它有很多属性 我们常用的是userAgent,该属性可以返回由客户机发送服务器的user-agent头部的值 下面前端代码可以判断用户是用哪个终端打开页面的，如果是用 PC 打开的，我们就跳转到 PC 端的页面，如果是用手机打开的，就跳转到手机端页面 12345if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123; window.location.href = &quot;&quot;; //手机 &#125; else &#123; window.location.href = &quot;&quot;; //电脑 &#125; history对象 window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互 该对象包含用户（在浏览器窗口中）访问过的 URL。 history对象方法 作用 back() 可以后退功能 forward() 前进功能 go(参数) 前进后退功能，参数如果是 1 前进1个页面 如果是 -1 后退1个页面 1234567891011&lt;body&gt; &lt;a href=&quot;list.html&quot;&gt;点击我去往列表页&lt;/a&gt; &lt;button&gt;前进&lt;/button&gt; &lt;script&gt; var btn = document.querySelector(&#x27;button&#x27;); btn.addEventListener(&#x27;click&#x27;, function() &#123; // history.forward(); history.go(1); &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"BOM","slug":"BOM","permalink":"http://example.com/categories/BOM/"}],"tags":[{"name":"BOM","slug":"BOM","permalink":"http://example.com/tags/BOM/"}]},{"title":"JavaScript基础大总结(一)","slug":"JavaScript基础大总结(一)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T08:01:11.585Z","comments":true,"path":"2022/04/24/JavaScript基础大总结(一)/","link":"","permalink":"http://example.com/2022/04/24/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%A7%E6%80%BB%E7%BB%93(%E4%B8%80)/","excerpt":"","text":"JavaScript基础大总结初识JavaScirpt JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思） 脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行 现在也可以基于 Node.js 技术进行服务器端编程 浏览器执行JS简介浏览器分成两部分：渲染引擎和 JS 引擎 渲染引擎：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit JS 引擎：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8 浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。 JS的组成JavaScript 包括 ECMAScript、DOM、BOM ECMAScriptECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。 ECMAScript：ECMAScript 规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。 DOM文档对象模型文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。 BOM浏览器对象模型BOM (Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。 JS初体验行内式JS 可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性)，如： onclink 注意单双引号的使用：在HTML中我们推荐使用双引号，JS中我们推荐使用单引号 可读性差，在 HTML 中编入 JS 大量代码时，不方便阅读 特殊情况下使用 内嵌式JS 可以将多行JS代码写到&lt;script&gt;标签中 内嵌 JS 是学习时常用的方式 外部JS 利于HTML页面代码结构化，把单独JS代码独立到HTML页面之外，既美观，又方便 引用外部JS文件的script标签中间不可以写代码 适合于JS代码量比较大的情况 JS基本语法注释单行注释 快捷键ctrl + / 多行注释 快捷键 shift + alt + a vscode中修改快捷键方式：vscode➡ 首选项按钮➡ 键盘快捷方式 ➡ 查找原来的快捷键➡ 修改为新的快捷键➡ 回车确认 输入输出语句 方法 说明 归属 alert(msg); 浏览器弹出警示框 浏览器 console.log(msg); 浏览器控制台打印输出信息 浏览器 prompt(info); 浏览看弹出输入框，用户可以输入 浏览器 alert() 主要用来显示消息给用户 console.log() 用来给程序员看自己运行时的消息 变量 变量是用于存放数据的容器，我们通过变量名获取数据，甚至数据可以修改 **本质：**变量是程序在**内存**中申请的一块用来存放数据的空间 变量初始化 var是一个JS关键字，用来声明变量(variable变量的意思)。使用该关键字声明变量后，计算机会自动为变量分配内存空间。 age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间 声明变量特殊情况 情况 说明 结果 var age; console.log(age); 只声明，不赋值 undefined console.log(age) 不声明 不赋值 直接使用 报错 age = 10;console.log(age); 不声明 只赋值 10 变量的命名规范 由字母(A-Z,a-z)，数字(0-9)，下划线(_)，美元符号($)组成，如:usrAge,num01,__name 严格区分大小写。 var app; 和 var App; 是两个变量 不能以数字开头。 不能是关键字，保留字。例如：var,for,while 遵循驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName 推荐翻译网站：有道 爱词霸 数据类型JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。 在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。 JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型 JS 把数据类型分为两类： 基本数据类型(Number,String,Boolean,Undefined,Null) 复杂数据类型(Object) 基本数据类型 简单数据类型 说明 默认值 Number 数字型，包含整型值和浮点型值，如21，0.21 0 Boolean 布尔值类型，如true，false ，等价于1和0 false Undefined var a; 声明了变量a但是没有赋值，此时a=undefined undefined（未定义的） string 字符串类型，如“张三” “” Null var a = null;声明了变量a为空值 null 数字型NumberJavaScript 数字类型既可以用来保存整数值，也可以保存小数(浮点数）。 数字型进制最常见的进制有二进制、八进制、十进制、十六进制。 在JS中八进制前面加0，十六进制前面加 0x ①数字型范围 JS中数值的最大值：Number.MAX_VALUE JS中数值的最大值：Number.MIN_VALUE ②数字型的三个特殊值 Infinity ，代表无穷大，大于任何数值 -Infinity ，代表无穷小，小于任何数值 Nan ，Not a Number，代表一个非数值 ③isNaN这个方法用来判断非数字，并且返回一个值，如果是数字返回的是false，如果不是数字返回的是true 2.4.3、字符串型String字符串型可以是引号中的任意文本，其语法为 “双引号” 和 “单引号’’ 因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。 ①字符串引号嵌套JS可以用 单引号嵌套双引号，或者用 双引号嵌套单引号（外双内单，外单内双） ②字符串转义符类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。 转义符都是 \\ 开头的，常用的转义符及其说明如下： 转义符 解释说明 \\n 换行符，n是newline \\ \\ 斜杠\\ \\ ’ ’ 单引号 \\ ‘’ ‘’ 双引号 \\ t tab 缩进 \\ b 空格，b是blank的意思 ③字符串长度字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。 ④字符串的拼接 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 注意：字符串 + 任何类型 =拼接之后的新字符串 + 号总结口诀：🌏数值相加，字符相连🌏 ⑤字符串拼接加强 我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值 变量是不能添加引号的，因为加引号的变量会变成字符串 如果变量两侧都有字符串拼接，口诀==🌏“引引加加 ”，删掉数字🌏==变量写加中间 布尔型Boolean 布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。 布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。 undefined未定义 一个声明后没有被赋值的变量会有一个默认值 undefined ( 如果进行相连或者相加时，注意结果） 1.undefined 和 字符串 相加，会拼接字符串 2.undefined 和 数字相加，最后结果是NaN 空值null 一个声明变量给 null 值，里面存的值为空 typeof typeof 可用来获取检测变量的数据类型 不同类型的返回值 类型 例 结果 string typeof “小白” “string” number typeof 18 “number” boolean typeof true “boolean” undefined typeof undefined “undefined” null typeof null “object” 字面量字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。 数字字面量：8，9，10 字符串字面量：‘大前端’，‘后端’ 布尔字面量：true、false 通过控制台的颜色判断属于哪种数据类型 黑色 字符串 蓝色 数值 灰色 undefined 和 null 数据类型转换使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另外一种数据类型。 我们通常会实现3种方式的转换： 转换为字符串类型 转换为数字型 转换为布尔型 ①转换为字符串型 方式 说明 案例 toString() 转成字符串 var num = 1; alert(num.toString()); String()强制转换 转成字符串 var num = 1; alert(String(num)); 加号拼接字符串 和字符串拼接的结果都是字符串 var num =1; alert(num+“我是字符串”); toString() 和 String() 使用方式不一样 三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一方式也称为隐士转换 ②转换为数字型 方式 说明 案例 parselnt(string)函数 将string类型转成整数数值型 parselnt(‘78’) parseFloat(string)函数 将string类型转成浮点数数值型 parseFloat(‘78.21’) Number()强制转换函数 将string类型转换为数值型 Number(‘12’) js 隐式转换(- * /) 利用算术运算隐式转换为数值型 ‘12’-0 1.注意 parseInt 和 parseFloat ，这两个是重点 2.隐式转换是我们在进行算数运算的时候，JS自动转换了数据类型 ③转换为布尔型 方法 说明 案例 Boolean()函数 其他类型转成布尔值 Boolean(‘true’); 代表空，否定的值会被转换为false，如 ’ ’ , 0, NaN , null , undefined 其余的值都会被被转换为true 运算符运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号 JavaScript 中常用的运算符有： 算数运算符 递增和递减运算符 比较运算符 逻辑运算符 赋值运算符 算术运算符概念：算术运算使用的符号，用于执行两个变量或值的算术运算。 运算符 描述 实例 + 加 10 + 20 =30 - 减 10 - 20 =-10 * 乘 10 * 20 =200 / 除 10 / 20 =0.5 % 取余数（取模） 返回出发的余数 9 % 2 =1 浮点数的精度问题浮点数值的最高精度是17位小数，但在进行算数计算时其精确度远远不如整数 所以不要直接判断两个浮点数是否相等 递增和递减运算符递增（++） 递减（- -） 放在变量前面时，我们称为前置递增(递减)运算符 放在变量后面时，我们称为后置递增(递减)运算符 注意：递增和递减运算符必须和变量配合使用。 ①前置递增运算符++num num = num + 1 使用口诀:先自加，后返回值 先自加 10+1=11，返回11，此时num=11 ②后置递增运算符num ++ num = num +1 使用口诀:先返回原值，后自加 ③小结 前置递增和后置递增运算符可以简化代码的编写，让变量的值 + 1 比以前写法更简单 单独使用时，运行结果相同，与其他代码联用时，执行结果会不同 开发时，大多使用后置递增/减，并且代码独占一行 比较(关系)运算符比较运算符是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值(true / false)作为比较运算的结果。 运算符名称 说明 案例 结果 &lt; 小于号 1 &lt; 2 true &gt; 大于号 1 &gt; 2 false &gt;= 大于等于号(大于或者等于) 2 &gt;= 2 true &lt;= 小于等于号(小于或者等于) 3 &lt;= 2 false == 判等号(会转型) 37 == 37 true != 不等号 37 != 37 false === !== 全等 要求值和数据类型都一致 37 === ‘37’ false ①===== 小结 符号 作用 用法 = 赋值 把右边给左边 == 判断 判断两边值是否相等(注意此时有隐士转换) === 全等 判断两边的值和数据类型是否完全相同 逻辑运算符逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值 逻辑运算符 说明 案例 &amp;&amp; “逻辑与”，简称”与” and true &amp;&amp; false || “逻辑或”，简称”或” or true || false ！ “逻辑非”，简称”非” not ！true 逻辑与：两边都是 true才返回 true，否则返回 false 逻辑或：两边都为 false 才返回 false，否则都为true 逻辑非：逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false 短路运算(逻辑中断)短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值 ①逻辑与 语法：表达式1 &amp;&amp; 表达式2 如果第一个表达式的值为真，则返回表达式2 如果第一个表达式的值为假，则返回表达式1 ②逻辑或 语法：表达式1 || 表达式2 如果第一个表达式的值为真，则返回表达式1 如果第一个表达式的值为假，则返回表达式2 赋值运算符概念：用来把数据赋值给变量的运算符。 赋值运算符 说明 案例 = 直接赋值 var usrName = ‘我是值’ += ，-= 加，减一个数后再赋值 var age = 10； age+=5；//15 *=，/=，%= 成，除，取模后再赋值 var age = 2; age*=5; //10 运算符优先级 优先级 运算符 顺序 1 小括号 () 2 一元运算符 ++ – ！ 3 算数运算符 先 * / 后 + - 4 关系运算符 &gt;, &gt;= , &lt; , &lt;=, 5 相等运算符 ，！=，=，！== 6 逻辑运算符 先 &amp;&amp; 后 ||（先与后或） 7 赋值运算符 = 8 逗号运算符 ， 1.一元运算符里面的逻辑非优先级很高 2.逻辑与 比 逻辑或 优先级高 3.练习题 流程控制流程控制主要有三种结构，分别是顺序结构、分支结构和循环结构，这三种结构代表三种代码执行的顺序 分支结构JS 语言提供了两种分支结构语句：JS 语句 switch语句 ①if语句案例：进入网吧 弹出一个输入框，要求用户输入年龄，如果年龄大于等于 18 岁，允许进网吧 ②if else 语句案例：判断闰年 接收用户输入的年份，如果是闰年就弹出闰年，否则弹出是平年 算法：能被4整除且不能整除100的为闰年（如2004年就是闰年，1901年不是闰年）或者能够被 400 整除的就是闰年 ③if else if 语句案例:接收用户输入的分数，根据分数输出对应的等级字母 A、B、C、D、E 其中： 90分(含)以上 ，输出：A 80分(含)~ 90 分(不含)，输出：B 70分(含)~ 80 分(不含)，输出：C 60分(含)~ 70 分(不含)，输出：D 60分(不含) 以下，输出： E 三元表达式 语法结构 : 表达式1 ? 表达式2 : 表达式3 执行思路 如果表达式1为true，则返回表达式2的值,如果表达式1为false，则返回表达式3的值 案例：数字补0 用户输入数字，如果数字小于10，则在前面补0，比如01，09， 如果数字大于10，则不需要补，比如20 switch switch ：开关 转换 ， case ：小例子 选项 关键字 switch 后面括号内可以是表达式或值， 通常是一个变量 关键字 case , 后跟一个选项的表达式或值，后面跟一个冒号 switch 表达式的值会与结构中的 case 的值做比较 如果存在匹配全等(===) ，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码执行结束 如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码 执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句 断点调试 浏览器中按 F12–&gt; sources –&gt;找到需要调试的文件–&gt;在程序的某一行设置断点(在行数点一下) 刷新浏览器 Watch: 监视，通过watch可以监视 变量的值的变化，非常的常用 F11: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化 循环循环在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称之为循环语句 1.输入10句”娘子晚安哈！” 2.求1-100之间所有整数的累加和 3.求1-100之间所有数的平均值 4.求1-100之间所有偶数和奇数的和 5.求1-100之间所有能被3整除的数字的和 6.要求用户输入班级人数，之后依次输入每个学生的成绩，最后打印出该班级总的成绩以及平均成绩。 7.一行打印5个星星 我们采取追加字符串的方式，这样可以打印到控制台上 双重for循环循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for 循环，这样的 for 循环语句我们称之为双重for循环。 内层循环可以看做外层循环的语句 内层循环执行的顺序也要遵循 for 循环的执行顺序 外层循环执行一次，内层循环要执行全部次数 ①打印五行五列星星核心： 内层循环负责一行打印五个星星 外层循环负责打印五行 ②打印n行n列的星星要求用户输入行数和列数，之后在控制台打印出用户输入行数和列数的星星 ③打印倒三角形 一共有10行，但是每行的星星个数不一样，因此需要用到双重 for 循环 外层的 for 控制行数 i ，循环10次可以打印10行 内层的 for 控制每行的星星个数 j 核心算法： 每一行星星的个数： j = i ; j &lt;= 10; j++ 每行打印完毕后，都需要重新换一行 while循环执行思路： 先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码 执行循环体代码 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束 注意： 使用 while 循环时一定要注意，它必须要有退出条件，否则会称为死循环 while 循环和 for 循环的不同之处在于 while 循环可以做较为复杂的条件判断，比如判断用户名和密码 ①打印人的一生从1岁到99岁 ②计算 1 ~ 100 之间所有整数的和do while循环执行思路： 先执行一次循环体代码 再执行表达式，如果结果为true，则继续执行循环体代码，如果为false，则退出循环，继续执行后面的代码 先执行再判断循环体，所以dowhile循环语句至少会执行一次循环体代码 需求：弹出一个提示框， 你爱我吗？ 如果输入我爱你，就提示结束，否则，一直询问 continue 关键字continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。 例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子 break关键字break 关键字用于立即跳出整个循环 例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的也不吃了 数组数组(Array)是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。 创建数组JavaScript 中创建数组有两种方式： 利用 new 创建数组 利用数组字面量创建数组 ①利用 new 创建数组 这种方式暂且了解，等学完对象再看 注意 Array()，A要大写 ②利用数组字面量创建数组 数组的字面量是方括号 [] 声明数组并赋值称为数组的初始化 这种字面量方式也是我们以后最多使用的方式 数组的索引（下标）索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始） 遍历数组我们可以通过 for 循环索引遍历数组中的每一项 数组的长度使用“数组名.length”可以访问数组元素的数量（数组长度） 注意： 此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆 当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化 案例1.请将 [“关羽”,“张飞”,“马超”,“赵云”,“黄忠”,“刘备”,“姜维”]; 数组里的元素依次打印到控制台 2.求数组 [2,6,1,7, 4] 里面所有元素的和以及平均值 ①声明一个求和变量 sum。 ①遍历这个数组，把里面每个数组元素加到 sum 里面。 ①用求和变量 sum 除以数组的长度就可以得到数组的平均值。 3.求数组[2,6,1,77,52,25,7]中的最大值 ①声明一个保存最大元素的变量 max。 ②默认最大值可以取数组中的第一个元素。 ③遍历这个数组，把里面每个数组元素和 max 相比较。 ④如果这个数组元素大于max 就把这个数组元素存到 max 里面，否则继续下一轮比较。 ⑤最后输出这个 max。 4.将数组 [‘red’, ‘green’, ‘blue’, ‘pink’] 里面的元素转换为字符串 思路：就是把里面的元素相加就好了，但是注意保证是字符相加 ①需要一个新变量 str 用于存放转换完的字符串。 ②遍历原来的数组，分别把里面数据取出来，加到字符串变量 str 里面。 5.将数组 [‘red’, ‘green’, ‘blue’, ‘pink’] 转换为字符串，并且用 | 或其他符号分割 ①需要一个新变量用于存放转换完的字符串 str。 ①遍历原来的数组，分别把里面数据取出来，加到字符串里面。 ①同时在后面多加一个分隔符。 数组中新增元素①通过修改 length 长度新增数组元素 可以通过修改 length 长度来实现数组扩容的目的 length 属性是可读写的 其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是 undefined ②通过修改数组索引新增数组元素 可以通过修改数组索引的方式追加数组元素 不能直接给数组名赋值，否则会覆盖掉以前的数据 这种方式也是我们最常用的一种方式 数组中新增元素1.新建一个数组，里面存放10个整数（ 1~10）， 要求使用循环追加的方式输出： [1,2,3,4,5,6,7,8,9,10] ①使用循环来追加数组。 ②声明一个空数组 arr。 ③循环中的计数器 i 可以作为数组元素存入。 由于数组的索引号是从0开始的， 因此计数器从 0 开始更合适，存入的数组元素要+1。 2.将数组 [2, 0, 6, 1, 77, 0, 52, 0, 25, 7] 中大于等于 10 的元素选出来，放入新数组 ①声明一个新的数组用于存放新数据。 ②遍历原来的数组，找出大于等于 10 的元素。 ③依次追加给新数组 newArr。 实现代码1： 实现代码2： 删除指定数组元素将数组[2, 0, 6, 1, 77, 0, 52, 0, 25, 7]中的 0 去掉后，形成一个不包含 0 的新数组。 翻转数组将数组 [‘red’, ‘green’, ‘blue’, ‘pink’, ‘purple’] 的内容反过来存放 数组排序冒泡排序 将数组 [5, 4, 3, 2, 1]中的元素按照从小到大的顺序排序，输出： 1，2，3，4，5","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript基础之对象与内置对象(三)","slug":"JavaScript基础之对象与内置对象(三)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T08:19:57.577Z","comments":true,"path":"2022/04/24/JavaScript基础之对象与内置对象(三)/","link":"","permalink":"http://example.com/2022/04/24/JavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1(%E4%B8%89)/","excerpt":"","text":"目录总览对象在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。 对象是由属性和方法组成的： 属性：事物的**特征，**在对象中用**属性**来表示（常用名词） 方法：事物的**行为，**在对象中用**方法**来表示（常用动词） 创建对象在 JavaScript 中，现阶段我们可以采用三种方式创建对象（object）： 利用字面量创建对象 利用 new Object创建对象 利用构造函数创建对象 ①利用字面量创建对象对象字面量：就是花括号 &#123; &#125; 里面包含了表达这个具体事物（对象）的属性和方法 &#123; &#125; 里面采取键值对的形式表示 键：相当于属性名 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等） 12345678910var star = &#123; name : &#x27;pink&#x27;, age : 18, sex : &#x27;男&#x27;, sayHi : function()&#123; alert(&#x27;大家好啊~&#x27;); &#125;&#125;;// 多个属性或者方法中间用逗号隔开// 方法冒号后面跟的是一个匿名函数 对象的调用 对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ” 对象里面属性的另一种调用方式 : 对象[‘属性名’]，注意方括号里面的属性必须加引号，我们后面会用 对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号 123console.log(star.name) // 调用名字属性console.log(star[&#x27;name&#x27;]) // 调用名字属性star.sayHi(); // 调用 sayHi 方法,注意，一定不要忘记带后面的括号 变量、属性、函数、方法总结 变量：单独声明赋值，单独存在 属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征 函数：单独存在的，通过==“函数名()”==的方式就可以调用 方法：对象里面的函数称为方法，方法不需要声明，使用==“对象.方法名()”==的方式就可以调用，方法用来描述该对象的行为和功能。 ②利用 new Object 创建对象跟之前的 new Array() 原理一致：var 对象名 = new Object(); 使用的格式：对象.属性 = 值 12345678910111213var obj = new Object(); //创建了一个空的对象obj.name = &#x27;张三丰&#x27;;obj.age = 18;obj.sex = &#x27;男&#x27;;obj.sayHi = function() &#123; console.log(&#x27;hi~&#x27;);&#125;//1.我们是利用等号赋值的方法添加对象//2.每个属性和方法之间用分号结束console.log(obj.uname);console.log(obj[&#x27;sex&#x27;]);obj.sayHi(); ③利用构造函数创建对象构造函数 ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 在 js 中，使用构造函数要时要注意以下两点： 构造函数用于创建某一类对象，其首字母要大写 构造函数要和 new 一起使用才有意义 1234567891011121314151617181920212223242526272829//构造函数的语法格式function 构造函数名() &#123; this.属性 = 值; this.方法 = function() &#123;&#125;&#125;new 构造函数名();//1. 构造函数名字首字母要大写//2. 构造函数不需要return就可以返回结果//3. 调用构造函数必须使用 new//4. 我们只要new Star() 调用函数就创建了一个对象//5. 我们的属性和方法前面必须加thisfunction Star(uname,age,sex) &#123; this.name = uname; this.age = age; this.sex = sex; this.sing = function(sang)&#123; console.log(sang); &#125;&#125;var ldh = new Star(&#x27;刘德华&#x27;,18,&#x27;男&#x27;);console.log(typeof ldh) // object对象，调用函数返回的是对象console.log(ldh.name);console.log(ldh[&#x27;sex&#x27;]);ldh.sing(&#x27;冰雨&#x27;);//把冰雨传给了sangvar zxy = new Star(&#x27;张学友&#x27;,19,&#x27;男&#x27;); 构造函数名字首字母要大写 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 构造函数中不需要 return 返回结果。 当我们创建对象的时候，必须用 new 来调用构造函数。 构造函数和对象 构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class） 创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化 new关键字new 在执行时会做四件事: 在内存中创建一个新的空对象。 让 this 指向这个新的对象。 执行构造函数里面的代码，给这个新对象添加属性和方法 返回这个新对象（所以构造函数里面不需要return） 遍历对象的属性 for...in 语句用于对数组或者对象的属性进行循环操作 语法如下 123for(变量 in 对象名字)&#123; // 在此执行代码&#125; 语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。 12345678910111213141516171819202122for(var k in obj) &#123; console.log(k); //这里的 k 是属性名 console.log(obj[k]);//这里的 obj[k] 是属性值&#125;1234var obj = &#123; name: &#x27;秦sir&#x27;, age: 18, sex: &#x27;男&#x27;, fn:function() &#123;&#125;;&#125;;console.log(obj.name);console.log(obj.age);console.log(obj.sex);//for in 遍历我们的对象//for (变量 in 对象)&#123;&#125;//我们使用for in 里面的变量 我们喜欢写k 或者keyfor(var k in obj)&#123; console.log(k); // k 变量 输出得到的是属性名 console.log(obj[k]); // obj[k] 得到的是属性值&#125; 内置对象 JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象 内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能 JavaScript 提供了多个内置对象：Math、 Date 、Array、String等 查文档学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询 MDN: https://developer.mozilla.org/zh-CN/ 如何学习对象中的方法 查阅该方法的功能 查看里面参数的意义和类型 查看返回值的意义和类型 通过 demo 进行测试 Math对象Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。 12345678// Math数学对象，不是一个构造函数，所以我们不需要new 来调用，而是直接使用里面的属性和方法即可Math.PI // 圆周率Math.floor() // 向下取整Math.ceil() // 向上取整Math.round() // 四舍五入版 就近取整 注意 -3.5 结果是 -3 Math.abs() // 绝对值Math.max()/Math.min() // 求最大和最小值 注意：上面的方法必须带括号 12console.log(Math.PI); console.log(Math.max(1,99,3)); // 99 练习：封装自己的数学对象 利用对象封装自己的数学对象，里面有PI 最大值 和最小值 123456789101112131415161718192021222324var myMath = &#123; PI: 3.141592653, max: function() &#123; var max = arguments[0]; for (var i = 1; i &lt; arguments.length; i++) &#123; if (arguments[i] &gt; max) &#123; max = arguments[i]; &#125; &#125; return max; &#125;, min: function() &#123; var min = arguments[0]; for (var i = 1; i &lt; arguments.length; i++) &#123; if (arguments[i] &lt; min) &#123; min = arguments[i]; &#125; &#125; return min; &#125;&#125;console.log(myMath.PI);console.log(myMath.max(1, 5, 9));console.log(myMath.min(1, 5, 9)); Math绝对值和三个取整方法 Math.abs() 取绝对值 三个取整方法： Math.floor() : 向下取整 Math.ceil() : 向上取整 Matg.round() : 四舍五入，其他数字都是四舍五入，但是5特殊，它往大了取 123456789101112131415161718//1.绝对值方法console.log(Math.abs(1)); // 1console.log(Math.abs(-1)); // 1console.log(Math.abs(&#x27;-1&#x27;)); // 1 隐式转换，会把字符串 -1 转换为数字型//2.三个取整方法console.log(Math.floor(1.1)); // 1 向下取整，向最小的取值 floor-地板console.log(Math.floor(1.9)); //1console.log(Math.ceil(1.1)); //2 向上取整，向最大的取值 ceil-天花板console.log(Math.ceil(1.9)); //2 //四舍五入 其他数字都是四舍五入，但是5特殊，它往大了取console.log(Math.round(1.1)); //1 四舍五入console.log(Math.round(1.5)); //2console.log(Math.round(1.9)); //2console.log(Math.round(-1.1)); // -1console.log(Math.round(-1.5)); // -1 随机数方法random() random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 &lt;= x &lt; 1 得到一个两数之间的随机整数，包括两个数在内 12345// 得到两个数之间的随机整数，并且包含这两个整数function getRandom(min,max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125;console.log(getRandom(1,10)); 1.随机点名 12var arr = [&#x27;张三&#x27;, &#x27;李四&#x27;,&#x27;王五&#x27;,&#x27;秦六&#x27;]；console.log(arr[getRandom(0,arr.length - 1)]); 2.猜数字游戏 123456789101112131415function getRandom(min,max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125;var random = getRandom(1,10);while(true) &#123; //死循环 ，需要退出循环条件 var num = prompt(&#x27;请输入1~10之间的一个整数:&#x27;); if(num &gt; random) &#123; alert(&#x27;你猜大了&#x27;); &#125;else if (num &lt; random) &#123; alert(&#x27;你猜小了&#x27;); &#125;else &#123; alert(&#x27;你猜中了&#x27;); break; //退出整个循环 &#125;&#125; Data()日期对象 Date 对象和 Math 对象不一样，他是一个构造函数，所以我们需要实例化后才能使用 Date 实例用来处理日期和时间 Date()方法的使用获取当前时间必须实例化12var now = new Date();console.log(now); Date()构造函数的参数如果括号里面有时间，就返回参数里面的时间。例如日期格式字符串为 ‘2019-5-1’，可以写成new Date(&#39;2019-5-1&#39;) 或者 new Date(&#39;2019/5/1&#39;) 如果Date()不写参数，就返回当前时间 如果Date()里面写参数，就返回括号里面输入的时间 123456789101112// 1.如果没有参数，返回当前系统的当前时间var now = new Date();console.log(now);// 2.参数常用的写法 数字型 2019,10,1 字符串型 &#x27;2019-10-1 8:8:8&#x27; 时分秒// 如果Date()里面写参数，就返回括号里面输入的时间 var data = new Date(2019,10,1);console.log(data); // 返回的是11月不是10月var data2 = new Date(&#x27;2019-10-1 8:8:8&#x27;);console.log(data2); 日期格式化我们想要 2019-8-8 8:8:8 格式的日期，要怎么办？ 需要获取日期指定的部分，所以我们要手动的得到这种格式 方法名 说明 代码 getFullYear() 获取当年 dObj.getFullYear() getMonth() 获取当月(0-11) dObj.getMonth() getDate 获取当天日期 dObj.getDate() getDay() 获取星期几(周日0到周六6) dObj.getDay() getHours() 获取当前小时 dObj.getHours() getMinutes() 获取当前小时 dObj.getMinutes() getSeconds() 获取当前秒钟 dObj.gerSeconds() 123456789101112131415161718192021222324252627var date = new Date();console.log(date.getFullYear()); // 返回当前日期的年 2019console.log(date.getMonth() + 1); //返回的月份小一个月 记得月份 +1console.log(date.getDate); //返回的是几号console.log(date.getDay()); //周一返回1 周6返回六 周日返回0// 写一个 2019年 5月 1日 星期三var date = new Date(); var year = date.getFullYear();var month = date.getMonth() + 1;var dates = date.getDate();console.log(&#x27;今天是&#x27; + year +&#x27;年&#x27; + month + &#x27;月&#x27; + dates +&#x27;日&#x27; );// 封装一个函数返回当前的时分秒 格式 08:08:08function getTimer() &#123; var time = new Date(); var h = time.getHours(); h = h &lt; 10 ? &#x27;0&#x27; + h : h; var m = time.getMinutes(); m = m &lt; 10 ? &#x27;0&#x27; + m : m; var s = time.getSeconds(); s = s &lt; 10 ? &#x27;0&#x27; + s : s; return h + &#x27;:&#x27; + m + &#x27;:&#x27; + s;&#125;console.log(getTimer()); 获取日期的总的毫秒形式 date.valueOf() ：得到现在时间距离1970.1.1总的毫秒数 date.getTime() ：得到现在时间距离1970.1.1总的毫秒数 123456789101112131415// 获取Date总的毫秒数 不是当前时间的毫秒数 而是距离1970年1月1号过了多少毫秒数// 实例化Date对象var date = new Date();// 1 .通过 valueOf() getTime() 用于获取对象的原始值console.log(date.valueOf()); //得到现在时间距离1970.1.1总的毫秒数console.log(date.getTime());// 2.简单的写法var date1 = +new Date(); // +new Date()返回的就是总的毫秒数，console.log(date1);// 3. HTML5中提供的方法 获得总的毫秒数 有兼容性问题console.log(Date.now()); 倒计时效果 123456789101112131415161718function countDown(time) &#123; var nowTime = +new Date(); //没有参数，返回的是当前时间总的毫秒数 var inputTime = +new Date(time); // 有参数，返回的是用户输入时间的总毫秒数 var times = (inputTime - nowTime) / 1000; //times就是剩余时间的总的秒数 var d = parseInt(times / 60 / 60 / 24); //天数 d &lt; 10 ? &#x27;0&#x27; + d : d; var h = parseInt(times / 60 / 60 % 24); //小时 h &lt; 10 ? &#x27;0&#x27; + h : h; var m = parseInt(times / 60 % 60); //分 m &lt; 10 ? &#x27;0&#x27; + m : m; var s = parseInt(times % 60); //秒 s &lt; 10 ? &#x27;0&#x27; + s : s; return d + &#x27;天&#x27; + h + &#x27;时&#x27; + m + &#x27;分&#x27; + s + &#x27;秒&#x27;;&#125;console.log(countDown(&#x27;2020-11-09 18:29:00&#x27;));var date = new Date;console.log(date); //现在时间 数组对象数组对象的创建创建数组对象的两种方式 字面量方式 new Array() 检测是否为数组 instanceof 运算符，可以判断一个对象是否属于某种类型 Array.isArray() 用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法 123456var arr = [1, 23];var obj = &#123;&#125;;console.log(arr instanceof Array); // trueconsole.log(obj instanceof Array); // falseconsole.log(Array.isArray(arr)); // trueconsole.log(Array.isArray(obj)); // false 添加删除数组元素 方法名 说明 返回值 push(参数1…) 末尾添加一个或多个元素，注意修改原数组 并返回新的长度 pop() 删除数组最后一个元素 返回它删除的元素的值 unshift(参数1…) 向数组的开头添加一个或更多元素，注意修改原数组 并返回新的长度 shift() 删除数组的第一个元素，数组长度减1，无参数，修改原数组 并返回第一个元素 1234567891011121314151617// 1.push() 在我们数组的末尾，添加一个或者多个数组元素 push 推var arr = [1, 2, 3];arr.push(4, &#x27;秦晓&#x27;);console.log(arr);console.log(arr.push(4, &#x27;秦晓&#x27;));console.log(arr);// push 完毕之后，返回结果是新数组的长度// 2. unshift 在我们数组的开头 添加一个或者多个数组元素arr.unshift(&#x27;red&#x27;);console.log(arr);// pop() 它可以删除数组的最后一个元素，一次只能删除一个元素arr.pop(); //不加参数// shift() 它剋删除数组的第一个元素,一次只能删除一个元素arr.shift(); //不加参数 筛选数组有一个包含工资的数组[1500,1200,2000,2100,1800],要求把数组中工资超过2000的删除，剩余的放到新数组里面 123456789var arr = [1500, 1200, 2000, 2100, 1800];var newArr = [];for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; 2000) &#123; newArr.push(arr[i]); &#125;&#125;console.log(newArr); 数组排序 方法名 说明 是否修改原数组 reverse() 颠倒数组中元素的顺序，无参数 该方法会改变原来的数组，返回新数组 sort() 对数组的元素进行排序 该方法会改变原来的数组，返回新数组 1234567891011121314151617// 1.翻转数组var arr = [&#x27;pink&#x27;,&#x27;red&#x27;,&#x27;blue&#x27;];arr.reverse();console.log(arr);// 2.数组排序(冒泡排序)var arr1 = [3,4,7,1];arr1.sort();console.log(arr1);// 对于双位数var arr = [1,64,9,61];arr.sort(function(a,b) &#123; return b - a; //降序的排列 return a - b; //升序 &#125; ) 数组索引 方法名 说明 返回值 indexOf() 数组中查找给定元素的第一个索引 如果存在返回索引号，如果不存在，则返回-1 lastIndexOf() 在数组的最后一个索引，从后向前索引 如果存在返回索引号，如果不存在，则返回-1 1234567//返回数组元素索引号方法 indexOf(数组元素) 作用就是返回该数组元素的索引号//它只发返回第一个满足条件的索引号//如果找不到元素，则返回-1var arr = [&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;.&#x27;pink&#x27;,&#x27;blue&#x27;];console.log(arr.indexOf(&#x27;blue&#x27;)); // 2console.log(arr.lastIndexOf(&#x27;blue&#x27;)); // 4 数组去重 分析：把旧数组里面不重复的元素选取出来放到新数组中，重复的元素只保留一个，放到新数组中去重。 核心算法：我们遍历旧数组，然后拿着旧数组元素去查询新数组，如果该元素在新数组里面没有出现过，我们就添加，否则不添加。 我们怎么知道该元素没有存在？ 利用 新数组.indexOf(数组元素) 如果返回是 -1 就说明 新数组里面没有改元素 123456789101112// 封装一个去重的函数 unique 独一无二的function unique(arr) &#123; var newArr = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (newArr.indexOf(arr[i]) === -1) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var demo = unique([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;a&#x27;, &#x27;x&#x27;, &#x27;a&#x27;, &#x27;x&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]);console.log(demo); 数组转化为字符串 方法名 说明 返回值 toString() 把数组转换成字符串，逗号分隔每一项 返回一个字符串 join(‘分隔符’) 方法用于把数组中的所有元素转换为一个字符串 返回一个字符串 12345678// 1.toString() 将我们的数组转换为字符串var arr = [1, 2, 3];console.log(arr.toString()); // 1,2,3// 2.join(&#x27;分隔符&#x27;)var arr1 = [&#x27;green&#x27;, &#x27;blue&#x27;, &#x27;red&#x27;];console.log(arr1.join()); // 不写默认用逗号分割console.log(arr1.join(&#x27;-&#x27;)); // green-blue-redconsole.log(arr1.join(&#x27;&amp;&#x27;)); // green&amp;blue&amp;red 其他方法 方法名 说明 返回值 concat() 连接两个或多个数组 不影响原数组 返回一个新的数组 slice() 数组截取slice(begin,end) 返回被截取项目的新数组 splice() 数组删除splice(第几个开始要删除的个数) 返回被删除项目的新数组，这个会影响原数组 字符串对象基本包装类型为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。 我们看看下面代码有什么问题吗？ 12var str = &#x27;andy&#x27;;console.log(str.length); 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ： 123456// 1.生成临时变量,把简单类型包装为复杂数据类型var temp = new String(&#x27;andy&#x27;);// 2.赋值给我们声明的字符变量str = temp;// 3.销毁临时变量temp = null; 字符串的不可变指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 1234567891011var str = &#x27;abc&#x27;;str = &#x27;hello&#x27;;// 当重新给 str 赋值的时候，常量&#x27;abc&#x27;不会被修改，依然在内存中// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题var str = &#x27;&#x27;;for(var i = 0; i &lt; 10000; i++)&#123; str += i;&#125;console.log(str);// 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间 根据字符返回位置字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 方法名 说明 indexOf(‘要查找的字符’，开始的位置) 返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是index索引号 lastIndexOf() 从后往前找，只找第一个匹配的 1234// 字符串对象 根据字符返回位置 str.indexOf(&#x27;要查找的字符&#x27;, [起始的位置]) var str = &#x27;改革春风吹满地，春天来了&#x27;; console.log(str.indexOf(&#x27;春&#x27;)); //默认从0开始查找 ，结果为2 console.log(str.indexOf(&#x27;春&#x27;, 3)); // 从索引号是 3的位置开始往后查找，结果是8 返回字符位置查找字符串 “abcoefoxyozzopp” 中所有o出现的位置以及次数 核心算法：先查找第一个o出现的位置 然后 只要 indexOf返回的结果不是 -1 就继续往后查找 因为 indexOf 只能查找到第一个，所以后面的查找，一定是当前索引加1，从而继续查找 12345678910var str = &quot;oabcoefoxyozzopp&quot;;var index = str.indexOf(&#x27;o&#x27;);var num = 0;// console.log(index);while (index !== -1) &#123; console.log(index); num++; index = str.indexOf(&#x27;o&#x27;, index + 1);&#125;console.log(&#x27;o出现的次数是: &#x27; + num); 根据位置返回字符🔥(重点) 方法名 说明 使用 charAt(index) 返回指定位置的字符(index字符串的索引号) str.charAt(0) charCodeAt(index) 获取指定位置处字符的ASCII码(index索引号) str.charCodeAt(0) str[index] 获取指定位置处字符 HTML,IE8+支持和charAt()等效 返回字符位置判断一个字符串 “abcoefoxyozzopp” 中出现次数最多的字符，并统计其次数 核心算法：利用 charAt() 遍历这个字符串 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1 遍历对象，得到最大值和该字符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; // 有一个对象 来判断是否有该属性 对象[&#x27;属性名&#x27;] var o = &#123; age: 18 &#125; if (o[&#x27;sex&#x27;]) &#123; console.log(&#x27;里面有该属性&#x27;); &#125; else &#123; console.log(&#x27;没有该属性&#x27;); &#125; // 判断一个字符串 &#x27;abcoefoxyozzopp&#x27; 中出现次数最多的字符，并统计其次数。 // o.a = 1 // o.b = 1 // o.c = 1 // o.o = 4 // 核心算法：利用 charAt() 遍历这个字符串 // 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1 // 遍历对象，得到最大值和该字符 var str = &#x27;abcoefoxyozzopp&#x27;; var o = &#123;&#125;; for (var i = 0; i &lt; str.length; i++) &#123; var chars = str.charAt(i); // chars 是 字符串的每一个字符 if (o[chars]) &#123; // o[chars] 得到的是属性值 o[chars]++; &#125; else &#123; o[chars] = 1; &#125; &#125; console.log(o); // 2. 遍历对象 var max = 0; var ch = &#x27;&#x27;; for (var k in o) &#123; // k 得到是 属性名 // o[k] 得到的是属性值 if (o[k] &gt; max) &#123; max = o[k]; ch = k; &#125; &#125; console.log(max); console.log(&#x27;最多的字符是&#x27; + ch);&lt;/script&gt; 字符串操作方法 方法名 说明 concat(str1,str2,str3…) concat() 方法用于连接两个或对各字符串。拼接字符串 substr(start,length) 从 start 位置开始(索引号), length 取的个数 slice(start,end) 从 start 位置开始，截取到 end 位置 ，end 取不到 (两个都是索引号) substring(start,end) 从 start 位置开始，截取到 end 位置 ，end 取不到 (基本和 slice 相同，但是不接受负) 123456789&lt;script&gt; // 1. concat(&#x27;字符串1&#x27;,&#x27;字符串2&#x27;....) var str = &#x27;andy&#x27;; console.log(str.concat(&#x27;red&#x27;)); // 2. substr(&#x27;截取的起始位置&#x27;, &#x27;截取几个字符&#x27;); var str1 = &#x27;改革春风吹满地&#x27;; console.log(str1.substr(2, 2)); // 第一个2 是索引号的2 第二个2 是取几个字符&lt;/script&gt; replace()方法replace() 方法用于在字符串中用一些字符替换另一些字符 其使用格式：replace(被替换的字符,要替换为的字符串) 1234567891011&lt;script&gt; // 1. 替换字符 replace(&#x27;被替换的字符&#x27;, &#x27;替换为的字符&#x27;) 它只会替换第一个字符 var str = &#x27;andyandy&#x27;; console.log(str.replace(&#x27;a&#x27;, &#x27;b&#x27;)); // 有一个字符串 &#x27;abcoefoxyozzopp&#x27; 要求把里面所有的 o 替换为 * var str1 = &#x27;abcoefoxyozzopp&#x27;; while (str1.indexOf(&#x27;o&#x27;) !== -1) &#123; str1 = str1.replace(&#x27;o&#x27;, &#x27;*&#x27;); &#125; console.log(str1);&lt;/script&gt; split()方法split() 方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。 例如下面代码： 1234567891011var str = &#x27;a,b,c,d&#x27;;console.log(str.split(&#x27;,&#x27;));// 返回的是一个数组 [a, b, c, d]&lt;script&gt;// 2. 字符转换为数组 split(&#x27;分隔符&#x27;) 前面我们学过 join 把数组转换为字符串 var str2 = &#x27;red, pink, blue&#x27;; console.log(str2.split(&#x27;,&#x27;)); var str3 = &#x27;red&amp;pink&amp;blue&#x27;; console.log(str3.split(&#x27;&amp;&#x27;));&lt;/script&gt; 大小写转换 toUpperCase() 转换大写 toLowerCase() 转换小写 简单类型于复杂类型简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。 值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型 string ，number，boolean，undefined，null 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型 通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等 堆和栈堆栈空间分配区别： 栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈； 简单数据类型存放到栈里面 堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。 复杂数据类型存放到堆里面 注意：JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言。 简单类型的内存分配 值类型（简单数据类型）： string ，number，boolean，undefined，null 值类型变量的数据直接存放在变量（栈空间）中 引用类型（复杂数据类型）：通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中 12345678&lt;script&gt; // 简单数据类型 null 返回的是一个空的对象 object var timer = null; console.log(typeof timer); // 如果有个变量我们以后打算存储为对象，暂时没想好放啥， 这个时候就给 null // 1. 简单数据类型 是存放在栈里面 里面直接开辟一个空间存放的是值 // 2. 复杂数据类型 首先在栈里面存放地址 十六进制表示 然后这个地址指向堆里面的数据&lt;/script&gt; 简单类型传参函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。 12345678910&lt;script&gt; // 简单数据类型传参 function fn(a) &#123; a++; console.log(a); &#125; var x = 10; fn(x); console.log(x);&lt;/script&gt; 复杂类型传参函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。 12345678910111213141516&lt;script&gt; // 复杂数据类型传参 function Person(name) &#123; this.name = name; &#125; function f1(x) &#123; // x = p console.log(x.name); // 2. 这个输出什么 ? 刘德华 x.name = &quot;张学友&quot;; console.log(x.name); // 3. 这个输出什么 ? 张学友 &#125; var p = new Person(&quot;刘德华&quot;); console.log(p.name); // 1. 这个输出什么 ? 刘德华 f1(p); console.log(p.name); // 4. 这个输出什么 ? 张学友&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript提高班之面向对象(六)","slug":"JavaScript提高班之面向对象(六)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T08:35:42.751Z","comments":true,"path":"2022/04/24/JavaScript提高班之面向对象(六)/","link":"","permalink":"http://example.com/2022/04/24/JavaScript%E6%8F%90%E9%AB%98%E7%8F%AD%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E5%85%AD)/","excerpt":"","text":"面向对象面向对象更贴近我们的实际生活, 可以使用面向对象描述现实世界事物. 但是事物分为具体的事物和抽象的事物 面向对象的思维特点： 抽取（抽象）对象共用的属性和行为组织(封装)成一个类(模板) 对类进行实例化, 获取类的对象 对象在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。 对象是由属性和方法组成的 属性：事物的**特征，**在对象中用**属性**来表示 方法：事物的**行为，**在对象中用**方法**来表示 类在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。 类抽象了对象的公共部分，它泛指某一大类（class） 对象特指某一个，通过类实例化一个具体的对象 创建类123class name &#123; // class body&#125; 创建实例 1var XX = new name(); 注意：类必须使用new 实例化对象 构造函数constructor() 方法是类的构造函数(默认方法)，用于传递参数,返回实例对象，通过 new 命令生成对象实例时，自动调用该方法。如果没有显示定义, 类内部会自动给我们创建一个constructor() 12345678910111213141516&lt;script&gt; // 1. 创建类 class 创建一个 明星类 class Star &#123; // constructor 构造器或者构造函数 constructor(uname, age) &#123; this.uname = uname; this.age = age; &#125; &#125; // 2. 利用类创建对象 new var ldh = new Star(&#x27;刘德华&#x27;, 18); var zxy = new Star(&#x27;张学友&#x27;, 20); console.log(ldh); console.log(zxy);&lt;/script&gt; 通过 class 关键字创建类，类名我们还是习惯性定义首字母大写 类里面有个 constructor函数，可以接收传递过来的参数，同时返回实例对象 constructor函数只要 new 生成实例时，就会自动调用这个函数，如果我们不写这个函数，类也会自动生成这个函数 最后注意语法规范 创建类➡类名后面不要加小括号 生成实例➡类名后面加小括号 构造函数不需要加 function 关键字 类中添加方法语法： 123456789101112class Person &#123; constructor(name,age) &#123; // constructor 称为构造器或者构造函数 this.name = name; this.age = age; &#125; say() &#123; console.log(this.name + &#x27;你好&#x27;); &#125;&#125; var ldh = new Person(&#x27;刘德华&#x27;, 18); ldh.say() 注意： 方法之间不能加逗号分隔，同时方法不需要添加 function 关键字。 1234567891011121314151617181920212223&lt;script&gt; // 1. 创建类 class 创建一个 明星类 class Star &#123; // 类的共有属性放到 constructor 里面 constructor(uname, age) &#123; this.uname = uname; this.age = age; &#125; sing(song) &#123; console.log(this.uname + song); &#125; &#125; // 2. 利用类创建对象 new var ldh = new Star(&#x27;刘德华&#x27;, 18); var zxy = new Star(&#x27;张学友&#x27;, 20); console.log(ldh); console.log(zxy); // (1) 我们类里面所有的函数不需要写function // (2) 多个函数方法之间不需要添加逗号分隔 ldh.sing(&#x27;冰雨&#x27;); zxy.sing(&#x27;李香兰&#x27;);&lt;/script&gt; 类的共有属性放到constructor 里面 类里面的函数都不需要写 function 关键字 类的继承现实中的继承：子承父业，比如我们都继承了父亲的姓。 程序中的继承：子类可以继承父类的一些属性和方法。 语法： 12345678// 父类class Father &#123; &#125;// 子类继承父类class Son extends Father &#123; &#125; 看一个实例： 12345678910111213141516171819202122232425262728&lt;script&gt; // 父类有加法方法 class Father &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; sum() &#123; console.log(this.x + this.y); &#125; &#125; // 子类继承父类加法方法 同时 扩展减法方法 class Son extends Father &#123; constructor(x, y) &#123; // 利用super 调用父类的构造函数 // super 必须在子类this之前调用 super(x, y); this.x = x; this.y = y; &#125; subtract() &#123; console.log(this.x - this.y); &#125; &#125; var son = new Son(5, 3); son.subtract(); son.sum();&lt;/script&gt; super关键字 super 关键字用于访问和调用对象父类上的函数，可以调用父类的构造函数，也可以调用父类的普通函数 调用父类的构造函数语法： 12345678910111213// 父类class Person &#123; constructor(surname)&#123; this.surname = surname; &#125;&#125;// 子类继承父类class Student entends Person &#123; constructor(surname,firstname) &#123; super(surname); //调用父类的 constructor(surname) this.firstname = firstname; //定义子类独有的属性 &#125;&#125; 注意：子类在构造函数中使用super,必须放到this前面（必须先调用父类的构造方法，在使用子类构造方法） 案例： 1234567891011121314151617181920212223// 父类class Father &#123; constructor(surname)&#123; this.surname = surname; &#125; saySurname() &#123; console.log(&#x27;我的姓是&#x27; + this.surname); &#125;&#125;// 子类继承父类class Son entends Father &#123; constructor(surname,firstname) &#123; super(surname); //调用父类的 constructor(surname) this.firstname = firstname; //定义子类独有的属性 &#125; sayFirstname() &#123; console.log(&#x27;我的名字是:&#x27; + this.firstname); &#125;&#125;var damao = new Son(&#x27;刘&#x27;,&#x27;德华&#x27;);damao.saySurname();damao.sayFirstname(); 调用父类的普通函数语法： 1234567891011121314class Father &#123; say() &#123; return &#x27;我是爸爸&#x27;; &#125;&#125;class Son extends Father &#123; say()&#123; // super.say() super调用父类的方法 return super.say() + &#x27;的儿子&#x27;; &#125;&#125;var damao = new Son();console.log(damao.say()); 多个方法之间不需要添加逗号分隔 继承中属性和方法的查找原则：就近原则，先看子类，再看父类 三个注意点 在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象 类里面的共有属性和方法一定要加 this使用 类里面的 1this 指向： constructor 里面的 this指向实例对象 方法里面的this指向这个方法的调用者 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; var that; var _that; class Star &#123; constructor(uname, age) &#123; // constructor 里面的this 指向的是 创建的实例对象 that = this; this.uname = uname; this.age = age; // this.sing(); this.btn = document.querySelector(&#x27;button&#x27;); this.btn.onclick = this.sing; &#125; sing() &#123; // 这个sing方法里面的this 指向的是 btn 这个按钮,因为这个按钮调用了这个函数 console.log(that.uname); // that里面存储的是constructor里面的this &#125; dance() &#123; // 这个dance里面的this 指向的是实例对象 ldh 因为ldh 调用了这个函数 _that = this; console.log(this); &#125; &#125; var ldh = new Star(&#x27;刘德华&#x27;); console.log(that === ldh); ldh.dance(); console.log(_that === ldh); // 1. 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象 // 2. 类里面的共有的属性和方法一定要加this使用. &lt;/script&gt;&lt;/body&gt; 构造函数和原型概述在典型的 OOP 的语言中（如 Java），都存在类的概念，类就是对象的模板，对象就是类的实例，但在 ES6之前， JS 中并没用引入类的概念。 ES6， 全称 ECMAScript 6.0 ，2015.06 发版。但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。 在 ES6之前 ，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。 创建对象有三种方式 对象字面量 new Object() 自定义构造函数 123456789101112131415// 1. 利用 new Object() 创建对象var obj1 = new Object();// 2. 利用对象字面量创建对象var obj2 = &#123;&#125;；// 3.利用构造函数创建对象function Star(uname,age) &#123; this.uname = uname; this.age = age; this.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;); &#125;&#125;var ldh = new Star(&#x27;刘德华&#x27;,18); 注意： 构造函数用于创建某一类对象，其首字母要大写 构造函数要和new一起使用才有意义 构造函数 构造函数是一种特殊的函数，主要用来初始化对象(为对象成员变量赋初始值)，它总与new一起使用 我们可以把对象中的一些公共的属性和方法抽取出来，然后封装到这个函数里面 new 在执行时会做四件事 在内存中创建一个新的空对象。 让 this 指向这个新的对象。 执行构造函数里面的代码，给这个新对象添加属性和方法。 返回这个新对象（所以构造函数里面不需要 return ）。 静态成员和实例成员JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。 静态成员: 在构造函数本身上添加的成员为静态成员，只能由构造函数本身来访问 实例成员: 在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问 1234567891011121314151617181920// 构造函数中的属性和方法我们称为成员，成员可以添加function Star(uname,age) &#123; this.uname = uname; this.age = age; this.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;); &#125;&#125;var ldh = new Star(&#x27;刘德华&#x27;,18);// 实例成员就是构造函数内部通过this添加的成员 uname age sing 就是实例成员// 实例成员只能通过实例化的对象来访问ldh.sing();Star.uname; // undefined 不可以通过构造函数来访问实例成员// 静态成员就是在构造函数本身上添加的成员 sex 就是静态成员// 静态成员只能通过构造函数来访问Star.sex = &#x27;男&#x27;;Star.sex;ldh.sex; // undefined 不能通过对象来访问 构造函数的问题构造函数方法很好用，但是存在浪费内存的问题。 我们希望所有的对象使用同一个函数，这样就比较节省内存 构造函数原型 prototype 构造函数通过原型分配的函数是所有对象所共享的,这样就解决了内存浪费问题 JavaScript 规定，每一个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有 我们可以把那些不变的方法，直接定义在prototype 对象上，这样所有对象的实例就可以共享这些方法 1234567891011121314151617181920212223&lt;body&gt; &lt;script&gt; // 1. 构造函数的问题. function Star(uname, age) &#123; //公共属性定义到构造函数里面 this.uname = uname; this.age = age; // this.sing = function() &#123; // console.log(&#x27;我会唱歌&#x27;); // &#125; &#125; //公共的方法我们放到原型对象身上 Star.prototype.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;); &#125; var ldh = new Star(&#x27;刘德华&#x27;, 18); var zxy = new Star(&#x27;张学友&#x27;, 19); console.log(ldh.sing === zxy.sing); ldh.sing(); zxy.sing(); // 2. 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上 &lt;/script&gt;&lt;/body&gt; 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上 问答：原型是什么？ 一个对象，我们也称为 prototype 为原型对象 问答：原型的作用是什么？ 共享方法 对象原型 __ proto __ 对象都会有一个属性 _proto_ 指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype 原型对象的属性和方法，就是因为对象有_proto_原型的存在。 _proto_对象原型和原型对象 prototype 是等价的 _proto_对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype Star.prototype 和 ldh._proto_ 指向相同 12345678910111213141516171819&lt;body&gt; &lt;script&gt; function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; Star.prototype.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;); &#125; var ldh = new Star(&#x27;刘德华&#x27;, 18); var zxy = new Star(&#x27;张学友&#x27;, 19); ldh.sing(); console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype console.log(ldh.__proto__ === Star.prototype); // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing // 如果没有sing 这个方法,因为有 __proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法 &lt;/script&gt;&lt;/body&gt; constructor 构造函数 对象原型(__ proto __) 和构造函数(prototype)原型对象 里面都有一个属性 constructor 属性， constructor 我们称为构造函数，因为它指回构造函数本身。 constructor主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数 一般情况下，对象的方法都在构造函数(prototype)的原型对象中设置 如果有多个对象的方法，我们可以给原型对象prototype采取对象形式赋值，但是这样会覆盖构造函数原型对象原来的内容，这样修改后的原型对象constructor就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个constructor指向原来的构造函数 具体请看实例配合理解 123456789101112131415161718192021222324252627&lt;body&gt; &lt;script&gt; function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数 // Star.prototype.sing = function() &#123; // console.log(&#x27;我会唱歌&#x27;); // &#125;; // Star.prototype.movie = function() &#123; // console.log(&#x27;我会演电影&#x27;); // &#125; Star.prototype = &#123; // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 constructor: Star, sing: function() &#123; console.log(&#x27;我会唱歌&#x27;); &#125;, movie: function() &#123; console.log(&#x27;我会演电影&#x27;); &#125; &#125; var ldh = new Star(&#x27;刘德华&#x27;, 18); var zxy = new Star(&#x27;张学友&#x27;, 19); &lt;/script&gt;&lt;/body&gt;7 构造函数、实例、原型对象三者关系 原型链查找规则 当访问一个对象的属性(包括方法)时，首先查找这个对象自身有没有该属性 如果没有就查找它的原型(也就是_proto_指向的prototype原型对象) 如果还没有就查找原型对象的原型(Object的原型对象) 依次类推一直找到Object为止(null) __ proto __对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。 123456789101112131415161718&lt;body&gt; &lt;script&gt; function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; Star.prototype.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;); &#125; var ldh = new Star(&#x27;刘德华&#x27;, 18); // 1. 只要是对象就有__proto__ 原型, 指向原型对象 console.log(Star.prototype); console.log(Star.prototype.__proto__ === Object.prototype); // 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype console.log(Object.prototype.__proto__); // 3. 我们Object.prototype原型对象里面的__proto__原型 指向为 null &lt;/script&gt;&lt;/body&gt; 原型对象this指向 构造函数中的 this指向我们的实例对象 原型对象里面放的是方法，这个方法里面的this指向的是这个方法的调用者，也就是这个实例对象 12345678910111213141516171819&lt;body&gt; &lt;script&gt; function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; var that; Star.prototype.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;); that = this; &#125; var ldh = new Star(&#x27;刘德华&#x27;, 18); // 1. 在构造函数中,里面this指向的是对象实例 ldh ldh.sing(); console.log(that === ldh); // 2.原型对象函数里面的this 指向的是 实例对象 ldh &lt;/script&gt;&lt;/body&gt; 扩展内置对象 可以通过原型对象，对原来的内置对象进行扩展自定义的方法 比如给数组增加自定义求偶数和的功能 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;script&gt; // 原型对象的应用 扩展内置对象方法 Array.prototype.sum = function() &#123; var sum = 0; for (var i = 0; i &lt; this.length; i++) &#123; sum += this[i]; &#125; return sum; &#125;; // Array.prototype = &#123; // sum: function() &#123; // var sum = 0; // for (var i = 0; i &lt; this.length; i++) &#123; // sum += this[i]; // &#125; // return sum; // &#125; // &#125; var arr = [1, 2, 3]; console.log(arr.sum()); console.log(Array.prototype); var arr1 = new Array(11, 22, 33); console.log(arr1.sum()); &lt;/script&gt;&lt;/body&gt; 注意： 数组和字符串内置对象不能给原型对象覆盖操作Array.prototype = &#123;&#125;，只能是Array.prototype.xxx = function()&#123;&#125;的方式 继承ES6 之前并没有给我们提供extends继承 我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承 call()调用这个函数，并且修改函数运行时的 this 指向 1fun.call(thisArg,arg1,arg2,......) thisArg：当前调用函数 this 的指向对象 arg1,arg2： 传递的其他参数 示例 12345678910111213141516171819&lt;body&gt; &lt;script&gt; // call 方法 function fn(x, y) &#123; console.log(&#x27;我希望我的希望有希望&#x27;); console.log(this); // Object&#123;...&#125; console.log(x + y); // 3 &#125; var o = &#123; name: &#x27;andy&#x27; &#125;; // fn(); // 1. call() 可以调用函数 // fn.call(); // 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象 fn.call(o, 1, 2); &lt;/script&gt;&lt;/body&gt; 借用构造函数继承父类型属性 核心原理: 通过 call() 把父类型的 this 指向子类型的 this，这样就可以实现子类型继承父类型的属性 12345678910111213141516171819&lt;body&gt; &lt;script&gt; // 借用父构造函数继承属性 // 1. 父构造函数 function Father(uname, age) &#123; // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; &#125; // 2 .子构造函数 function Son(uname, age, score) &#123; // this 指向子构造函数的对象实例 Father.call(this, uname, age); this.score = score; &#125; var son = new Son(&#x27;刘德华&#x27;, 18, 100); console.log(son); &lt;/script&gt;&lt;/body&gt; 借用原型对象继承父类型方法 一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法 核心原理： 将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类() 本质： 子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象 将子类的constructor重新指向子类的构造函数 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;script&gt; // 借用父构造函数继承属性 // 1. 父构造函数 function Father(uname, age) &#123; // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; &#125; Father.prototype.money = function() &#123; console.log(100000); &#125;; // 2 .子构造函数 function Son(uname, age, score) &#123; // this 指向子构造函数的对象实例 Father.call(this, uname, age); this.score = score; &#125; // Son.prototype = Father.prototype; 这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化 Son.prototype = new Father(); // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 Son.prototype.constructor = Son; // 这个是子构造函数专门的方法 Son.prototype.exam = function() &#123; console.log(&#x27;孩子要考试&#x27;); &#125; var son = new Son(&#x27;刘德华&#x27;, 18, 100); console.log(son); console.log(Father.prototype); console.log(Son.prototype.constructor); &lt;/script&gt;&lt;/body&gt; 类的本质 class 本质还是 function 类的所有方法都定义在类的 prototype属性上 类创建的实例，里面也有_proto_指向类的prototype原型对象 所以 ES6 的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 所以 ES6 的类其实就是语法糖 语法糖：语法糖就是一种便捷写法，简单理解 ES5新增方法ES5 给我们新增了一些方法，可以很方便的操作数组或者字符串 数组方法 字符串方法 对象方法 数组方法 迭代(遍历)方法：forEach() ，map()，filter()，some() ，every() ; forEach()1array.forEach(function(currentValue,index,arr)) currentValue : 数组当前项的值 index: 数组当前项的索引 arr: 数组对象本身 1234567891011121314&lt;body&gt; &lt;script&gt; // forEach 迭代(遍历) 数组 var arr = [1, 2, 3]; var sum = 0; arr.forEach(function(value, index, array) &#123; console.log(&#x27;每个数组元素&#x27; + value); console.log(&#x27;每个数组元素的索引号&#x27; + index); console.log(&#x27;数组本身&#x27; + array); sum += value; &#125;) console.log(sum); &lt;/script&gt;&lt;/body&gt; filter()筛选数组1array.filter(function(currentValue,index,arr)) filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组 注意它直接返回一个新数组 1234567891011&lt;body&gt; &lt;script&gt; // filter 筛选数组 var arr = [12, 66, 4, 88, 3, 7]; var newArr = arr.filter(function(value, index) &#123; // return value &gt;= 20; return value % 2 === 0; &#125;); console.log(newArr); &lt;/script&gt;&lt;/body&gt; some() some()方法用于检测数组中的元素是否满足指定条件（查找数组中是否有满足条件的元素） 注意它返回的是布尔值，如果查找到这个元素，就返回true，如果查找不到就返回false 如果找到第一个满足条件的元素，则终止循环，不再继续查找 123456789101112&lt;body&gt; &lt;script&gt; // some 查找数组中是否有满足条件的元素 var arr1 = [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;blue&#x27;]; var flag1 = arr1.some(function(value) &#123; return value == &#x27;pink&#x27;; &#125;); console.log(flag1); // 1. filter 也是查找满足条件的元素 返回的是一个数组 而且是把所有满足条件的元素返回回来 // 2. some 也是查找满足条件的元素是否存在 返回的是一个布尔值 如果查找到第一个满足条件的元素就终止循环 &lt;/script&gt;&lt;/body&gt; 字符串方法 trim()方法会从一个字符串的两端删除空白字符 trim()方法并不影响原字符串本身，它返回的是一个新的字符串 123456789101112131415161718192021222324&lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;button&gt;点击&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; // trim 方法去除字符串两侧空格 var str = &#x27; an dy &#x27;; console.log(str); var str1 = str.trim(); console.log(str1); var input = document.querySelector(&#x27;input&#x27;); var btn = document.querySelector(&#x27;button&#x27;); var div = document.querySelector(&#x27;div&#x27;); btn.onclick = function() &#123; var str = input.value.trim(); if (str === &#x27;&#x27;) &#123; alert(&#x27;请输入内容&#x27;); &#125; else &#123; console.log(str); console.log(str.length); div.innerHTML = str; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 对象方法Object.keys() Object.keys()用于获取对象自身所有的属性 效果类似for...in 返回一个由属性名组成的数组 1234567891011121314151617181920&lt;body&gt; &lt;script&gt; // 用于获取对象自身所有的属性 var obj = &#123; id: 1, pname: &#x27;小米&#x27;, price: 1999, num: 2000 &#125;; var arr = Object.keys(obj); console.log(arr); arr.forEach(function(value) &#123; console.log(value); // id // pname // price // num &#125;) &lt;/script&gt;&lt;/body&gt; Object.defineProperty() Object.defineProperty()定义对象中新属性或修改原有的属性(了解) 1Object.defineProperty(obj,prop,descriptor) obj : 目标对象 prop : 需定义或修改的属性的名字 descriptor : 目标属性所拥有的特性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;body&gt; &lt;script&gt; // Object.defineProperty() 定义新属性或修改原有的属性 var obj = &#123; id: 1, pname: &#x27;小米&#x27;, price: 1999 &#125;; // 1. 以前的对象添加和修改属性的方式 // obj.num = 1000; // obj.price = 99; // console.log(obj); // 2. Object.defineProperty() 定义新属性或修改原有的属性 Object.defineProperty(obj, &#x27;num&#x27;, &#123; value: 1000, enumerable: true &#125;); console.log(obj); Object.defineProperty(obj, &#x27;price&#x27;, &#123; value: 9.9 &#125;); console.log(obj); Object.defineProperty(obj, &#x27;id&#x27;, &#123; // 如果值为false 不允许修改这个属性值 默认值也是false writable: false, &#125;); obj.id = 2; console.log(obj); Object.defineProperty(obj, &#x27;address&#x27;, &#123; value: &#x27;中国山东蓝翔技校xx单元&#x27;, // 如果只为false 不允许修改这个属性值 默认值也是false writable: false, // enumerable 如果值为false 则不允许遍历, 默认的值是 false enumerable: false, // configurable 如果为false 则不允许删除这个属性 不允许在修改第三个参数里面的特性 默认为false configurable: false &#125;); console.log(obj); console.log(Object.keys(obj)); delete obj.address; console.log(obj); delete obj.pname; console.log(obj); Object.defineProperty(obj, &#x27;address&#x27;, &#123; value: &#x27;中国山东蓝翔技校xx单元&#x27;, // 如果值为false 不允许修改这个属性值 默认值也是false writable: true, // enumerable 如果值为false 则不允许遍历, 默认的值是 false enumerable: true, // configurable 如果为false 则不允许删除这个属性 默认为false configurable: true &#125;); console.log(obj.address); &lt;/script&gt;&lt;/body&gt; 第三个参数 descriptor 说明：以对象形式{ }书写 value：设置属性的值，默认为undefined writeable: 值是否可以重写 true | false 默认为false enumerable: 目标属性是否可以被枚举 true | false 默认为false configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false 默认为false 函数进阶函数的定义方式 函数声明方式 function 关键字(命名函数) 函数表达式(匿名函数) new Function() 1var fn = new Function(&#x27;参数1&#x27;,&#x27;参数2&#x27;,.....,&#x27;函数体&#x27;); Function 里面参数都必须是字符串格式 第三种方式执行效率低，也不方便书写，因此较少使用 所有函数都是 Function 的实例(对象) 函数也属于对象 123456789101112131415161718192021222324&lt;body&gt; &lt;script&gt; // 函数的定义方式 // 1. 自定义函数(命名函数) function fn() &#123;&#125;; // 2. 函数表达式 (匿名函数) var fun = function() &#123;&#125;; // 3. 利用 new Function(&#x27;参数1&#x27;,&#x27;参数2&#x27;, &#x27;函数体&#x27;); // Function 里面参数都必须是字符串格式，执行效率低，较少写 var f = new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;console.log(a + b)&#x27;); f(1, 2); // 4. 所有函数都是 Function 的实例(对象) console.dir(f); // 5. 函数也属于对象 console.log(f instanceof Object); &lt;/script&gt;&lt;/body&gt; 函数的调用方式 普通函数 对象的方法 构造函数 绑定事件函数 定时器函数 立即执行函数 1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;script&gt; // 函数的调用方式 // 1. 普通函数 function fn() &#123; console.log(&#x27;人生的巅峰&#x27;); &#125; // fn(); fn.call() // 2. 对象的方法 var o = &#123; sayHi: function() &#123; console.log(&#x27;人生的巅峰&#x27;); &#125; &#125; o.sayHi(); // 3. 构造函数 function Star() &#123;&#125;; new Star(); // 4. 绑定事件函数 // btn.onclick = function() &#123;&#125;; // 点击了按钮就可以调用这个函数 // 5. 定时器函数 // setInterval(function() &#123;&#125;, 1000); 这个函数是定时器自动1秒钟调用一次 // 6. 立即执行函数 (function() &#123; console.log(&#x27;人生的巅峰&#x27;); &#125;)(); // 立即执行函数是自动调用 &lt;/script&gt;&lt;/body&gt; 函数内this的指向 this指向，是当我们调用函数的时候确定的，调用方式的不同决定了this的指向不同，一般我们指向我们的调用者 调用方式 this指向 普通函数调用 window 构造函数调用 实例对象，原型对象里面的方法也指向实例对象 对象方法调用 该方法所属对象 事件绑定方法 绑定事件对象 定时器函数 window 立即执行函数 window 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; // 函数的不同调用方式决定了this 的指向不同 // 1. 普通函数 this 指向window function fn() &#123; console.log(&#x27;普通函数的this&#x27; + this); &#125; window.fn(); // 2. 对象的方法 this指向的是对象 o var o = &#123; sayHi: function() &#123; console.log(&#x27;对象方法的this:&#x27; + this); &#125; &#125; o.sayHi(); // 3. 构造函数 this 指向 ldh 这个实例对象 原型对象里面的this 指向的也是 ldh这个实例对象 function Star() &#123;&#125;; Star.prototype.sing = function() &#123; &#125; var ldh = new Star(); // 4. 绑定事件函数 this 指向的是函数的调用者 btn这个按钮对象 var btn = document.querySelector(&#x27;button&#x27;); btn.onclick = function() &#123; console.log(&#x27;绑定时间函数的this:&#x27; + this); &#125;; // 5. 定时器函数 this 指向的也是window window.setTimeout(function() &#123; console.log(&#x27;定时器的this:&#x27; + this); &#125;, 1000); // 6. 立即执行函数 this还是指向window (function() &#123; console.log(&#x27;立即执行函数的this&#x27; + this); &#125;)(); &lt;/script&gt;&lt;/body&gt; 改变函数内部this指向 JavaScript 为我们专门提供了一些函数方法来帮我们处理函数内部 this 的指向问题，常用的有 bind(),call(),apply()三种方法 call() 方法 call()方法调用一个对象，简单理解为调用函数的方式，但是它可以改变函数的this指向 fun.call(thisArg,arg1,arg2,.....) thisArg: 在 fun 函数运行时指定的 this 值 arg1,arg2: 传递的其他参数 返回值就是函数的返回值，因为它就是调用函数 因此当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call，比如继承 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;script&gt; // 改变函数内this指向 js提供了三种方法 call() apply() bind() // 1. call() var o = &#123; name: &#x27;andy&#x27; &#125; function fn(a, b) &#123; console.log(this); console.log(a + b); &#125;; fn.call(o, 1, 2); // call 第一个可以调用函数 第二个可以改变函数内的this 指向 // call 的主要作用可以实现继承 function Father(uname, age, sex) &#123; this.uname = uname; this.age = age; this.sex = sex; &#125; function Son(uname, age, sex) &#123; Father.call(this, uname, age, sex); &#125; var son = new Son(&#x27;刘德华&#x27;, 18, &#x27;男&#x27;); console.log(son); &lt;/script&gt;&lt;/body&gt; apply()方法 apply()方法调用一个函数，简单理解为调用函数的方式，但是它可以改变函数的 this指向 fun.apply(thisArg,[argsArray]) thisArg: 在 fun 函数运行时指定的 this 值 argsArray : 传递的值，必须包含在数组里面 返回值就是函数的返回值，因为它就是调用函数 因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值 123456789101112131415161718192021222324252627&lt;body&gt; &lt;script&gt; // 改变函数内this指向 js提供了三种方法 call() apply() bind() // 2. apply() 应用 运用的意思 var o = &#123; name: &#x27;andy&#x27; &#125;; function fn(arr) &#123; console.log(this); console.log(arr); // &#x27;pink&#x27; &#125;; fn.apply(o, [&#x27;pink&#x27;]); // 1. 也是调用函数 第二个可以改变函数内部的this指向 // 2. 但是他的参数必须是数组(伪数组) // 3. apply 的主要应用 比如说我们可以利用 apply 借助于数学内置对象求数组最大值 // Math.max(); var arr = [1, 66, 3, 99, 4]; var arr1 = [&#x27;red&#x27;, &#x27;pink&#x27;]; // var max = Math.max.apply(null, arr); var max = Math.max.apply(Math, arr); var min = Math.min.apply(Math, arr); console.log(max, min); &lt;/script&gt;&lt;/body&gt; bind()方法 bind()方法不会调用函数。但是能改变函数内部 this指向 fun.bind(thisArg,arg1,arg2,....) 返回由指定的 this值和初始化参数改造的 原函数拷贝 因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;button&gt;点击&lt;/button&gt; &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; // 改变函数内this指向 js提供了三种方法 call() apply() bind() // 3. bind() 绑定 捆绑的意思 var o = &#123; name: &#x27;andy&#x27; &#125;; function fn(a, b) &#123; console.log(this); console.log(a + b); &#125;; var f = fn.bind(o, 1, 2); f(); // 1. 不会调用原来的函数 可以改变原来函数内部的this 指向 // 2. 返回的是原函数改变this之后产生的新函数 // 3. 如果有的函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind // 4. 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮 // var btn1 = document.querySelector(&#x27;button&#x27;); // btn1.onclick = function() &#123; // this.disabled = true; // 这个this 指向的是 btn 这个按钮 // // var that = this; // setTimeout(function() &#123; // // that.disabled = false; // 定时器函数里面的this 指向的是window // this.disabled = false; // 此时定时器函数里面的this 指向的是btn // &#125;.bind(this), 3000); // 这个this 指向的是btn 这个对象 // &#125; var btns = document.querySelectorAll(&#x27;button&#x27;); for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; this.disabled = true; setTimeout(function() &#123; this.disabled = false; &#125;.bind(this), 2000); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 总结call apply bind 总结： 相同点： 都可以改变函数内部的 this指向 区别点： call和apply会调用函数，并且改变函数内部的this指向 call和apply传递的参数不一样，call 传递参数，apply 必须数组形式 bind不会调用函数，可以改变函数内部this指向 主要应用场景 call经常做继承 apply经常跟数组有关系，比如借助于数学对线实现数组最大值与最小值 bind不调用函数，但是还想改变this指向，比如改变定时器内部的this指向","categories":[{"name":"JS面向对象","slug":"JS面向对象","permalink":"http://example.com/categories/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"JS面向对象","slug":"JS面向对象","permalink":"http://example.com/tags/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"JavaScript进阶班之DOM技术(四)","slug":"JavaScript进阶班之DOM技术(四)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T08:27:18.394Z","comments":true,"path":"2022/04/24/JavaScript进阶班之DOM技术(四)/","link":"","permalink":"http://example.com/2022/04/24/JavaScript%E8%BF%9B%E9%98%B6%E7%8F%AD%E4%B9%8BDOM%E6%8A%80%E6%9C%AF(%E5%9B%9B)/","excerpt":"","text":"目录总览 DOM简介什么是DOM文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口 W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。 文档：一个页面就是一个文档，DOM中使用doucument来表示 元素：页面中的所有标签都是元素，DOM中使用 element 表示 节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示 DOM 把以上内容都看做是对象 获取元素如何获取页面元素DOM在我们实际开发中主要用来操作元素。 我们如何来获取页面中的元素呢? 获取页面中的元素可以使用以下几种方式: 根据 ID 获取 根据标签名获取 通过 HTML5 新增的方法获取 特殊元素获取 根据ID获取使用 getElementByld() 方法可以获取带ID的元素对象 1doucument.getElementByld(&#x27;id名&#x27;) 使用 console.dir() 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。 示例 1234567891011&lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;&lt;script&gt; // 1.因为我们文档页面从上往下加载，所以得先有标签，所以script写在标签下面 // 2.get 获得 element 元素 by 通过 驼峰命名法 // 3.参数 id是大小写敏感的字符串 // 4.返回的是一个元素对象 var timer = document.getElementById(&#x27;time&#x27;); console.log(timer); // 5. console.dir 打印我们的元素对象，更好的查看里面的属性和方法 console.dir(timer);&lt;/script&gt; 根据标签名获取根据标签名获取，使用 getElementByTagName() 方法可以返回带有指定标签名的对象的集合 1doucument.getElementsByTagName(&#x27;标签名&#x27;); 因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历 得到元素对象是动态的 返回的是获取过来元素对象的集合，以伪数组的形式存储 如果获取不到元素，则返回为空的伪数组(因为获取不到对象) 12345678910111213141516171819&lt;ul&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 1.返回的是获取过来元素对象的集合 以伪数组的形式存储 var lis = document.getElementsByTagName(&#x27;li&#x27;); console.log(lis); console.log(lis[0]); // 2.依次打印,遍历 for (var i = 0; i &lt; lis.length; i++) &#123; console.log(lis[i]); &#125; // 3.如果页面中只有 1 个 li，返回的还是伪数组的形式 // 4.如果页面中没有这个元素，返回的是空伪数组&lt;/script&gt; 根据标签名获取还可以根据标签名获取某个元素（父元素）内部所有指定标签名的子元素,获取的时候不包括父元素自己 123element.getElementsByTagName(&#x27;标签名&#x27;)ol.getElementsByTagName(&#x27;li&#x27;); 注意：父元素必须是单个对象(必须指明是哪一个元素对象)，获取的时候不包括父元素自己 12345&lt;script&gt; //element.getElementsByTagName(&#x27;标签名&#x27;); 父元素必须是指定的单个元素 var ol = document.getElementById(&#x27;ol&#x27;); console.log(ol.getElementsByTagName(&#x27;li&#x27;));&lt;/script&gt; 通过H5新增方法获取①getElementsByClassName根据类名返回元素对象合集 document.getElementsByClassName(&#39;类名&#39;) 1 ②document.querySelector根据指定选择器返回第一个元素对象 1234567document.querySelector(&#x27;选择器&#x27;);// 切记里面的选择器需要加符号 // 类选择器.box // id选择器 #navvar firstBox = document.querySelector(&#x27;.box&#x27;);123456 ③document.querySelectorAll根据指定选择器返回所有元素对象 1document.querySelectorAll(&#x27;选择器&#x27;); 注意： 1querySelector` 和 `querySelectorAll` 里面的选择器需要加符号,比如: `document.querySelector(&#x27;#nav&#x27;); ④例子1234567891011121314151617&lt;script&gt; // 1. getElementsByClassName 根据类名获得某些元素集合 var boxs = document.getElementsByClassName(&#x27;box&#x27;); console.log(boxs); // 2. querySelector 返回指定选择器的第一个元素对象 切记 里面的选择器需要加符号 .box #nav var firstBox = document.querySelector(&#x27;.box&#x27;); console.log(firstBox); var nav = document.querySelector(&#x27;#nav&#x27;); console.log(nav); var li = document.querySelector(&#x27;li&#x27;); console.log(li); // 3. querySelectorAll()返回指定选择器的所有元素对象集合 var allBox = document.querySelectorAll(&#x27;.box&#x27;); console.log(allBox); var lis = document.querySelectorAll(&#x27;li&#x27;); console.log(lis);&lt;/script&gt; 获取特殊元素①获取body元素返回body元素对象 1document.body; ②获取html元素返回html元素对象 1document.documentElement; 事件基础事件概述JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 简单理解： 触发— 响应机制。 网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。 事件三要素 事件源(谁) 事件类型(什么事件) 事件处理程序(做啥) 1234567891011&lt;script&gt; // 点击一个按钮，弹出对话框 // 1. 事件是有三部分组成 事件源 事件类型 事件处理程序 我们也称为事件三要素 //(1) 事件源 事件被触发的对象 谁 按钮 var btn = document.getElementById(&#x27;btn&#x27;); //(2) 事件类型 如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下 //(3) 事件处理程序 通过一个函数赋值的方式 完成 btn.onclick = function() &#123; alert(&#x27;点秋香&#x27;); &#125;&lt;/script&gt; 执行事件的步骤 获取事件源 注册事件(绑定事件) 添加事件处理程序(采取函数赋值形式) 123456789101112&lt;script&gt; // 执行事件步骤 // 点击div 控制台输出 我被选中了 // 1. 获取事件源 var div = document.querySelector(&#x27;div&#x27;); // 2.绑定事件 注册事件 // div.onclick // 3.添加事件处理程序 div.onclick = function() &#123; console.log(&#x27;我被选中了&#x27;); &#125;&lt;/script&gt; 鼠标事件 鼠标事件 触发条件 onclick 鼠标点击左键触发 onmouseover 鼠标经过触发 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmousemove 鼠标移动触发 onmouseup 鼠标弹起触发 onmousedown 鼠标按下触发 操作元素JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容 、属性等。注意以下都是属性 改变元素内容从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉。 1element.innerText 起始位置到终止位置的全部内容，包括HTML标签，同时保留空格和换行 12345678910111213141516171819202122element.innerHTML&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt; 我是文字 &lt;span&gt;123&lt;/span&gt; &lt;/p&gt; &lt;script&gt; // innerText 和 innerHTML的区别 // 1. innerText 不识别html标签,去除空格和换行 var div = document.querySelector(&#x27;div&#x27;); div.innerText = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;; // 2. innerHTML 识别html标签 保留空格和换行的 div.innerHTML = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;; // 这两个属性是可读写的 可以获取元素里面的内容 var p = document.querySelector(&#x27;p&#x27;); console.log(p.innerText); console.log(p.innerHTML); &lt;/script&gt;&lt;/body&gt; 改变元素属性12345678// img.属性img.src = &quot;xxx&quot;;input.value = &quot;xxx&quot;;//表单里的值，文字通过value来修改的input.type = &quot;xxx&quot;;input.checked = &quot;xxx&quot;;input.selected = true / false;input.disabled = true / false; //表单被禁用 改变样式属性我们可以通过 JS 修改元素的大小、颜色、位置等样式。 行内样式操作 123// element.stylediv.style.backgroundColor = &#x27;pink&#x27;;div.style.width = &#x27;250px&#x27;; 类名样式操作 1// element.className 注意： JS里面的样式采取驼峰命名法，比如 fontSize ，backgroundColor JS 修改 style 样式操作 ，产生的是行内样式，CSS权重比较高 如果样式修改较多，可以采取操作类名方式更改元素样式 class 因为是个保留字，因此使用className来操作元素类名属性 className 会直接更改元素的类名，会覆盖原先的类名 12345678910111213141516171819&lt;body&gt; &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt; &lt;script&gt; // 1. 使用 element.style 获得修改元素样式 如果样式比较少 或者 功能简单的情况下使用 var test = document.querySelector(&#x27;div&#x27;); test.onclick = function() &#123; // this.style.backgroundColor = &#x27;purple&#x27;; // this.style.color = &#x27;#fff&#x27;; // this.style.fontSize = &#x27;25px&#x27;; // this.style.marginTop = &#x27;100px&#x27;; // 让我们当前元素的类名改为了 change // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况 // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器 // this.className = &#x27;change&#x27;; this.className = &#x27;first change&#x27;; &#125; &lt;/script&gt;&lt;/body&gt; 总结 排他思想如果有同一组元素，我们相要某一个元素实现某种样式，需要用到循环的排他思想算法： 所有元素全部清除样式（干掉其他人） 给当前元素设置样式 （留下我自己） 注意顺序不能颠倒，首先干掉其他人，再设置自己 123456789101112131415161718192021222324&lt;body&gt; &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;button&gt;按钮4&lt;/button&gt; &lt;button&gt;按钮5&lt;/button&gt; &lt;script&gt; // 1. 获取所有按钮元素 var btns = document.getElementsByTagName(&#x27;button&#x27;); // btns得到的是伪数组 里面的每一个元素 btns[i] for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function() &#123; // (1) 我们先把所有的按钮背景颜色去掉 干掉所有人 for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].style.backgroundColor = &#x27;&#x27;; &#125; // (2) 然后才让当前的元素背景颜色为pink 留下我自己 this.style.backgroundColor = &#x27;pink&#x27;; &#125; &#125; //2. 首先先排除其他人，然后才设置自己的样式 这种排除其他人的思想我们成为排他思想 &lt;/script&gt;&lt;/body&gt; 自定义属性获取属性值 获取内置属性值(元素本身自带的属性) 1element.属性; 获取自定义的属性 1element.getAttribute(&#x27;属性&#x27;); 设置属性值 设置内置属性值 1element.属性 = &#x27;值&#x27;; 主要设置自定义的属性 1element.setAttribute(&#x27;属性&#x27;); 移除属性1234567891011121314151617181920212223element.removeAttribute(&#x27;属性&#x27;);&lt;body&gt; &lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt; &lt;script&gt; var div = document.querySelector(&#x27;div&#x27;); // 1. 获取元素的属性值 // (1) element.属性 console.log(div.id); //(2) element.getAttribute(&#x27;属性&#x27;) get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index console.log(div.getAttribute(&#x27;id&#x27;)); console.log(div.getAttribute(&#x27;index&#x27;)); // 2. 设置元素属性值 // (1) element.属性= &#x27;值&#x27; div.id = &#x27;test&#x27;; div.className = &#x27;navs&#x27;; // (2) element.setAttribute(&#x27;属性&#x27;, &#x27;值&#x27;); 主要针对于自定义属性 div.setAttribute(&#x27;index&#x27;, 2); div.setAttribute(&#x27;class&#x27;, &#x27;footer&#x27;); // class 特殊 这里面写的就是class 不是className // 3 移除属性 removeAttribute(属性) div.removeAttribute(&#x27;index&#x27;); &lt;/script&gt;&lt;/body&gt; H5自定义属性自定义属性目的： 保存并保存数据，有些数据可以保存到页面中而不用保存到数据库中 有些自定义属性很容易引起歧义，不容易判断到底是内置属性还是自定义的，所以H5有了规定 设置H5自定义属性H5规定自定义属性 data-开头作为属性名并赋值 123&lt;div data-index = &quot;1&quot;&gt;&lt;/&gt;// 或者使用JavaScript设置div.setAttribute(&#x27;data-index&#x27;,1); 获取H5自定义属性 兼容性获取 element.getAttribute(&#39;data-index&#39;) H5新增的：element.dataset.index 或element.dataset[&#39;index&#39;] IE11才开始支持 123456789101112131415161718&lt;body&gt; &lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt; &lt;script&gt; var div = document.querySelector(&#x27;div&#x27;); console.log(div.getAttribute(&#x27;getTime&#x27;)); div.setAttribute(&#x27;data-time&#x27;, 20); console.log(div.getAttribute(&#x27;data-index&#x27;)); console.log(div.getAttribute(&#x27;data-list-name&#x27;)); // h5新增的获取自定义属性的方法 它只能获取data-开头的 // dataset 是一个集合里面存放了所有以data开头的自定义属性 console.log(div.dataset); console.log(div.dataset.index); console.log(div.dataset[&#x27;index&#x27;]); // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法 console.log(div.dataset.listName); console.log(div.dataset[&#x27;listName&#x27;]); &lt;/script&gt;&lt;/body&gt; 节点操作获取元素通常使用两种方式： 1.利用DOM提供的方法获取元素 2.利用节点层级关系获取元素 document.getElementById() 利用父子兄节点关系获取元素 document.getElementsByTagName() 逻辑性强，但是兼容性较差 document.querySelector 等 逻辑性不强，繁琐 这两种方式都可以获取元素节点，我们后面都会使用，但是节点操作更简单 一般的，节点至少拥有三个基本属性 节点概述网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。 一般的，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。 元素节点：nodeType 为1 属性节点：nodeType 为2 文本节点：nodeType 为3(文本节点包括文字、空格、换行等) 我们在实际开发中，节点操作主要操作的是元素节点 利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。 父级节点1node.parentNode parentNode属性可以返回某节点的父结点，注意是最近的一个父结点 如果指定的节点没有父结点则返回null 123456789101112131415161718192021222324&lt;body&gt; &lt;!-- 节点的优点 --&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;ul&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;span class=&quot;erweima&quot;&gt;×&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 1. 父节点 parentNode var erweima = document.querySelector(&#x27;.erweima&#x27;); // var box = document.querySelector(&#x27;.box&#x27;); // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null console.log(erweima.parentNode); &lt;/script&gt;&lt;/body&gt; 子结点1parentNode.childNodes(标准) parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合 返回值包含了所有的子结点，包括元素节点，文本节点等 如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes 1parentNode.children(非标准) parentNode.children 是一个只读属性，返回所有的子元素节点 它只返回子元素节点，其余节点不返回 （这个是我们重点掌握的） 虽然 children 是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用 12345678910111213141516171819202122232425&lt;body&gt; &lt;ul&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; // DOM 提供的方法（API）获取 var ul = document.querySelector(&#x27;ul&#x27;); var lis = ul.querySelectorAll(&#x27;li&#x27;); // 1. 子节点 childNodes 所有的子节点 包含 元素节点 文本节点等等 console.log(ul.childNodes); console.log(ul.childNodes[0].nodeType); console.log(ul.childNodes[1].nodeType); // 2. children 获取所有的子元素节点 也是我们实际开发常用的 console.log(ul.children); &lt;/script&gt;&lt;/body&gt; 第一个子结点1parentNode.firstChild firstChild 返回第一个子节点，找不到则返回null 同样，也是包含所有的节 点 最后一个子结点1parentNode.lastChild lastChild 返回最后一个子节点，找不到则返回null 同样，也是包含所有的节点 123456789101112131415161718192021&lt;body&gt; &lt;ol&gt; &lt;li&gt;我是li1&lt;/li&gt; &lt;li&gt;我是li2&lt;/li&gt; &lt;li&gt;我是li3&lt;/li&gt; &lt;li&gt;我是li4&lt;/li&gt; &lt;li&gt;我是li5&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; var ol = document.querySelector(&#x27;ol&#x27;); // 1. firstChild 第一个子节点 不管是文本节点还是元素节点 console.log(ol.firstChild); console.log(ol.lastChild); // 2. firstElementChild 返回第一个子元素节点 ie9才支持 console.log(ol.firstElementChild); console.log(ol.lastElementChild); // 3. 实际开发的写法 既没有兼容性问题又返回第一个子元素 console.log(ol.children[0]); //第一个子元素节点 console.log(ol.children[ol.children.length - 1]);//最后一个子元素节点 &lt;/script&gt;&lt;/body&gt; 第一个子结点(兼容性)1parentNode.firstElementChild firstElementChild 返回第一个子节点，找不到则返回null 有兼容性问题，IE9以上才支持 最后一个子结点(兼容性)1parentNode.lastElementChild lastElementChild 返回最后一个子节点，找不到则返回null 有兼容性问题，IE9以上才支持 解决方案实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？ 解决方案 如果想要第一个子元素节点，可以使用 parentNode.chilren[0] 如果想要最后一个子元素节点，可以使用 12// 数组元素个数减1 就是最后一个元素的索引号parentNode.chilren[parentNode.chilren.length - 1] 示例： 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;ol&gt; &lt;li&gt;我是li1&lt;/li&gt; &lt;li&gt;我是li2&lt;/li&gt; &lt;li&gt;我是li3&lt;/li&gt; &lt;li&gt;我是li4&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; var ol = document.querySelector(&#x27;ol&#x27;); // 1.firstChild 获取第一个子结点的，包含文本结点和元素结点 console.log(ol.firstChild); // 返回的是文本结点 #text(第一个换行结点) console.log(ol.lastChild); // 返回的是文本结点 #text(最后一个换行结点) // 2. firstElementChild 返回第一个子元素结点 console.log(ol.firstElementChild); // &lt;li&gt;我是li1&lt;/li&gt; // 第2个方法有兼容性问题，需要IE9以上才支持 // 3.实际开发中，既没有兼容性问题，又返回第一个子元素 console.log(ol.children[0]); // &lt;li&gt;我是li1&lt;/li&gt; console.log(ol.children[3]); // &lt;li&gt;我是li4&lt;/li&gt; // 当里面li个数不唯一时候，需要取到最后一个结点时这么写 console.log(ol.children[ol.children.length - 1]); &lt;/script&gt;&lt;/body&gt; 兄弟节点下一个兄弟节点1node.nextSibling nextSibling 返回当前元素的下一个兄弟元素节点，找不到则返回null 同样，也是包含所有的节点 上一个兄弟节点1node.previousSibling previousSibling 返回当前元素上一个兄弟元素节点，找不到则返回null 同样，也是包含所有的节点 下一个兄弟节点(兼容性)1node.nextElementSibling nextElementSibling 返回当前元素下一个兄弟元素节点，找不到则返回null 有兼容性问题，IE9才支持 上一个兄弟节点(兼容性)1node.previousElementSibling previousElementSibling 返回当前元素上一个兄弟元素节点，找不到则返回null 有兼容性问题，IE9才支持 示例 12345678910111213&lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;span&gt;我是span&lt;/span&gt; &lt;script&gt; var div = document.querySelector(&#x27;div&#x27;); // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等 console.log(div.nextSibling); // #text console.log(div.previousSibling); // #text // 2. nextElementSibling 得到下一个兄弟元素节点 console.log(div.nextElementSibling); //&lt;span&gt;我是span&lt;/span&gt; console.log(div.previousElementSibling);//null &lt;/script&gt;&lt;/body&gt; 如何解决兼容性问题 ？ 答：自己封装一个兼容性的函数 123456789function getNextElementSibling(element) &#123; var el = element; while(el = el.nextSibling) &#123; if(el.nodeType === 1)&#123; return el; &#125; &#125; return null;&#125; 创建节点1document.createElement(&#x27;tagName&#x27;); document.createElement() 方法创建由 tagName 指定的HTML 元素 因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点 添加节点1node.appendChild(child) node.appendChild() 方法将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS 里面的 after 伪元素。 1node.insertBefore(child,指定元素) node.insertBefore() 方法将一个节点添加到父节点的指定子节点前面。类似于 CSS 里面的 before 伪元素。 示例 1234567891011121314151617&lt;body&gt; &lt;ul&gt; &lt;li&gt;123&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1. 创建节点元素节点 var li = document.createElement(&#x27;li&#x27;); // 2. 添加节点 node.appendChild(child) node 父级 child 是子级 后面追加元素 类似于数组中的push // 先获取父亲ul var ul = document.querySelector(&#x27;ul&#x27;); ul.appendChild(li); // 3. 添加节点 node.insertBefore(child, 指定元素); var lili = document.createElement(&#x27;li&#x27;); ul.insertBefore(lili, ul.children[0]); // 4. 我们想要页面添加一个新的元素分两步: 1. 创建元素 2. 添加元素 &lt;/script&gt;&lt;/body&gt; 删除节点1node.removeChild(child) node.removeChild()方法从 DOM 中删除一个子节点，返回删除的节点 javascript:;//组织链接跳转 复制节点(克隆节点)1node.cloneNode() node.cloneNode()方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点 如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点 如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点 示例 1234567891011121314&lt;body&gt; &lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var ul = document.querySelector(&#x27;ul&#x27;); // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容 // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容 var lili = ul.children[0].cloneNode(true); ul.appendChild(lili); &lt;/script&gt;&lt;/body&gt; 面试题三种动态创建元素的区别 doucument.write() element.innerHTML document.createElement() 区别： document.write() 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘 innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘 innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂 1234567891011121314151617181920212223&lt;body&gt; &lt;div class=&quot;innner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;create&quot;&gt;&lt;/div&gt; &lt;script&gt; // 2. innerHTML 创建元素 var inner = document.querySelector(&#x27;.inner&#x27;); // 2.1 innerHTML 用拼接字符串方法 for (var i = 0; i &lt;= 100; i++) &#123; inner.innerHTML += &#x27;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#x27;; &#125; // 2.2 innerHTML 用数组形式拼接 var arr = []; for (var i = 0; i &lt;= 100; i++) &#123; arr.push(&#x27;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#x27;); &#125; inner.innerHTML = arr.join(&#x27;&#x27;); // 3.document.createElement() 创建元素 var create = document.querySelector(&#x27;.create&#x27;); var a = document.createElement(&#x27;a&#x27;); create.appendChild(a); &lt;/script&gt;&lt;/body&gt; createElement()创建多个元素效率稍低一点点，但是结构更清晰 总结：不同浏览器下， innerHTML 效率要比 createElement 高 DOM核心对于DOM操作，我们主要针对子元素的操作，主要有 创建 增 删 改 查 属性操作 时间操作 创建 document.write innerHTML createElement 增 appendChild insertBefore 删 removeChild 改 主要修改dom的元素属性，dom元素的内容、属性、表单的值等 修改元素属性：src、href、title 等 修改普通元素内容：innerHTML、innerText 修改表单元素：value、type、disabled 修改元素样式：style、className 查 主要获取查询dom的元素 DOM提供的API方法：getElementById、getElementsByTagName (古老用法，不推荐) H5提供的新方法：querySelector、querySelectorAll (提倡) 利用节点操作获取元素：父(parentNode)、子(children)、兄(previousElementSibling、nextElementSibling) 提倡 属性操作 主要针对于自定义属性 setAttribute：设置dom的属性值 getAttribute：得到dom的属性值 removeAttribute：移除属性 事件高级注册事件(绑定事件)给元素添加事件，称为注册事件或者绑定事件。 注册事件有两种方式：传统方式和方法监听注册方式 传统注册方式 方法监听注册方式 利用 on 开头的事件 onclick w3c 标准推荐方式 &lt;button onclick = &quot;alert(&quot;hi&quot;)&quot;&gt;&lt;/button&gt; addEventListener() 它是一个方法 btn.onclick = function() {} IE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替 特点：注册事件的唯一性 特点：同一个元素同一个事件可以注册多个监听器 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数 按注册顺序依次执行 ①addEventListener事件监听方式 eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上 当该对象触发指定的事件时，就会执行事件处理函数 1eventTarget.addEventListener(type,listener[,useCapture]) 该方法接收三个参数： type:事件类型字符串，比如click,mouseover,注意这里不要带on listener：事件处理函数，事件发生时，会调用该监听函数 useCapture：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;button&gt;传统注册事件&lt;/button&gt; &lt;button&gt;方法监听注册事件&lt;/button&gt; &lt;button&gt;ie9 attachEvent&lt;/button&gt; &lt;script&gt; var btns = document.querySelectorAll(&#x27;button&#x27;); // 1. 传统方式注册事件 btns[0].onclick = function() &#123; alert(&#x27;hi&#x27;); &#125; btns[0].onclick = function() &#123; alert(&#x27;hao a u&#x27;); &#125; // 2. 事件监听注册事件 addEventListener // (1) 里面的事件类型是字符串 所以加引号 而且不带on // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序） btns[1].addEventListener(&#x27;click&#x27;, function() &#123; alert(22); &#125;) btns[1].addEventListener(&#x27;click&#x27;, function() &#123; alert(33); &#125;) // 3. attachEvent ie9以前的版本支持 btns[2].attachEvent(&#x27;onclick&#x27;, function() &#123; alert(11); &#125;) &lt;/script&gt;&lt;/body&gt; ②attachEvent事件监听方式(兼容) eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上 当该对象触发指定的事件时，指定的回调函数就会被执行 1eventTarget.attachEvent(eventNameWithOn,callback) 该方法接收两个参数： eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on callback： 事件处理函数，当目标触发事件时回调函数被调用 ie9以前的版本支持 ③注册事件兼容性解决方案兼容性处理的原则：首先照顾大多数浏览器，再处理特殊浏览器 1234567891011function addEventListener(element, eventName, fn) &#123; // 判断当前浏览器是否支持 addEventListener 方法 if (element.addEventListener) &#123; element.addEventListener(eventName, fn); // 第三个参数 默认是false &#125; else if (element.attachEvent) &#123; element.attachEvent(&#x27;on&#x27; + eventName, fn); &#125; else &#123; // 相当于 element.onclick = fn; element[&#x27;on&#x27; + eventName] = fn;&#125; 删除事件(解绑事件)removeEventListener删除事件方式1eventTarget.removeEventListener(type,listener[,useCapture]); 该方法接收三个参数： type:事件类型字符串，比如click,mouseover,注意这里不要带on listener：事件处理函数，事件发生时，会调用该监听函数 useCapture：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习 detachEvent删除事件方式(兼容)1eventTarget.detachEvent(eventNameWithOn,callback); 该方法接收两个参数： eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on callback： 事件处理函数，当目标触发事件时回调函数被调用 ie9以前的版本支持 传统事件删除方式1eventTarget.onclick = null; 事件删除示例： 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; var divs = document.querySelectorAll(&#x27;div&#x27;); divs[0].onclick = function() &#123; alert(11); // 1. 传统方式删除事件 divs[0].onclick = null; &#125; // 2.removeEventListener 删除事件 divs[1].addEventListener(&#x27;click&#x27;,fn); //里面的fn不需要调用加小括号 function fn()&#123; alert(22); divs[1].removeEventListener(&#x27;click&#x27;,fn); &#125; // 3.IE9 中的删除事件方式 divs[2].attachEvent(&#x27;onclick&#x27;,fn1); function fn1() &#123; alert(33); divs[2].detachEvent(&#x27;onclick&#x27;,fn1); &#125; &lt;/script&gt;&lt;/body&gt; 删除事件兼容性解决方案123456789function removeEventListener(element, eventName, fn) &#123; // 判断当前浏览器是否支持 removeEventListener 方法 if (element.removeEventListener) &#123; element.removeEventListener(eventName, fn); // 第三个参数 默认是false &#125; else if (element.detachEvent) &#123; element.detachEvent(&#x27;on&#x27; + eventName, fn); &#125; else &#123; element[&#x27;on&#x27; + eventName] = null;&#125; DOM事件流 事件流描述的是从页面中接收事件的顺序 事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流 事件冒泡： IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。 事件捕获： 网景最早提出，由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。 加深理解： 我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。 捕获阶段 document -&gt; html -&gt; body -&gt; father -&gt; son 两个盒子嵌套，一个父盒子一个子盒子，我们的需求是当点击父盒子时弹出 father ，当点击子盒子时弹出 son 12345678910111213141516171819&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // dom 事件流 三个阶段 // 1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。 // 2. onclick 和 attachEvent（ie） 只能得到冒泡阶段。 // 3. 捕获阶段 如果addEventListener 第三个参数是 true 那么则处于捕获阶段 document -&gt; html -&gt; body -&gt; father -&gt; son var son = document.querySelector(&#x27;.son&#x27;); son.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;son&#x27;); &#125;, true); var father = document.querySelector(&#x27;.father&#x27;); father.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;father&#x27;); &#125;, true); &lt;/script&gt;&lt;/body&gt; 但是因为DOM流的影响，我们点击子盒子，会先弹出 father，之后再弹出 son 这是因为捕获阶段由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收 document -&gt; html -&gt; body -&gt; father -&gt; son 先看 document 的事件，没有；再看 html 的事件，没有；再看 body 的事件，没有；再看 father 的事件，有就先执行；再看 son 的事件，再执行。 冒泡阶段 son -&gt; father -&gt;body -&gt; html -&gt; document 12345678910111213141516171819&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 4. 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么则处于冒泡阶段 son -&gt; father -&gt;body -&gt; html -&gt; document var son = document.querySelector(&#x27;.son&#x27;); son.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;son&#x27;); &#125;, false); var father = document.querySelector(&#x27;.father&#x27;); father.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;father&#x27;); &#125;, false); document.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;document&#x27;); &#125;) &lt;/script&gt;&lt;/body&gt; 我们点击子盒子，会弹出 son、father、document 这是因为冒泡阶段开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点 son -&gt; father -&gt;body -&gt; html -&gt; document 小结 JS 代码中只能执行捕获或者冒泡其中的一个阶段 onclick 和 attachEvent只能得到冒泡阶段 addEventListener(type,listener[,useCapture])第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false (不写默认就是false),表示在事件冒泡阶段调用事件处理程序 实际开发中我们很少使用事件捕获，我们更关注事件冒泡。 有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave 事件对象123456eventTarget.onclick = function(event) &#123; // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt &#125; eventTarget.addEventListener(&#x27;click&#x27;, function(event) &#123; // 这个 event 就是事件对象，我们还喜欢的写成 e 或者 evt &#125;) 官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态 简单理解： 事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面 这个对象就是事件对象 event，它有很多属性和方法，比如“ 谁绑定了这个事件 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键 这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去 当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数） 1234567891011121314151617181920&lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;script&gt; // 事件对象 var div = document.querySelector(&#x27;div&#x27;); div.onclick = function(e) &#123; // console.log(e); // console.log(window.event); // e = e || window.event; console.log(e); &#125; // 1. event 就是一个事件对象 写到我们侦听函数的 小括号里面 当形参来看 // 2. 事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数 // 3. 事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标啊，如果是键盘事件里面就包含的键盘事件的信息 比如 判断用户按下了那个键 // 4. 这个事件对象我们可以自己命名 比如 event 、 evt、 e // 5. 事件对象也有兼容性问题 ie678 通过 window.event 兼容性的写法 e = e || window.event; &lt;/script&gt;&lt;/body&gt; 事件对象的兼容性方案事件对象本身的获取存在兼容问题： 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。 在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找 解决： 1e = e || window.event; 事件对象的常见属性和方法 事件对象属性方法 说明 e.target 返回触发事件的对象 标准 e.srcElement 返回触发事件的对象 非标准 ie6-8使用 e.type 返回事件的类型 比如click mouseover 不带on e.cancelBubble 该属性阻止冒泡，非标准，ie6-8使用 e.returnValue 该属性阻止默认行为 非标准，ie6-8使用 e.preventDefault() 该方法阻止默认行为 标准 比如不让链接跳转 e.stopPropagation() 阻止冒泡 标准 e.target 和 this 的区别： this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素） e.target 是事件触发的元素。 事件对象阻止默认行为1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;form action=&quot;http://www.baidu.com&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;sub&quot;&gt; &lt;/form&gt; &lt;script&gt; // 常见事件对象的属性和方法 // 1. 返回事件类型 var div = document.querySelector(&#x27;div&#x27;); div.addEventListener(&#x27;click&#x27;, fn); div.addEventListener(&#x27;mouseover&#x27;, fn); div.addEventListener(&#x27;mouseout&#x27;, fn); function fn(e) &#123; console.log(e.type); &#125; // 2. 阻止默认行为（事件） 让链接不跳转 或者让提交按钮不提交 var a = document.querySelector(&#x27;a&#x27;); a.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault(); // dom 标准写法 &#125;) // 3. 传统的注册方式 a.onclick = function(e) &#123; // 普通浏览器 e.preventDefault(); 方法 // e.preventDefault(); // 低版本浏览器 ie678 returnValue 属性 // e.returnValue; // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点： return 后面的代码不执行了， 而且只限于传统的注册方式 return false; alert(11); &#125; &lt;/script&gt;&lt;/body&gt; 阻止事件冒泡事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点 事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。 标准写法 1e.stopPropagation(); 非标准写法： IE6-8 利用对象事件 cancelBubble属性 12345678910111213141516171819202122232425e.cancelBubble = true;&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 常见事件对象的属性和方法 // 阻止冒泡 dom 推荐的标准 stopPropagation() var son = document.querySelector(&#x27;.son&#x27;); son.addEventListener(&#x27;click&#x27;, function(e) &#123; alert(&#x27;son&#x27;); e.stopPropagation(); // stop 停止 Propagation 传播 e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡 &#125;, false); var father = document.querySelector(&#x27;.father&#x27;); father.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;father&#x27;); &#125;, false); document.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;document&#x27;); &#125;) &lt;/script&gt;&lt;/body&gt; 阻止事件冒泡的兼容性解决方案12345if(e &amp;&amp; e.stopPropagation)&#123; e.stopPropagation(); &#125;else&#123; window.event.cancelBubble = true; &#125; e.target 与 this e.target 与 this 的区别 this是事件绑定的元素，这个函数的调用者(绑定这个事件的元素) e.target是事件触发的元素 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;ul&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 常见事件对象的属性和方法 // 1. e.target 返回的是触发事件的对象（元素） this 返回的是绑定事件的对象（元素） // 区别 ： e.target 点击了那个元素，就返回那个元素 this 那个元素绑定了这个点击事件，那么就返回谁 var div = document.querySelector(&#x27;div&#x27;); div.addEventListener(&#x27;click&#x27;, function(e) &#123; console.log(e.target); console.log(this); &#125;) var ul = document.querySelector(&#x27;ul&#x27;); ul.addEventListener(&#x27;click&#x27;, function(e) &#123; // 我们给ul 绑定了事件 那么this 就指向ul console.log(this); console.log(e.currentTarget); // e.target 指向我们点击的那个对象 谁触发了这个事件 我们点击的是li e.target 指向的就是li console.log(e.target); &#125;) // 了解兼容性 // div.onclick = function(e) &#123; // e = e || window.event; // var target = e.target || e.srcElement; // console.log(target); // &#125; // 2. 了解 跟 this 有个非常相似的属性 currentTarget ie678不认识 &lt;/script&gt;&lt;/body&gt; 事件对象的兼容性事件对象本身的获取存在兼容问题： 标准浏览器中浏览器是给方法传递的参数，只需定义形参e就可以获取到 在 IE6 -&gt; 8 中，浏览器不会给方法传递参数，如果需要的话，需要到window.event中获取查找 解决方案 e = e || window.event 123456789101112&lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;script&gt; // 事件对象 var div = document.querySelector(&#x27;div&#x27;); div.onclick = function(e) &#123; // e = e || window.event; console.log(e); // 事件对象也有兼容性问题 ie678 通过 window.event 兼容性的写法 e = e || window.event; &#125;&lt;/body&gt; 事件委托 事件委托也称为事件代理，在 jQuery 里面称为事件委派 事件委托的原理 不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点 12345678910111213141516171819&lt;body&gt; &lt;ul&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点 var ul = document.querySelector(&#x27;ul&#x27;); ul.addEventListener(&#x27;click&#x27;, function(e) &#123; // alert(&#x27;知否知否，点我应有弹框在手！&#x27;); // e.target 这个可以得到我们点击的对象 e.target.style.backgroundColor = &#x27;pink&#x27;; // 点了谁，就让谁的style里面的backgroundColor颜色变为pink &#125;) &lt;/script&gt;&lt;/body&gt; 以上案例：给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。 常见的鼠标事件 鼠标事件 触发条件 onclick 鼠标点击左键触发 onmouseover 鼠标经过触发 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmousemove 鼠标移动触发 onmouseup 鼠标弹起触发 onmousedown 鼠标按下触发 禁止鼠标右键与鼠标选中 contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单 selectstart 禁止鼠标选中 1234567891011121314&lt;body&gt; &lt;h1&gt;我是一段不愿意分享的文字&lt;/h1&gt; &lt;script&gt; // 1. contextmenu 我们可以禁用右键菜单 document.addEventListener(&#x27;contextmenu&#x27;, function(e) &#123; e.preventDefault(); // 阻止默认行为 &#125;) // 2. 禁止选中文字 selectstart document.addEventListener(&#x27;selectstart&#x27;, function(e) &#123; e.preventDefault(); &#125;) &lt;/script&gt;&lt;/body&gt; 鼠标事件对象 event对象代表事件的状态，跟事件相关的一系列信息的集合 现阶段我们主要是用鼠标事件对象 MouseEvent 和键盘事件对象 KeyboardEvent。 鼠标事件对象 说明 e.clientX 返回鼠标相对于浏览器窗口可视区的X坐标 e.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标 e.pageX（重点） 返回鼠标相对于文档页面的X坐标 IE9+ 支持 e.pageY（重点） 返回鼠标相对于文档页面的Y坐标 IE9+ 支持 e.screenX 返回鼠标相对于电脑屏幕的X坐标 e.screenY 返回鼠标相对于电脑屏幕的Y坐标 123456789101112131415161718192021&lt;body&gt; &lt;script&gt; // 鼠标事件对象 MouseEvent document.addEventListener(&#x27;click&#x27;, function(e) &#123; // 1. client 鼠标在可视区的x和y坐标 console.log(e.clientX); console.log(e.clientY); console.log(&#x27;---------------------&#x27;); // 2. page 鼠标在页面文档的x和y坐标 console.log(e.pageX); console.log(e.pageY); console.log(&#x27;---------------------&#x27;); // 3. screen 鼠标在电脑屏幕的x和y坐标 console.log(e.screenX); console.log(e.screenY); &#125;) &lt;/script&gt;&lt;/body&gt; 常用的键盘事件 键盘事件 触发条件 onkeyup 某个键盘按键被松开时触发 onkeydown 某个键盘按键被按下时触发 onkeypress 某个键盘按键被按下时触发，但是它不识别功能键，比如 ctrl shift 箭头等 如果使用addEventListener 不需要加 on onkeypress 和前面2个的区别是，它不识别功能键，比如左右箭头，shift 等 三个事件的执行顺序是： keydown – keypress — keyup 1234567891011121314151617181920212223&lt;body&gt; &lt;script&gt; // 常用的键盘事件 //1. keyup 按键弹起的时候触发 // document.onkeyup = function() &#123; // console.log(&#x27;我弹起了&#x27;); // &#125; document.addEventListener(&#x27;keyup&#x27;, function() &#123; console.log(&#x27;我弹起了&#x27;); &#125;) //3. keypress 按键按下的时候触发 不能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener(&#x27;keypress&#x27;, function() &#123; console.log(&#x27;我按下了press&#x27;); &#125;) //2. keydown 按键按下的时候触发 能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener(&#x27;keydown&#x27;, function() &#123; console.log(&#x27;我按下了down&#x27;); &#125;) // 4. 三个事件的执行顺序 keydown -- keypress -- keyup &lt;/script&gt;&lt;/body&gt; 键盘对象属性 键盘事件对象 属性 说明 keyCode 返回该键值的ASCII值 onkeydown和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写。 在我们实际开发中，我们更多的使用keydown和keyup， 它能识别所有的键（包括功能键） Keypress 不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值 1234567891011121314151617181920&lt;body&gt; &lt;script&gt; // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值 // 1. 我们的keyup 和keydown事件不区分字母大小写 a 和 A 得到的都是65 // 2. 我们的keypress 事件 区分字母大小写 a 97 和 A 得到的是65 document.addEventListener(&#x27;keyup&#x27;, function(e) &#123; console.log(&#x27;up:&#x27; + e.keyCode); // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键 if (e.keyCode === 65) &#123; alert(&#x27;您按下的a键&#x27;); &#125; else &#123; alert(&#x27;您没有按下a键&#x27;) &#125; &#125;) document.addEventListener(&#x27;keypress&#x27;, function(e) &#123; console.log(&#x27;press:&#x27; + e.keyCode); &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"}]},{"title":"JavaScript基础之函数与作用域(二)","slug":"JavaScript基础之函数与作用域(二)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T08:10:03.522Z","comments":true,"path":"2022/04/24/JavaScript基础之函数与作用域(二)/","link":"","permalink":"http://example.com/2022/04/24/JavaScript%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F(%E4%BA%8C)/","excerpt":"","text":"函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。 函数的使用函数在使用时分为两步：声明函数和调用函数 ①声明函数1234//声明函数function 函数名()&#123; //函数体代码&#125; function 是声明函数的关键字,必须小写 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum ②调用函数12//调用函数函数名(); //通过调用函数名来执行函数体代码 调用的时候千万不要忘记添加小括号 口诀：函数不调用，自己不执行 注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。 函数的封装 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口 函数的参数形参和实参在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时，同样也需要传递相应的参数，这些参数被称为实参。 参数 说明 形参 形式上的参数 函数定义的时候 传递的参数 当前并不知道是什么 实参 实际上的参数 函数调用的时候 传递的参数 实参是传递给形参的 参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去 12345678// 带参数的函数声明function 函数名(形参1, 形参2 , 形参3...) &#123; // 可以定义任意多的参数，用逗号分隔 // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3...); 例如：利用函数求任意两个数的和 12345678// 声明函数function getSum(num1,num2)&#123; console.log(num1+num2)&#125;// 调用函数getSum(1,3) //4getSum(6，5) //11 函数调用的时候实参值是传递给形参的 形参简单理解为:不用声明的变量 实参和形参的多个参数之间用逗号(,)分隔， 形参和实参个数不匹配 参数个数 说明 实参个数等于形参个数 输出正确结果 实参个数多于形参个数 只取到形参的个数 实参个数小于形参个数 多的形参定义为undefined，结果为NaN 12345678function sum(num1, num2) &#123; console.log(num1 + num2);&#125;sum(100, 200); // 300，形参和实参个数相等，输出正确结果sum(100, 400, 500, 700); // 500，实参个数多于形参，只取到形参的个数sum(200); // 实参个数少于形参，多的形参定义为undefined，结果为NaN 注意：在JavaScript中，形参的默认值是undefined 小结 函数可以带参数也可以不带参数 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined 调用函数的时候，函数名括号里面的是实参 多个参数中间用逗号分隔 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配 函数的返回值return语句有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。 return 语句的语法格式如下： 1234567// 声明函数function 函数名（）&#123; ... return 需要返回的值;&#125;// 调用函数函数名(); // 此时调用函数就可以得到函数体内return 后面的值 在使用 return 语句时，函数会停止执行，并返回指定的值 如果函数没有 return ，返回的值是 undefined 1234567// 声明函数function sum()&#123; ... return 666;&#125;// 调用函数sum(); // 此时 sum 的值就等于666，因为 return 语句会把自身后面的值返回给调用者 return 终止函数return 语句之后的代码不被执行 1234567function add(num1，num2)&#123; //函数体 return num1 + num2; // 注意：return 后的代码不执行 alert(&#x27;我不会被执行，因为前面有 return&#x27;);&#125;var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值alert(resNum); // 27 return 的返回值return 只能返回一个值。如果用逗号隔开多个值，以最后一个为准 123456function add(num1，num2)&#123; //函数体 return num1,num2;&#125;var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值alert(resNum); // 6 小结函数都是有返回值的 如果有 return ，则返回 return 后面的值 如果没有 return，则返回 undefined 区别break、continue、return 的区别 break ： 结束当前循环体(如 for、while) continue ：跳出本次循环，继续执行下次循环(如for、while) return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码 练习1.利用函数求任意两个数的最大值 12345function getMax(num1, num2) &#123; return num1 &gt; num2 ? num1 : num2;&#125;console.log(getMax(1, 2));2console.log(getMax(11, 2));11 2.求数组 [5,2,99,101,67,77] 中的最大数值 12345678910111213//定义一个获取数组中最大数的函数function getMaxFromArr(numArray)&#123; var maxNum = 0; for(var i = 0; i &lt; numArray.length;i++)&#123; if(numArray[i]&gt;maxNum)&#123; maxNum = numArray[i]; &#125; &#125; return maxNum;&#125;var arrNum = [5,2,99,101,67,77];var maxN = getMaxFromArr(arrNum); //这个实参是个数组alert(&#x27;最大值为&#x27; + maxN); 3.创建一个函数，实现两个数之间的加减乘除运算，并将结果返回 123456789var a = parseFloat(prompt(&#x27;请输入第一个数&#x27;));var b = parseFloat(prompt(&#x27;请输入第二个数&#x27;));function count(a,b)&#123; var arr = [a + b, a - b, a * b, a / b]; return arr;&#125;var result = count(a,b);console.log(result) arguments的使用当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。 arguments存放的是传递过来的实参 arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点 ①：具有 length 属性 ②：按索引方式储存数据 ③：不具有数组的 push , pop 等方法 123456789// 函数声明function fn() &#123; console.log(arguments); //里面存储了所有传递过来的实参 console.log(arrguments.length); // 3 console.log(arrguments[2]); // 3&#125;// 函数调用fn(1,2,3); 例如：利用函数求任意个数的最大值 1234567891011 function maxValue() &#123; var max = arguments[0]; for (var i = 0; i &lt; arguments.length; i++) &#123; if (max &lt; arguments[i]) &#123; max = arguments[i]; &#125; &#125; return max;&#125;console.log(maxValue(2, 4, 5, 9)); // 9console.log(maxValue(12, 4, 9)); // 12 函数调用另外一个函数因为每个函数都是独立的代码块，用/于完成特殊任务，因此经常会用到函数相互调用的情况。具体演示在下面的函数练习中会有。 函数练习1.利用函数封装方式，翻转任意一个数组 123456789function reverse(arr) &#123; var newArr = []; for (var i = arr.length - 1; i &gt;= 0; i--) &#123; newArr[newArr.length] = arr[i]; &#125; return newArr;&#125;var arr1 = reverse([1, 3, 4, 6, 9]);console.log(arr1); 2.利用函数封装方式，对数组排序 – 冒泡排序 123456789101112function sort(arr) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; for (var j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; return arr;&#125; 3.输入一个年份，判断是否是闰年（闰年：能被4整除并且不能被100整数，或者能被400整除） 123456789function isRun(year) &#123; var flag = false; if (year % 4 === 0 &amp;&amp; year % 100 !== 0 || year % 400 === 0) &#123; flag = true; &#125; return flag;&#125;console.log(isRun(2010));console.log(isRun(2012)); 4.用户输入年份，输出当前年份2月份的天数，如果是闰年，则2月份是 29天， 如果是平年，则2月份是 28天 1234567891011121314151617function backDay() &#123; var year = prompt(&#x27;请您输入年份:&#x27;); if (isRun(year)) &#123; //调用函数需要加小括号 alert(&#x27;你输入的&#x27; + year + &#x27;是闰年，2月份有29天&#x27;); &#125; else &#123; alert(&#x27;您输入的&#x27; + year + &#x27;不是闰年，2月份有28天&#x27;); &#125;&#125;backDay();//判断是否是闰年的函数function isRun(year) &#123; var flag = false; if (year % 4 === 0 &amp;&amp; year % 100 !== 0 || year % 400 === 0) &#123; flag = true; &#125; return flag;&#125; 函数的两种声明方式自定义函数方式(命名函数)利用函数关键字 function 自定义函数方式。 123456// 声明定义方式function fn() &#123;...&#125;// 调用 fn(); 12345 因为有名字，所以也被称为命名函数 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面 函数表达式方式(匿名函数)利用函数表达式方式的写法如下： 12345// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function()&#123;...&#125;;// 调用的方式，函数调用必须写到函数体下面fn(); 因为函数没有名字，所以也称为匿名函数 这个fn 里面存储的是一个函数 函数调用的代码必须写到函数体后面 作用域通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。 JavaScript (ES6前) 中的作用域有两种： 全局作用域 局部作用域(函数作用域) 全局作用域作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件 局部（函数）作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域 JS 没有块级作用域 快作用域由 &#123;&#125; 包括 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码： 12345if(true)&#123; int num = 123; System.out.println(num); // 123&#125;System.out.println(num); // 报错 JS 中没有块级作用域(在ES6之前) 12345if(true)&#123; int num = 123; System.out.println(num); // 123&#125;System.out.println(num); // 123 变量的作用域在JavaScript中，根据作用域的不同，变量可以分为两种： 全局变量 局部变量 全局变量在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量） 全局变量在代码的任何位置都可以使用 在全局作用域下 var 声明的变量 是全局变量 特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用） 局部变量在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量） 局部变量只能在该函数内部使用 在函数内部 var 声明的变量是局部变量 函数的形参实际上就是局部变量 区别 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间 作用域链 只要是代码，就至少有一个作用域 写在函数内部的叫局部作用域 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链 12345678910// 作用域链: 内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构我们称为作用域链表var num = 10;funtion fn() &#123; //外部函数 var num = 20; function fun() &#123; //内部函数 console.log(num); // 20 ,一级一级访问 &#125;&#125; 作用域链：采取就近原则的方式来查找变量最终的值。 预解析首先来看几段代码和结果： 1234567891011121314151617181920212223242526console.log(num); // 结果是多少？//会报错 num is undefinedconsole.log(num); // 结果是多少？var num = 10; // undefined// 命名函数(自定义函数方式):若我们把函数调用放在函数声明上面fn(); //11function fn() &#123; console.log(&#x27;11&#x27;);&#125;// 匿名函数(函数表达式方式):若我们把函数调用放在函数声明上面fn();var fn = function() &#123; console.log(&#x27;22&#x27;); // 报错&#125;//相当于执行了以下代码var fn;fn(); //fn没赋值，没这个，报错var fn = function() &#123; console.log(&#x27;22&#x27;); //报错&#125; JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。 预解析：js引擎会把js里面所有的 var 还有 function 提升到当前作用域的最前面 代码执行：从上到下执行JS语句 预解析只会发生在通过 var 定义的变量和 function 上。学习预解析能够让我们知道为什么在变量声明之前访问变量的值是 undefined，为什么在函数声明之前就可以调用函数。 变量预解析(变量提升)变量预解析也叫做变量提升、函数提升 变量提升: 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升 12345678910console.log(num); // 结果是多少？var num = 10; // undefined//相当于执行了以下代码var num; // 变量声明提升到当前作用域最上面console.log(num);num = 10; // 变量的赋值不会提升 函数预解析(函数提升)函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。 1234fn(); //11function fn() &#123; console.log(&#x27;11&#x27;);&#125; 解决函数表达式声明调用问题对于函数表达式声明调用需要记住：函数表达式调用必须写在函数声明的下面 12345678910111213// 匿名函数(函数表达式方式):若我们把函数调用放在函数声明上面fn();var fn = function() &#123; console.log(&#x27;22&#x27;); // 报错&#125;//相当于执行了以下代码var fn;fn(); //fn没赋值，没这个，报错var fn = function() &#123; console.log(&#x27;22&#x27;); //报错&#125; 预解析练习预解析部分十分重要，可以通过下面4个练习来理解。 Pink老师的视频讲解预解析：https://www.bilibili.com/video/BV1Sy4y1C7ha?p=143 12345678// 练习1var num = 10;fun();function fun() &#123; console.log(num); //undefined var num = 20;&#125;// 最终结果是 undefined 上述代码相当于执行了以下操作 12345678var num;function fun() &#123; var num; console.log(num); num = 20;&#125;num = 10;fun(); 123456789// 练习2var num = 10;function fn()&#123; console.log(num); //undefined var num = 20; console.log(num); //20&#125;fn();// 最终结果是 undefined 20 上述代码相当于执行了以下操作 123456789var num;function fn()&#123; var num; console.log(num); var num = 20; console.log(num);&#125;num = 10;fn(); 12345678910// 练习3var a = 18;f1();function f1() &#123; var b = 9; console.log(a); console.log(b); var a = &#x27;123&#x27;;&#125; 上述代码相当于执行了以下操作 1234567891011var a;function f1() &#123; var b; var a b = 9; console.log(a); //undefined console.log(b); //9 a = &#x27;123&#x27;;&#125;a = 18;f1(); 12345678910111213// 练习4f1();console.log(c);console.log(b);console.log(a);function f1() &#123; var a = b = c = 9; // 相当于 var a = 9; b = 9;c = 9; b和c的前面没有var声明,当全局变量看 // 集体声明 var a = 9,b = 9,c = 9; console.log(a); console.log(b); console.log(c);&#125; 上述代码相当于执行了以下操作 1234567891011function f1() &#123; var a; a = b = c = 9; console.log(a); //9 console.log(b); //9 console.log(c); //9&#125;f1();console.log(c); //9console.log(b); //9console.log(a); //报错 a是局部变量","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript基础加高级总结 (全面)","slug":"JavaScript基础加高级总结 (全面)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T08:00:47.665Z","comments":true,"path":"2022/04/24/JavaScript基础加高级总结 (全面)/","link":"","permalink":"http://example.com/2022/04/24/JavaScript%E5%9F%BA%E7%A1%80%E5%8A%A0%E9%AB%98%E7%BA%A7%E6%80%BB%E7%BB%93%20(%E5%85%A8%E9%9D%A2)/","excerpt":"","text":"一、javaScript基础大总结1、数据类型相关知识点Ⅰ-基本(值)类型 String: 任意字符串 Number: 任意的数字 boolean: true/false undefined: undefined null: null –&gt;使用typeof时返回object symbol (ECMAScript 2016新增)。 –&gt;Symbol 是 基本数据类型 的一种，Symbol 对象是 Symbol原始值的封装 (en-US) 。 bigint， –&gt;BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数。 加上下方的 [ 对象 ] 类型,目前 javaScript 有八种数据类型 Ⅱ-对象(引用)类型 Object: 任意对象 Function: 一种特别的对象(可以执行) –内部包含可运行的代码 Array: 一种特别的对象(key为数值下标属性, 内部数据是有序的) Ⅲ-判断方法①* typeof* typeof 操作符返回一个字符串，表示未经计算的操作数的类型。 可以判断: undefined/ 数值 / 字符串 / 布尔值 / function 不能判断: null与object object与array 注意: 运行console.log(typeof undefined)时,得到的的也是一个字符串,同时为小写!!–&gt; &#39;undefined&#39; 代码示例 1234567891011121314151617 // typeof返回数据类型的字符串表达 var a //注意:typeof返回的是字符串 console.log(a, typeof a, typeof a===&#x27;undefined&#x27;,a===undefined ) // undefined &#x27;undefined&#x27; true true console.log(undefined === &#x27;undefined&#x27;) //false a = 4 console.log(typeof a===&#x27;number&#x27;) //true a = &#x27;hongjilin&#x27; console.log(typeof a===&#x27;string&#x27;) //true console.log(typeof a===&#x27;String&#x27;) //false --&gt;注意,返回的类型为小写 a = true console.log(typeof a===&#x27;boolean&#x27;) //true a = null console.log(typeof a, a===null) // &#x27;object&#x27; truelet b=&#123;&#125; console.log(typeof b,typeof null, &#x27;-------&#x27;) // &#x27;object&#x27; &#x27;object&#x27; --&gt;所以Typeof不能判断null与object ②*instanceof*(判断实例方法) 专门判断对象的具体类型 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 代码示例: 1234567891011121314151617181920 var b1 = &#123; b2: [1, &#x27;abc&#x27;, console.log],//可以简化成 b3:()=&gt;()=&gt; &#x27;hongjilin&#x27; --&gt;高阶函数相关知识 b3: function () &#123; return () =&gt;&#123; return &#x27;hongjilin&#x27;&#125; &#125; &#125;/**使用instanceof进行对象判断*/ console.log(b1 instanceof Object, b1 instanceof Array) // true false console.log(b1.b2 instanceof Array, b1.b2 instanceof Object) // true true console.log(b1.b3 instanceof Function, b1.b3 instanceof Object) // true true /**使用typeof进行对象中某属性的判断*/console.log(typeof b1.b2, typeof null) // &#x27;object&#x27; &#x27;object&#x27; console.log(typeof b1.b3===&#x27;function&#x27;) // true console.log(typeof b1.b2[2]===&#x27;function&#x27;) //true /**调用对象与数组中某函数示例*/ b1.b2[2](&#x27;调用console.log打印hongjilin&#x27;) //调用console.log打印hongjilin console.log(b1.b3()()) // hongjilin ③*===* 具体可以看 MDN的JavaScript中的相等性判断 可以判断: undefined, null 简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false ) Ⅳ-相关问题引出① undefined与null的区别? undefined代表定义未赋值 nulll定义并赋值了, 只是值为null 代码示例 1234var aconsole.log(a) // undefineda = nullconsole.log(a) // null ② 什么时候给变量赋值为null呢? 初始赋值, 表明将要赋值为对象,可以用做约定俗成的占位符 结束前, 让对象成为垃圾对象(被垃圾回收器回收) 代码示例 123456//起始,可以用做约定俗成的占位符var b = null // 初始赋值为null, 表明将要赋值为对象//确定对象就赋值b = [&#x27;atguigu&#x27;, 12]//最后在不使用的时候,将其引用置空,就可以释放b这个对象占用的内存 ---当没有引用指向它的对象称为垃圾对象b = null // 让b指向的对象成为垃圾对象(被垃圾回收器回收) ③ 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值(对象类型) Ⅴ-补充知识点:①字符串对比*&gt;、&lt;以及charCodeAt()*方法 Javascript字符串在进行大于(小于)比较时，会根据第一个不同的字符的ascii值码进行比较，当数字(number)与字符串(string)进行比较大小时，会强制的将数字(number)转换成字符串(string)然后再进行比较 1234567(function()&#123; console.log(&#x27;13&#x27;&gt;&#x27;3&#x27;); // 输出：false console.log(5&gt;&#x27;6&#x27;); // 输出： false console.log(&#x27;d&#x27;&gt;&#x27;ABDC&#x27;) // 输出： true console.log(19&gt;&#x27;ssf&#x27;) // 输出 false console.log(&#x27;A&#x27;&gt;&#x27;abcdef&#x27;) // 输出 false&#125;)() 手动转换为ascii后相减,用正负数表示大小 1sorter=&#123;(a:string,b:string)=&gt; a.charCodeAt()-b.charCodeAt()&#125; 2、数据,变量, 内存的理解Ⅰ-什么是数据? 存储在内存中代表特定信息的’东西’, 本质上是0101… 数据的特点: 可传递, 可运算 –&gt;let a=0;b=a 🔜体现可传递 一切皆数据 内存中所有操作的目标: 数据 算术运算 逻辑运算 赋值 运行函数 Ⅱ-什么是内存? 内存条通电后产生的可储存数据的空间(临时的) 内存产生和死亡: 内存条(电路版)==&gt;通电==&gt;产生内存空间==&gt;存储数据==&gt;处理数据==&gt;断电==&gt;内存空间和数据都消失 一块小内存的2个数据 内部存储的数据 地址值 内存分类 栈: 全局变量/局部变量 堆: 对象 Ⅲ-什么是变量? 可变化的量, 由变量名和变量值组成 每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据 ps:变量obj.xx–&gt;.相当于拿着地址找到后面对应的内存,所以只有当我变量中存的是地址,才可以用. Ⅳ-内存,数据, 变量三者之间的关系 内存用来存储数据的空间 变量是内存的标识 Ⅴ-相关问题引出① 关于赋值和内存的问题 let a = xxx, a内存中到底保存的是什么? xxx是基本数据, 保存的就是这个数据 xxx是对象, 保存的是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) ② 关于引用变量赋值问题 2个引用变量指向同一个对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一引用变量依然指向前一个对象 代码示例: 12345678910111213 let a = &#123;age: 12&#125;//此时是将a指向的地址值赋值给B,所以B此时也指向&#123;age:12&#125;这个内存 let b = a//此时重新创建了一个内存并让a指向它,所以此处a指向的是&#123;name:&#x27;hong&#x27;&#125;,而b指向仍是刚开始的指向&#123;age:12&#125; a = &#123;name: &#x27;hong&#x27;&#125;//此时a与b指向的内存已经不一样了,所以修改互不影响 b.age = 14 console.log(b.age, a.name, a.age) // 14 hong undefined //此时其实已经重新创建了一个内存&#123;age:15&#125;,并且将其地址赋值覆盖给a//实际上传进来的obj也是拿着其key对应的地址值找内存,此时 const fn2=(obj) =&gt; obj = &#123;age: 15&#125; fn2(a) console.log(a.age) //15 ③ 在js调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本/地址值)传递 所以实际上传进function中的参数也是拿着其存着的地址值找内存 12345//传进来的obj存储的是a中存的地址值,所以obj==a(因为他们地址值一致,指向一致) let a = &#123;name: &#x27;hong&#x27;&#125; const fn2=(obj) =&gt; obj = &#123;age: 15&#125; fn2(a) console.log(a.age) //15 理解2: 可能是值传递, 也可能是引用传递(地址值) ④ JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象==&gt;垃圾回收器回收 123456 var a = 3 var obj = &#123;name:&quot;hong&quot;&#125; obj = undefined ||null //此时,obj没有被释放,但是之前声明的`&#123;name:&quot;hong&quot;&#125;`由于没有人指向它,会在后面你某个时刻被垃圾回收器回收function fn () &#123; var b = &#123;&#125;&#125; fn() // b是自动释放, b所指向的对象是在后面的某个时刻由垃圾回收器回收 3、对象Ⅰ-对象的概念① 什么是对象? 多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中的一个事物 ② 为什么要用对象? 统一管理多个数据 ③ 对象的组成 属性: 属性名(字符串)和属性值(任意)组成 方法: 一种特别的属性(属性值是函数) Ⅱ-如何访问对象内部数据? .属性名: 编码简单, 有时不能用 [&#39;属性名&#39;]: 编码麻烦, 能通用 Ⅲ-什么时候必须使用[&#39;属性名&#39;]的方式? 属性名包含特殊字符: - 空格 属性名不确定 123456789101112var p = &#123;&#125;//1. 给p对象添加一个属性: content type: text/json// p.content-type = &#x27;text/json&#x27; //不能用p[&#x27;content-type&#x27;] = &#x27;text/json&#x27;console.log(p[&#x27;content-type&#x27;])//2. 属性名不确定var propName = &#x27;myAge&#x27;var value = 18// p.propName = value //不能用p[propName] = valueconsole.log(p[propName]) 4、函数Ⅰ-函数的概念① 什么是函数 实现特定功能的n条语句的封装体 只有函数是可以执行的, 其它类型的数据不能执行 ② 为什么要用函数? 提高代码复用 便于阅读交流 ③ 如何定义函数? 函数声明 表达式 123function fn1 () &#123; console.log(&#x27;fn1()&#x27; )//函数声明 const fn2 = ()=&gt; console.log(&#x27;fn2()&#x27;) //表达式 Ⅱ-如何调用(执行)函数 test(): 直接调用 obj.test(): 通过对象调用 new test(): new调用 test.call/apply(obj): 临时让test成为obj的方法进行调用 代码示例 123456789var obj = &#123;&#125;//此处不能使用箭头函数,因为箭头函数会改变this指向function test2 () &#123; this.xxx = &#x27;hongjilin&#x27;&#125;// obj.test2() 不能直接, 根本就没有test2.call(obj) // 可以让一个函数成为指定任意对象的方法进行调用console.log(obj.xxx) Ⅲ-回调函数① 什么函数才是回调函数? 你定义的 你没有调 但最终它执行了(在某个时刻或某个条件下) ② 常见的回调函数? dom事件回调函数 ==&gt;发生事件的dom元素 定时器回调函数 ===&gt;window ajax请求回调函数(后面讲) 生命周期回调函数(后面讲) 1234 // dom事件回调函数document.getElementById(&#x27;btn&#x27;).onclick = function () &#123;alert(this.innerHTML)&#125;// 定时器回调函数setTimeout(function () &#123; alert(&#x27;到点了&#x27;+this)&#125;, 2000) Ⅳ-IIFE (自调用函数) 全称: Immediately-Invoked Function Expression 自调用函数 作用: 隐藏实现 不会污染外部(一般指全局)命名空间 用它来编码js模块 代码示例 123456789101112131415 (function () &#123; //匿名函数自调用 var a = 3 console.log(a + 3) &#125;)() console.log(a) // a is not defined //此处前方为何要一个`;`--&gt;因为自调用函数外部有一个()包裹,可能与前方以()结尾的代码被一起认为是函数调用 //不加分号可能会被认为这样 console.log(a)(IIFE) ;(function () &#123;//不会污染外部(全局)命名空间--&gt;举例 let a = 1; function test () &#123; console.log(++a) &#125; //声明一个局部函数test window.$ = function () &#123; return &#123;test: test&#125; &#125;// 向外暴露一个全局函数 &#125;)()test () //test is not defined $().test() // 1. $是一个函数 2. $执行后返回的是一个对象 Ⅴ-函数中的this① this是什么? 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 ② 如何确定this的值? test(): window p.test(): p new test(): 新创建的对象 p.call(obj): obj ③ 代码举例详解 12345678910111213141516171819202122232425262728293031 function Person(color) &#123; console.log(this) this.color = color; this.getColor = function () &#123; console.log(this) return this.color; &#125;; this.setColor = function (color) &#123; console.log(this) this.color = color; &#125;; &#125; Person(&quot;red&quot;); //this是谁? window const p = new Person(&quot;yello&quot;); //this是谁? p p.getColor(); //this是谁? p const obj = &#123;&#125;; //调用call会改变this指向--&gt;让我的p函数成为`obj`的临时方法进行调用 p.setColor.call(obj, &quot;black&quot;); //this是谁? obj const test = p.setColor; test(); //this是谁? window --&gt;因为直接调用了 function fun1() &#123; function fun2() &#123; console.log(this); &#125; fun2(); //this是谁? window &#125;fun1();//调用fun1 5、关于语句分号 js一条语句的后面可以不加分号 是否加分号是编码风格问题, 没有应该不应该，只有你自己喜欢不喜欢 在下面2种情况下不加分号会有问题 小括号开头的前一条语句 中方括号开头的前一条语句 解决办法: 在行首加分号 强有力的例子: vue.js库 知乎热议: https://www.zhihu.com/question/20298345 二、函数高级1、原型与原型链Ⅰ-原型 [prototype] 函数的prototype属性 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象) 原型对象中有一个属性constructor, 它指向函数对象 给原型对象添加属性(一般都是方法) 作用: 函数的所有实例对象自动拥有原型中的属性(方法) 代码示例 12345678910111213// 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)console.log(Date.prototype, typeof Date.prototype)function Fun () &#123; &#125;console.log(Fun.prototype) // 默认指向一个Object空对象(没有我们的属性)// 原型对象中有一个属性constructor, 它指向函数对象console.log(Date.prototype.constructor===Date)console.log(Fun.prototype.constructor===Fun)//给原型对象添加属性(一般是方法) ===&gt;实例对象可以访问Fun.prototype.test = function () &#123; console.log(&#x27;test()&#x27;) &#125;var fun = new Fun()fun.test() Ⅱ-显式原型与隐式原型 每个函数function都有一个prototype，即显式原型(属性) 每个实例对象都有一个[__ proto __]，可称为隐式原型(属性) 对象的隐式原型的值为其对应构造函数的显式原型的值 内存结构 总结: 函数的[prototype]属性: 在定义函数时自动添加的, 默认值是一个空Object对象 对象的[__ proto __]属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前) 代码示例: 123456789101112131415161718//定义构造函数function Fn() &#123; // 内部默认执行语句: this.prototype = &#123;&#125; &#125;// 1. 每个函数function都有一个prototype，即显式原型属性, 默认指向一个空的Object对象console.log(Fn.prototype)// 2. 每个实例对象都有一个__proto__，可称为隐式原型//创建实例对象var fn = new Fn() // 内部默认执行语句: this.__proto__ = Fn.prototypeconsole.log(fn.__proto__)// 3. 对象的隐式原型的值为其对应构造函数的显式原型的值console.log(Fn.prototype===fn.__proto__) // true//给原型添加方法Fn.prototype.test = function () &#123; console.log(&#x27;test()&#x27;)&#125;//通过实例调用原型的方法fn.test() Ⅲ-原型链① 原型链 原型链 访问一个对象的属性时， 先在自身属性中查找，找到返回 如果没有, 再沿着[__ proto __]这条链向上查找, 找到返回 如果最终没找到, 返回undefined 别名: 隐式原型链 作用: 查找对象的属性(方法) ②构造函数/原型/实例对象的关系(图解) ``` var o1 = new Object(); var o2 = {};12345![image-20210714212928432](https://gitee.com/hongjilin/hongs-study-notes/raw/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0/A_JavaScript%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210714212928432.png)1. ``` function Foo()&#123; &#125; ps:所有函数的[__ proto __]都是一样的 ③ 属性问题 读取对象的属性值时: 会自动到原型链中查找 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上 代码示例 123456789101112131415161718192021222324function Fn() &#123; &#125;Fn.prototype.a = &#x27;xxx&#x27;var fn1 = new Fn()console.log(fn1.a, fn1) //xxx Fn&#123;&#125;var fn2 = new Fn()fn2.a = &#x27;yyy&#x27;console.log(fn1.a, fn2.a, fn2) //xxx yyy Fn&#123;a: &quot;yyy&quot;&#125;function Person(name, age) &#123; this.name = name this.age = age&#125;Person.prototype.setName = function (name) &#123; this.name = name&#125;var p1 = new Person(&#x27;Tom&#x27;, 12)p1.setName(&#x27;Bob&#x27;)console.log(p1) //Person &#123;name: &quot;Bob&quot;, age: 12&#125;var p2 = new Person(&#x27;Jack&#x27;, 12)p2.setName(&#x27;Cat&#x27;)console.log(p2) //Person &#123;name: &quot;Cat&quot;, age: 12&#125;console.log(p1.__proto__===p2.__proto__) // true --&gt;所以方法一般定义在原型中 Ⅳ-instanceof instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 123456789101112131415161718/*案例1 */function Foo() &#123; &#125;var f1 = new Foo()console.log(f1 instanceof Foo) // trueconsole.log(f1 instanceof Object) // true/*案例2 */console.log(Object instanceof Function) // trueconsole.log(Object instanceof Object) // trueconsole.log(Function instanceof Function) // trueconsole.log(Function instanceof Object) // truefunction Foo() &#123;&#125;console.log(Object instanceof Foo) // false Ⅴ-相关面试题 测试题1: 123456789/*测试题1 */function A () &#123;&#125;A.prototype.n = 1let b = new A()A.prototype = &#123; n: 2, m: 3&#125;let c = new A()console.log(b.n, b.m, c.n, c.m) // 1 undefined 2 3 测试题2:原理看②构造函数/原型/实例对象的关系(图解) 1234567891011121314151617181920/* 测试题2 */function F ()&#123;&#125;Object.prototype.a = function()&#123; console.log(&#x27;a()&#x27;)&#125;Function.prototype.b = function()&#123; console.log(&#x27;b()&#x27;)&#125;let f = new F()f.a() //a()f.b() //f.b is not a function --&gt;找不到F.a() //a()F.b() //b()console.log(f)console.log(Object.prototype)console.log(Function.prototype) 结果图例 2、执行上下文与执行上下文栈 当代码在 JavaScript 中运行时，执行代码的环境非常重要，并将概括为以下几点： 全局代码——第一次执行代码的默认环境。 函数代码——当执行流进入函数体时。 (…) —— 我们当作 执行上下文 是当前代码执行的一个环境与范围。 换句话说，当我们启动程序时，我们从全局执行上下文中开始。一些变量是在全局执行上下文中声明的。我们称之为全局变量。当程序调用一个函数时，会发生什么? 以下几个步骤： JavaScript 创建一个新的执行上下文，我们叫作本地执行上下文。 这个本地执行上下文将有它自己的一组变量，这些变量将是这个执行上下文的本地变量。 新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。 函数什么时候结束?当它遇到一个 return 语句或一个结束括号}。 当一个函数结束时，会发生以下情况: 这个本地执行上下文从执行堆栈中弹出。 函数将返回值返回调用上下文。调用上下文是调用这个本地的执行上下文，它可以是全局执行上下文，也可以是另外一个本地的执行上下文。这取决于调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有 return 语句，则返回 undefined。 这个本地执行上下文被销毁，销毁是很重要，这个本地执行上下文中声明的所有变量都将被删除，不在有变量，这个就是为什么 称为本地执行上下文中自有的变量。 此图出于CSDN的Free Joe Ⅰ-变量提升与函数提升 变量声明提升 通过var定义(声明)的变量, 在定义语句之前就可以访问到 值: undefined 函数声明提升 通过function声明的函数, 在之前就可以直接调用 值: 函数定义(对象) 引出一个问题: 变量提升和函数提升是如何产生的? 12345678910111213141516/* 面试题 : 输出 undefined */ var a = 3 function fn () &#123; console.log(a) var a = 4 //变量提升 &#125; fn() //undefined&#x27;--------------------------------------------&#x27; console.log(b) //undefined 变量提升 fn2() //可调用 函数提升 // fn3() //不能 变量提升 var b = 3 function fn2() &#123; console.log(&#x27;fn2()&#x27;) &#125; var fn3 = function () &#123; console.log(&#x27;fn3()&#x27;) &#125; Ⅱ-执行上下文 代码分类(位置) 全局代码 函数(局部)代码 全局执行上下文 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 var定义的全局变量==&gt;undefined, 添加为window的属性 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 this==&gt;赋值(window) 开始执行全局代码 函数执行上下文 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中) 对局部数据进行预处理 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 –&gt;不懂的同学看这里 var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 开始执行函数体代码 Ⅲ-执行上下文栈 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)–&gt;所以栈底百分百是[window] 在函数执行上下文创建后, 将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移除(出栈) 当所有的代码执行完后, 栈中只剩下window 上下文栈数==函数调用数+1 1234567891011//1. 进入全局执行上下文var a = 10var bar = function (x) &#123; var b = 5 foo(x + b) //3. 进入foo执行上下文 &#125;var foo = function (y) &#123; var c = 5 console.log(a + c + y)&#125;bar(10) //2. 进入bar函数执行上下文 此处用一个动态图来展示: 举个栗子: 123456789101112131415161718192021222324252627//栗子&lt;!--1. 依次输出什么?gb: undefinedfb: 1fb: 2fb: 3fe: 3fe: 2fe: 1ge: 12. 整个过程中产生了几个执行上下文? 5--&gt;&lt;script type=&quot;text/javascript&quot;&gt;console.log(&#x27;gb: &#x27;+ i)var i = 1foo(1)function foo(i) &#123; if (i == 4) &#123; return &#125; console.log(&#x27;fb:&#x27; + i) foo(i + 1) //递归调用: 在函数内部调用自己 console.log(&#x27;fe:&#x27; + i) //出栈 所以会 3 2 1这样的结果&#125;console.log(&#x27;ge: &#x27; + i)&lt;/script&gt; Ⅳ-相关面试题 123456789101112131415161718192021222324252627函数提升优先级高于变量提升,且不会被变量声明覆盖,但是会被变量赋值覆盖/*测试题1: 先执行变量提升, 再执行函数提升*/function a() &#123;&#125;var aconsole.log(typeof a) // &#x27;function&#x27;/*测试题2:*/if (!(b in window)) &#123; var b = 1&#125;console.log(b) // undefined/*测试题3:*/var c = 1function c(c) &#123; console.log(c) var c = 3 //与此行无关&#125;c(2) // 报错 c is not a function 3、作用域与作用域链Ⅰ-作用域 理解 就是一块”地盘”, 一个代码段所在的区域 它是静态的(相对于上下文对象), 在编写代码时就确定了 分类 全局作用域 函数作用域 没有块作用域(ES6有了) –&gt;(java语言也有) 作用 隔离变量，不同作用域下同名变量不会有冲突 1234567891011121314151617/* //没块作用域 if(true) &#123; var c = 3 &#125; console.log(c) */ var a = 10, b = 20 function fn(x) &#123; var a = 100, c = 300; console.log(&#x27;fn()&#x27;, a, b, c, x) //100 20 300 10 function bar(x) &#123; var a = 1000, d = 400 console.log(&#x27;bar()&#x27;, a, b, c, d, x) &#125; bar(100)//1000 20 300 400 100 bar(200)//1000 20 300 400 200 &#125; fn(10) Ⅱ-作用域与执行上下文的区别与联系 区别1: 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建 函数执行上下文是在调用函数时, 函数体代码执行之前创建 区别2: 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放 联系: 执行上下文(对象)是从属于所在的作用域 全局上下文环境==&gt;全局作用域 函数上下文环境==&gt;对应的函数使用域 Ⅲ-作用域链 理解 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外) 查找变量时就是沿着作用域链来查找的 查找一个变量的查找规则 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常 12345678910111213var a = 1 function fn1() &#123; var b = 2 function fn2() &#123; var c = 3 console.log(c) console.log(b) console.log(a) console.log(d) &#125; fn2() &#125; fn1() Ⅳ-相关面试题① 作用域在函数定义时就已经确定了。而不是在函数调用时 作用域1:作用域在函数定义时就已经确定了。而不是在函数调用时 1234567var x = 10;function fn() &#123; console.log(x); &#125;function show(f) &#123; var x = 20; f();&#125;show(fn); //输出10 ② 对象变量不能产生局部作用域 123456789101112var fn = function () &#123; console.log(fn)&#125;fn()var obj = &#123; //对象变量不能产生局部作用域,所以会找到全局去,导致报错 fn2: function () &#123; console.log(fn2) //console.log(this.fn2) &#125;&#125;obj.fn2() 4、闭包预备知识点梳理 在进入闭包之前,你要确保上面知识点你能掌握.你不确定 ? 噢好吧,那你就跟着我看下这部分梳理(如果懂得直接跳过即可) Ⅰ- 举个栗子分析执行上下文 在讨论闭包之前，让我们看下下方的代码(建议先只看代码自己头脑风暴再看笔记中的描述),也算是对上面知识点的梳理回顾： 12345671: let a = 32: function addTwo(x) &#123;3: let ret = x + 24: return ret5: &#125;6: let b = addTwo(a)7: console.log(b) 为了理解 JavaScript 引擎是如何工作的，让我们详细分析一下： 在第 1 行，我们在全局执行上下文中声明了一个新变量 a，并将赋值为 3。 接下来就变得棘手了，第 2 行到第 5 行实际上是在一起的。这里发生了什么? 我们在全局执行上下文中声明了一个名为addTwo的新变量,我们给它分配了什么? –&gt;一个函数定义。 两个括号{}之间的任何内容都被分配给addTwo，函数内部的代码没有被求值，没有被执行，只是存储在一个变量中以备将来使用。 现在我们在第 6 行。 它看起来很简单，但是这里有很多东西需要拆开分析。首先，我们在全局执行上下文中声明一个新变量，并将其标记为[b]，变量一经声明，其值即为 undefined。 接下来，仍然在第 6 行，我们看到一个赋值操作符。我们准备给变量b赋一个新值，接下来我们看到一个函数被调用。当您看到一个变量后面跟着一个圆括号(…)时，这就是调用函数的信号，接着，每个函数都返回一些东西(值、对象或 undefined)，无论从函数返回什么，都将赋值给变量b。 但是首先我们需要调用标记为addTwo的函数。JavaScript 将在其全局执行上下文内存中查找名为addTwo的变量。噢，它找到了一个，它是在[步骤 2(或第 2 - 5 行)中定义]的。变量[addTwo]包含一个函数定义。 注意:变量[a]作为参数传递给函数。 JavaScript 在全局执行上下文内存中搜索变量a，找到它，发现它的值是 3，并将数字 3 作为参数传递给函数，准备好执行函数。 现在执行上下文将切换,创建了一个新的本地执行上下文，我们将其命名为[“addTwo 执行上下文”，执行上下文被推送到调用堆栈上。在 addTwo 执行上下文中，我们要做的第一件事是什么? 你可能会说，“在 addTwo 执行上下文中声明了一个新的变量 ret”，这是不对的。 正确的答案是:我们需要先看函数的参数。在 addTwo 执行上下文中声明一个新的变量[x]，因为值 3 是作为参数传递的，所以变量 x 被赋值为 3。 下一步才是在 addTwo 执行上下文中声明一个新的变量ret。它的值被设置为 undefined(第三行)。 仍然是第 3 行，需要执行一个相加操作。 首先我们需要x的值，JavaScript 会寻找一个变量x，它会首先在addTwo执行上下文中寻找，找到了一个值为 3。第二个操作数是数字 2。两个相加结果为 5 就被分配给变量ret。 第 4 行，我们返回变量ret的内容，在 addTwo 执行上下文中查找，找到值为 5，返回，函数结束。 第 4 - 5 行，函数结束。 addTwo 执行上下文被销毁，变量x和ret被消去了，它们已经不存在了。addTwo 执行上下文从调用堆栈中弹出，返回值返回给调用上下文，在这种情况下，调用上下文是全局执行上下文，因为函数addTwo 是从全局执行上下文调用的。 现在我们继续第 4 步的内容，返回值 5 被分配给变量b，此时实际上程序仍然在第 6 行(盗梦空间既视感) 在第 7 行，b的值 5 被打印到控制台了。 对于一个非常简单的程序，这是一个非常冗长的解释，我们甚至还没有涉及闭包。但肯定会涉及的，不过首先我们得绕一两个弯。 Ⅱ-举个栗子分析词法作用域 这里想说明，我们在函数执行上下文中有变量，在全局执行上下文中有变量。JavaScript 的一个复杂之处在于它如何查找变量，如果在函数执行上下文中找不到变量，它将在调用上下文中寻找它，如果在它的调用上下文中没有找到，就一直往上一级，直到它在全局执行上下文中查找为止。(如果最后找不到，它就是 undefined)。 12345671: let val1 = 22: function multiplyThis(n) &#123;3: let ret = n * val14: return ret5: &#125;6: let multiplied = multiplyThis(6)7: console.log(&#x27;example of scope:&#x27;, multiplied) 下面列出向个步骤来解释一下（如果你已经熟悉了，请跳过）： 在全局执行上下文中声明一个新的变量val1，并将其赋值为 2。 行 2 - 5，声明一个新的变量 multiplyThis，并给它分配一个函数定义。 第六行，声明一个在全局执行上下文 multiplied 新变量。 从全局执行上下文内存中查找变量multiplyThis，并将其作为函数执行，传递数字 6 作为参数。 新函数调用(创建新执行上下文），创建一个新的 multiplyThis 函数执行上下文。 在 multiplyThis 执行上下文中，声明一个变量 n 并将其赋值为 6 –&gt;声明后才会进入函数体内部执行 执行函数回到第 3 行。 在multiplyThis执行上下文中，声明一个变量ret。 继续第 3 行。对两个操作数 n 和 val1 进行乘法运算.在 1multiplyThis 执行上下文中查找变量 1n 。 我们在步骤 6 中声明了它,它的内容是数字 6。在multiplyThis执行上下文中查找变量val1。 multiplyThis执行上下文没有一个标记为 val1 的变量。我们向调用上下文查找，调用上下文是全局执行上下文，在全局执行上下文中寻找 [val1]。哦，是的、在那儿，它在步骤 1 中定义，数值是 2。 继续第 3 行。将两个操作数相乘并将其赋值给ret变量，6 * 2 = 12，ret 现在值为 12。 返回ret变量，销毁multiplyThis执行上下文及其变量 ret 和 n 。变量 val1 没有被销毁，因为它是全局执行上下文的一部分。 回到第 6 行。在调用上下文中，数字 12 赋值给 multiplied 的变量。 最后在第 7 行，我们在控制台中打印 multiplied 变量的值 在这个例子中，我们需要记住一个函数可以访问在它的调用上下文中定义的变量，这个就是词法作用域（Lexical scope）。 Ⅲ- 返回函数的函数[高阶函数] 在第一个例子中，函数addTwo返回一个数字。请记住，函数可以返回任何东西。让我们看一个返回函数的函数示例，因为这对于下方理解闭包非常重要。看栗子： 12345678910111: let val = 72: function createAdder() &#123;3: function addNumbers(a, b) &#123;4: let ret = a + b5: return ret6: &#125;7: return addNumbers8: &#125;9: let adder = createAdder()10: let sum = adder(val, 8)11: console.log(&#x27;example of function returning a function: &#x27;, sum) 让我们回到分步分解： 第一行。我们在全局执行上下文中声明一个变量val并赋值为 7。 行 2 - 8。我们在全局执行上下文中声明了一个名为 createAdder 的变量，并为其分配了一个函数定义。 内部的第 3 至 7 行描述了上述函数定义，和以前一样，在这一点上，我们没有直接讨论这个函数。我们只是将函数定义存储到[createAdder]变量中。 第 9 行。 我们在全局执行上下文中声明了一个名为 adder 的新变量，暂时，值为 undefined 我们看到括号()，我们需要执行或调用一个函数，查找全局执行上下文的内存并查找名为createAdder 的变量，它是在步骤 2 中创建的。好吧，我们调用它。 调用函数时，执行到第 2 行。 创建一个新的createAdder执行上下文。我们可以在createAdder的执行上下文中创建自有变量。js 引擎将createAdder的上下文添加到调用堆栈。这个函数没有参数，让我们直接跳到它的主体部分. 第 3 - 6 行(执行到主体函数中)。 我们有一个新的函数声明，我们在createAdder执行上下文中创建一个变量 addNumbers。这很重要，addnumber只存在于createAdder执行上下文中。我们将函数定义存储在名为 addNumbers 的自有变量中。 在第 7 行，我们返回变量addNumbers的内容。js 引擎查找一个名为addNumbers的变量并找到它，这是一个函数定义。好的，函数可以返回任何东西，包括函数定义。我们返addNumbers的定义。第 4 行和第 5 行括号之间的内容构成该函数定义。 [return addNumbers]时，createAdder执行上下文将被销毁。addNumbers 变量不再存在。但addNumbers函数定义仍然存在，因为它返回并赋值给了 adder 变量。 此处很重要!!!此时的[adder=createAdder()]实际上它的值是[addNumbers]的函数定义而不是[createAdder]了,adder现在是一个匿名函数–这里有点绕,要确定理解 第 10 行。我们在全局执行上下文中定义了一个新的变量 sum，先赋值为 undefined; 接下来我们需要执行一个函数。哪个函数? 是名为adder变量中定义的函数。我们在全局执行上下文中查找它，果然找到了它，这个函数有两个参数。 让我们查找这两个参数，第一个是我们在步骤 1 中定义的变量val，它表示数字 7，第二个是数字 8。 现在我们要执行这个函数，函数定义概述在第 3-5 行，因为这个函数是匿名，为了方便理解，我们暂且叫它adder吧。这时创建一个adder函数执行上下文，在adder执行上下文中创建了两个新变量 a 和 b。它们分别被赋值为 7 和 8，因为这些是我们在上一步传递给函数的参数。 执行回到第 4 行。 在adder执行上下文中声明了一个名为ret的新变量, 将变量a的内容和变量b的内容相加得 15 并赋给 ret 变量。 ret变量从该函数返回。这个匿名函数执行上下文被销毁，从调用堆栈中删除，变量a、b和ret不再存在。 返回值被分配给我们在步骤 9 中定义的sum变量。 我们将sum的值打印到控制台。 如预期，控制台将打印 15。我们在这里确实经历了很多困难，我想在这里说明几点。首先，函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。其次，每次调用函数时，都会(临时)创建一个本地执行上下文。当函数完成时，执行上下文将消失。函数在遇到 return 或右括号}时执行完成。 高阶函数是什么? 所谓高阶函数，就是一个函数就可以接收另一个函数作为参数，或者是返回一个函数–&gt;常见的高阶函数有map、reduce、filter、sort等 123456var ADD =function add(a) &#123;return function(b) &#123;return a+b&#125;&#125;调用：ADD(2)(3)即可获得结果 map ```//map接受一个函数作为参数，不改变原来的数组，只是返回一个全新的数组var arr = [1,2,3,4,5]var arr1 = arr.map(item =&gt; item = 2)//arr 输出[1,2,3,4,5]//arr1 输出[2,2,2,2,2]1234567891. reduce- ``` // reduce也是返回一个全新的数组。reduce接受一个函数作为参数，这个函数要有两个形参，代表数组中的前两项，reduce会将这个函数的结果与数组中的第三项再次组成这个函数的两个形参以此类推进行累积操作 var arr = [1,2,3,4,5] var arr2 = arr.reduce((a,b)=&gt; a+b) console.log(arr2) // 15 filter ```//filter返回过滤后的数组。filter也接收一个函数作为参数，这个函数将作用于数组中的每个元素，根据该函数每次执行后返回的布尔值来保留结果，如果是true就保留，如果是false就过滤掉（这点与map要区分）var arr = [1,2,3,4,5] var arr3 = arr.filter(item =&gt; item % 2 == 0)console.log(arr3)// [2,4]12345678910111213## 5、闭包一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。本来闭包部分是看`尚硅谷`的教学视频,当时那位老师在此部分讲解的让我觉得并没特别清晰(在刚开始时没讲到重点,导致难以理解,但是在后面有提到就懂了),所以我自己看完后再去翻阅许多关于闭包的资料进行自学,随后将其梳理整合并加以自己感悟记录于此### Ⅰ-引出闭包概念#### ① 错误场景需求: `点击某个按钮, 提示&quot;点击的是第n个按钮&quot;` 测试1测试2测试3","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"②、jQuery，Hold on!","slug":"②、jQuery，Hold on!","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T06:29:09.056Z","comments":true,"path":"2022/04/24/②、jQuery，Hold on!/","link":"","permalink":"http://example.com/2022/04/24/%E2%91%A1%E3%80%81jQuery%EF%BC%8CHold%20on!/","excerpt":"","text":"②、jQuery，Hold on!✍、jQuery完结篇（二）jQuery事件🔥jQuery事件注册🔥单个事件注册🔥语法： 123element.事件(function()&#123;&#125;)$(&quot;div&quot;).click(function()&#123;事件处理程序&#125;) 其他事件和原生基本一致。 比如mouseover、mouseout、blur、focus、change、keydown、keyup、resize、scroll 等 jQuery事件处理🔥事件处理 on()绑定事件🔥 on() 方法在匹配元素上绑定一个或多个事件的事件处理函数 语法： 1element.on(events,[selector],fn) events ：一个或多个空格分隔的事件类型，如 “click” 或 “keydown” selector：元素的子元素选择器 fn：回调函数，即绑定在元素身上的侦听函数 12345678$(&quot;div&quot;).on(&#123; mouseenter: function()&#123; $(this).css(&quot;background&quot;,&quot;skyblue&quot;); &#125;, click: function()&#123; $(this).css(&quot;background&quot;,&quot;purple&quot;); &#125;&#125;) ①on() 方法优势1 可以绑定多个事件，多个处理事件处理程序。 12345$(&quot;div&quot;).on(&#123; mouseover: function()&#123;&#125;, mouseout: function()&#123;&#125;, click: function()&#123;&#125;&#125;) 如果事件处理程序相同 123$(&quot;div&quot;).on(&quot;mouseover mouseout&quot;,function()&#123; $(this.toggleClass(&quot;current&quot;));&#125;); ②on()方法优势2 可以事件委派操作.事件委派的定义就是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素 12345$(&quot;ul&quot;).on(&quot;click&quot;,&quot;li&quot;,function()&#123; alert(&quot;hello world!&quot;);&#125;);//事件是绑定在ul身上，只有一个ul 添加了点击事件，但是触发对象是li，会发生事件冒泡，冒泡到父亲身上，父亲就会执行这个函数 在此之前有bind(), live() delegate()等方法来处理事件绑定或者事件委派，最新版本的请用on替代他们。 ③on()方法优势3动态创建的元素，click()没有办法绑定事件，on() 可以给未来动态生成的元素绑定事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 传统方法$(&quot;ol li&quot;).click(function()&#123; alert(11);&#125;)var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;)$(&quot;ol&quot;).append(li);// 没有用，动态创建的元素没有办法绑定事件// on可以给未来动态创建的元素绑定事件$(&quot;ol&quot;).on(&quot;click&quot;,&quot;li&quot;,function()&#123; alert(11);&#125;)var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;)$(&quot;ol&quot;).append(li);123456789101112131415&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;/ol&gt; &lt;script&gt; $(function() &#123; // 1. 单个事件注册 // $(&quot;div&quot;).click(function() &#123; // $(this).css(&quot;background&quot;, &quot;purple&quot;); // &#125;); // $(&quot;div&quot;).mouseenter(function() &#123; // $(this).css(&quot;background&quot;, &quot;skyblue&quot;); // &#125;); // 2. 事件处理on // (1) on可以绑定1个或者多个事件处理程序 // $(&quot;div&quot;).on(&#123; // mouseenter: function() &#123; // $(this).css(&quot;background&quot;, &quot;skyblue&quot;); // &#125;, // click: function() &#123; // $(this).css(&quot;background&quot;, &quot;purple&quot;); // &#125;, // mouseleave: function() &#123; // $(this).css(&quot;background&quot;, &quot;blue&quot;); // &#125; // &#125;); $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() &#123; $(this).toggleClass(&quot;current&quot;); &#125;); // (2) on可以实现事件委托（委派） // $(&quot;ul li&quot;).click(); $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123; alert(11); &#125;); // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li // (3) on可以给未来动态创建的元素绑定事件 // $(&quot;ol li&quot;).click(function() &#123; // alert(11); // &#125;) $(&quot;ol&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123; alert(11); &#125;) var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;); $(&quot;ol&quot;).append(li); &#125;) &lt;/script&gt;&lt;/body&gt; 事件处理 off()解绑事件🔥 off() 方法可以移除通过on()方法添加的事件处理程序。 123$(&quot;div&quot;).off(); // 这个是接除了div身上的所有事件$(&quot;div&quot;).off(&quot;click&quot;); //这个是解除了div身上的点击事件$(&quot;ul&quot;).off(&quot;click&quot;,&quot;li&quot;); //这个是解绑事件委托 如果有些事件只想执行一次就不再执行，可以使用one() 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$(&quot;p&quot;).one(&quot;click&quot;,function()&#123; alert(11);&#125;)123&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; &#125; &lt;/style&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; $(&quot;div&quot;).on(&#123; click: function() &#123; console.log(&quot;我点击了&quot;); &#125;, mouseover: function() &#123; console.log(&#x27;我鼠标经过了&#x27;); &#125; &#125;); $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123; alert(11); &#125;); // 1. 事件解绑 off // $(&quot;div&quot;).off(); // 这个是解除了div身上的所有事件 $(&quot;div&quot;).off(&quot;click&quot;); // 这个是解除了div身上的点击事件 $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;); // 2. one() 但是它只能触发事件一次 $(&quot;p&quot;).one(&quot;click&quot;, function() &#123; alert(11); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;我是屁&lt;/p&gt;&lt;/body&gt; 自动触发事件trigger()🔥有些事件希望自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。 12345678// 1.元素.事件()$(&quot;div&quot;).click();// 2.元素.trigger(&quot;事件&quot;)$(&quot;div&quot;).trigger(&quot;click&quot;);// 3.元素.triggerHandler(&quot;事件&quot;) 不会触发元素的默认行为$(&quot;div&quot;).triggerHandler(&quot;click&quot;); triggerHandler 模式不会触发元素的默认行为，这是和前面两种的区别。 1234567891011121314151617181920212223&lt;script&gt; $(function() &#123; $(&quot;div&quot;).on(&quot;click&quot;, function() &#123; alert(11); &#125;); // 自动触发事件 // 1. 元素.事件() // $(&quot;div&quot;).click();会触发元素的默认行为 // 2. 元素.trigger(&quot;事件&quot;) // $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为 $(&quot;input&quot;).trigger(&quot;focus&quot;); // 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为 $(&quot;div&quot;).triggerHandler(&quot;click&quot;); $(&quot;input&quot;).on(&quot;focus&quot;, function() &#123; $(this).val(&quot;你好吗&quot;); &#125;); // $(&quot;input&quot;).triggerHandler(&quot;focus&quot;); &#125;);&lt;/script&gt; jQuery事件对象🔥事件被触发，就会有事件对象的产生 1element.on(events,[selector],function(event)&#123;&#125;) 阻止默认行为: event.preventDefault() 或者 return false 阻止冒泡 : event.stopPropagation() 12345678910111213141516171819202122232425262728293031&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: pink; &#125; &lt;/style&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; $(document).on(&quot;click&quot;, function() &#123; console.log(&quot;点击了document&quot;); &#125;) $(&quot;div&quot;).on(&quot;click&quot;, function(event) &#123; // console.log(event); console.log(&quot;点击了div&quot;); event.stopPropagation(); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; jQuery其他方法🔥jQuery对象拷贝🔥如果想要把某个对象拷贝(合并)给另外一个对象使用，此时可以使用$.extend()方法 1$.extend([deep],target,object1,[objectN]) deep:如果设为true为深拷贝，默认为false 浅拷贝 target: 要拷贝的目标对象 object1:待拷贝到第一个对象的对象 objectN:待拷贝的第N个对象的对象 浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象 深拷贝，前面加true，完全克隆(拷贝的对象，而不是地址),修改目标对象不会影响被拷贝对象 深拷贝把里面的数据完全复制一份给目标对象，如果里面有不冲突的属性，会合并到一起 123456789101112131415161718192021222324252627282930313233343536$(function()&#123; var targetObj = &#123;&#125;; var obj = &#123; id: 1, name: &quot;andy&quot; &#125;; // $.extend(target,obj); $.extend(targetObj,obj); // 会覆盖targetObj里面原来的数据 // 把 obj 拷贝给 targetObj&#125;)12345678910&lt;script&gt; $(function() &#123; var targetObj = &#123; id: 0, msg: &#123; sex: &#x27;男&#x27; &#125; &#125;; var obj = &#123; id: 1, name: &quot;andy&quot;, msg: &#123; age: 18 &#125; &#125;; // 1. 浅拷贝把原来对象里面的复杂数据类型地址拷贝给目标对象 // targetObj.msg.age = 20; // console.log(targetObj); // console.log(obj); // 2. 深拷贝把里面的数据完全复制一份给目标对象 如果里面有不冲突的属性,会合并到一起 $.extend(true, targetObj, obj); // console.log(targetObj); // 会覆盖targetObj 里面原来的数据 targetObj.msg.age = 20; console.log(targetObj); // msg :&#123;sex: &quot;男&quot;, age: 20&#125; console.log(obj); jQuery多库共存🔥 jQuery使用$作为标示符，随着jQuery的流行,其他 js 库也会用这$作为标识符， 这样一起使用会引起冲突 需要一个解决方案，让jQuery 和其他的js库不存在冲突，可以同时存在，这就叫做多库共存。 解决方案： 把里面的 $ 符号统一改为 jQuery。 比如 jQuery(’‘div’’) jQuery 变量规定新的名称：$.noConflict() var xx = $.noConflict(); 1234567891011121314151617181920212223242526&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; function $(ele) &#123; return document.querySelector(ele); &#125; console.log($(&quot;div&quot;)); // 1. 如果$ 符号冲突 我们就使用 jQuery jQuery.each(); // 2. 让jquery 释放对$ 控制权 让用自己决定 var suibian = jQuery.noConflict(); console.log(suibian(&quot;span&quot;)); suibian.each(); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt;&lt;/body&gt; jQuery插件🔥jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 注意: 这些插件也是依赖于jQuery来完成的，所以必须要先引入jQuery文件，因此也称为 jQuery 插件。 jQuery 插件常用的网站: jQuery插件库 http://www.jq22.com/ (需要登录) jQuery之家 http://www.htmleaf.com/ (不需登录，推荐) jQuery插件使用步骤🔥 引入相关文件(jQuery文件和插件文件) 复制相关 html，css，js(调用插件) 瀑布流插件🔥 我们打开 jQuery 之家，选择我们需要的 jQuery 插件，直接下载插件即可(这里以瀑布流插件为例) 我们下载完是一个压缩包，直接解压即可 打开 index.html，右击检查网页源代码 我们发现此插件引入了 css ，js。我们将解压好的文件夹中的css、js拷贝到我们自己所需的文件夹中 我们接着看我们刚才打开的 index.html ，此插件引入了 css ，js，我们将其引用部分复制粘贴进我们自己的网页中 接下来我们只需修改 HTML 部分即可。我们在下载插件的页面 下滑查看插件的 HTML结构，在打开的 index.html 中复制展示的段落代码，粘贴进我们自己的 HTML 网页中，并进行图片的更换 最后，完事大成，我们来看看我们自己的效果 这样就和插件效果一模一样了，我们在 插件下载页面 下滑，可以看到我们的配置参数，自己也可以在 引入内部js 代码中进行修改 jQuery图片懒加载🔥 图片懒加载(图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载) 当我们页面滑动到可视区域，再显示图片 我们使用 jquery 插件库 EasyLazyload。 注意，此时的js引入文件和js调用必须写到 DOM元素（图片）最后面 下载插件，并解压插件 打开 index.html，右键 查看网页源代码 将其需要引入的 css、js 文件复制到我们自己的网页文件夹中 将其引入的代码复制进我们自己的网页结构中， 在下载插件页面 下滑查看使用方法，将 HTML 结构也复制进我们自己的网页结构中 全屏滚动插件fullpage.js🔥GitHub地址：https://github.com/alvarotrigo/fullPage.js 中文翻译网站：https://www.dowebok.com/demo/2014/77/ 和上面插件一样，下载解压，查看使用方法即可食用。","categories":[{"name":"JQuery","slug":"JQuery","permalink":"http://example.com/categories/JQuery/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://example.com/tags/JQuery/"}]},{"title":"①、jQuery，Hold on!","slug":"①、jQuery，Hold on!","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T06:27:31.628Z","comments":true,"path":"2022/04/24/①、jQuery，Hold on!/","link":"","permalink":"http://example.com/2022/04/24/%E2%91%A0%E3%80%81jQuery%EF%BC%8CHold%20on!/","excerpt":"","text":"①、jQuery，Hold on!✍、jQuery完结篇（一） jQuery🔥JavaScript库 JavaScript 库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。 简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。 比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。 jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 j 就是 JavaScript； Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。 jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。 学习jQuery本质： 就是学习调用这些函数（方法）。 jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。 jQuery下载🔥 官网: https://jquery.com/ 其余版本的下载：https://code.jquery.com/ 1x ：兼容 IE 678 等低版本浏览器， 官网不再更新 2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新 3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本 我们在使用之前要先下载 ，步骤如下，首先打开官网 打开官网，选择压缩的版本使用即可 点击压缩版本进入：ctrl+A 全选， ctrl+c 复制 在vs中新建jquery.min.js 文件（此处任何名称均可，只要是js文件即可） 在html 文件进行引入即可 1&lt;script src = &quot;jquery.min.js&quot;&gt;&lt;/script&gt; jQuery的入口函数🔥12345678910// 第一种方法 推荐$(function()&#123; ... // 此处是页面DOM加载完成的入口 &#125;)// 第二种方法$(document).ready(function()&#123; ... //此处是页面DOM加载完成的入口&#125;) 等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完毕，jQuery 帮我们完成了封装 相当于原生 js 中的 DOMContentLoaded 不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css 文件、图片加载完毕才执行内部代码 更推荐使用第一种方式 jQuery的顶级对象$🔥 $ 是 jQuery 的别称，在代码中可以使用 jQuery 代替$ $ 是 jQuery 的顶级对象，相当于原生 JavaScript 中的 window。 把元素利用$包装成jQuery对象，就可以调用jQuery的方法。 123456789101112131415&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; // 1. $ 是jQuery的别称（另外的名字） // $(function() &#123; // alert(11) // &#125;); jQuery(function() &#123; // alert(11) // $(&#x27;div&#x27;).hide(); jQuery(&#x27;div&#x27;).hide(); &#125;); // 2. $同时也是jQuery的 顶级对象 &lt;/script&gt;&lt;/body&gt; jQuery对象和DOM对象🔥 DOM对象：用原生js获取过来的对象 jQuery对象: 用jQuery方式获取过来的对象是jQuery对象。 本质：通过$把DOM元素进行了包装(伪数组形式存储) jQuery对象只能使用jQuery方法，DOM对象则使用原生的JavaScript的属性和方法 12345678910111213141516171819&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt; &lt;script&gt; // 1. DOM 对象: 用原生js获取过来的对象就是DOM对象 var myDiv = document.querySelector(&#x27;div&#x27;); // myDiv 是DOM对象 var mySpan = document.querySelector(&#x27;span&#x27;); // mySpan 是DOM对象 console.dir(myDiv); // 2. jQuery对象:用jquery方式获取过来的对象是jQuery对象。 // 本质:通过$把DOM元素进行了包装 $(&#x27;div&#x27;); // $(&#x27;div&#x27;)是一个jQuery 对象 $(&#x27;span&#x27;); // $(&#x27;span&#x27;)是一个jQuery 对象 console.dir($(&#x27;div&#x27;)); // 3. jQuery 对象只能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 属性和方法 // myDiv.style.display = &#x27;none&#x27;; // myDiv.hide(); myDiv是一个dom对象不能使用 jquery里面的hide方法 // $(&#x27;div&#x27;).style.display = &#x27;none&#x27;; 这个$(&#x27;div&#x27;)是一个jQuery对象不能使用原生js 的属性和方法 &lt;/script&gt;&lt;/body&gt; jQuery对象和DOM对象转化🔥 DOM 对象与 jQuery 对象之间是可以相互转换的。 因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。 DOM 对象转换为 jQuery 对象🔥 语法：$(DOM对象) 1$(&#x27;div&#x27;) jQuery 对象转换为 DOM 对象🔥 语法： 123456789101112131415161718192021222324// 第一种方法$(&#x27;div&#x27;)[index] index是索引号// 第二种方法$(&#x27;div&#x27;).get(index) index是索引号123456&lt;body&gt; &lt;video src=&quot;mov.mp4&quot; muted&gt;&lt;/video&gt; &lt;script&gt; // 1. DOM对象转换为 jQuery对象 // (1) 我们直接获取视频，得到就是jQuery对象 // $(&#x27;video&#x27;); // (2) 我们已经使用原生js 获取过来就是DOM对象 var myvideo = document.querySelector(&#x27;video&#x27;); // $(myvideo).play(); jquery里面没有play 这个方法 // 2. jQuery对象转换为DOM对象 // myvideo.play(); $(&#x27;video&#x27;)[0].play() $(&#x27;video&#x27;).get(0).play() &lt;/script&gt;&lt;/body&gt; jQuery常用API🔥jQuery选择器🔥jQuery基础选择器🔥原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。 语法：$(&quot;选择器&quot;) 里面选择器直接写CSS选择器即可，但是要加引号 1$(&quot;.nav&quot;); 名称 用法 描述 ID选择器 $(&quot;#id&quot;) 获取指定ID的元素 全选选择器 $(&#39;*&#39;) 匹配所有元素 类选择器 $(&quot;.class&quot;) 获取同一类class的元素 标签选择器 $(&quot;div&quot;) 获取同一类标签的所有元素 并集选择器 $(&quot;div,p,li&quot;) 选取多个元素 交集选择器 $(&quot;li.current&quot;) 交集元素 jQuery层级选择器🔥 名称 用法 描述 子代选择器 $(&quot;ul&gt;li&quot;) 使用&gt;号，获取亲儿子层级的选择器；注意，并不会获取孙子层级的元素 后代选择器 $(&quot;ul li&quot;) 使用空格，代表后代选择器，获取 ul 下的所有 li 元素，包括孙子等 1234567891011121314151617181920212223242526$(&quot;ul li&quot;);&lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div class=&quot;nav&quot;&gt;我是nav div&lt;/div&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;ol&gt; &lt;li&gt;我是ol 的&lt;/li&gt; &lt;li&gt;我是ol 的&lt;/li&gt; &lt;li&gt;我是ol 的&lt;/li&gt; &lt;li&gt;我是ol 的&lt;/li&gt; &lt;/ol&gt; &lt;ul&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() &#123; console.log($(&quot;.nav&quot;)); console.log($(&quot;ul li&quot;)); &#125;) &lt;/script&gt;&lt;/body&gt; 知识铺垫jQuery 设置样式 1$(&#x27;div&#x27;).css(&#x27;属性&#x27;,&#x27;值&#x27;) jQuery隐式迭代🔥 遍历内部DOM元素(伪数组形式存储)的过程就叫做 隐式迭代 简单理解: 给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用 1234567891011121314151617181920&lt;body&gt; &lt;div&gt;惊喜不，意外不&lt;/div&gt; &lt;div&gt;惊喜不，意外不&lt;/div&gt; &lt;div&gt;惊喜不，意外不&lt;/div&gt; &lt;div&gt;惊喜不，意外不&lt;/div&gt; &lt;ul&gt; &lt;li&gt;相同的操作&lt;/li&gt; &lt;li&gt;相同的操作&lt;/li&gt; &lt;li&gt;相同的操作&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1. 获取四个div元素 console.log($(&quot;div&quot;)); // 2. 给四个div设置背景颜色为粉色 jquery对象不能使用style $(&quot;div&quot;).css(&quot;background&quot;, &quot;pink&quot;); // 3. 隐式迭代就是把匹配的所有元素内部进行遍历循环，给每一个元素添加css这个方法 $(&quot;ul li&quot;).css(&quot;color&quot;, &quot;red&quot;); &lt;/script&gt;&lt;/body&gt; jQuery筛选选择器🔥12// 选取 ul 里面的 第一个 li$(&quot;ul li:first&quot;).css(&quot;color&quot;,&quot;red&quot;); 语法 用法 描述 : first $(&#39;li:first&#39;) 获取第一个li元素 : last $(&#39;li:last&#39;) 获取最后一个li元素 : eq(index) $(&quot;li:eq(2)&quot;) 获取到的li元素中，选择索引号为2的元素，索引号index从0开始 : odd $(&quot;li:odd&quot;) 获取到的li元素中，选择索引号为奇数的元素 : even $(&quot;li:even&quot;) 获取到的li元素中，选择索引号为偶数的元素 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;ul&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;/ul&gt; &lt;!-- 有序列表 --&gt; &lt;ol&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; $(function() &#123; // 获取第一个li元素 $(&quot;ul li:first&quot;).css(&quot;color&quot;, &quot;red&quot;); // 获取索引号为2的li $(&quot;ul li:eq(2)&quot;).css(&quot;color&quot;, &quot;blue&quot;); // 获取索引号为奇数的li $(&quot;ol li:odd&quot;).css(&quot;color&quot;, &quot;skyblue&quot;); // 获取索引号为偶数的li $(&quot;ol li:even&quot;).css(&quot;color&quot;, &quot;pink&quot;); &#125;) &lt;/script&gt;&lt;/body&gt; jQuery筛选方法🔥 语法 用法 说明 🔥parent() $(&quot;li&quot;).parent(); 查找父级，最近一级的父元素 🔥children(selector) $(&quot;ul&quot;).children(&quot;li&quot;) 相当于$(&quot;ul&gt;li&quot;),最近一级(亲儿子) 🔥find(selector) $(&quot;ul&quot;).find(&quot;li&quot;) 相当于$(&quot;ul li&quot;) 后代选择器 🔥siblings(selector) $(&quot;.first&quot;).siblings(&quot;li&quot;) 查找兄弟节点，不包括自己本身 nextAll([expr]) $(&quot;.first&quot;).nextAll() 查找当前元素之后所有的同辈元素 prevtAll([expr]) $(&quot;.last&quot;).prevAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(&#39;div&#39;).hasClass(&quot;protected&quot;) 检查当前的元素是否含有某个特定的类，如果有，则返回true 🔥eq(index) $(&quot;li&quot;).eq(2); 相当于$(&quot;li:eq(2),index&quot;)index从0开始 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div class=&quot;yeye&quot;&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;儿子&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;nav&quot;&gt; &lt;p&gt;我是屁&lt;/p&gt; &lt;div&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 注意一下都是方法 带括号 $(function() &#123; // 1. 父 parent() 返回的是 最近一级的父级元素 亲爸爸 console.log($(&quot;.son&quot;).parent()); // 2. 子 // (1) 亲儿子 children() 类似子代选择器 ul&gt;li // $(&quot;.nav&quot;).children(&quot;p&quot;).css(&quot;color&quot;, &quot;red&quot;); // (2) 可以选里面所有的孩子 包括儿子和孙子 find() 类似于后代选择器 $(&quot;.nav&quot;).find(&quot;p&quot;).css(&quot;color&quot;, &quot;red&quot;); &#125;); &lt;/script&gt;&lt;/body&gt; jQuery排他思想🔥 想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。 1234567891011121314151617181920&lt;body&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;script&gt; $(function() &#123; // 1. 隐式迭代 给所有的按钮都绑定了点击事件 $(&quot;button&quot;).click(function() &#123; // 2. 当前的元素变化背景颜色 $(this).css(&quot;background&quot;, &quot;pink&quot;); // 3. 其余的兄弟去掉背景颜色 隐式迭代 $(this).siblings(&quot;button&quot;).css(&quot;background&quot;, &quot;&quot;); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; jQuerty链式编程🔥链式编程是为了节省代码量，看起来更优雅。使用链式编程一定注意是哪个对象执行样式. 12345678910111213141516171819202122232425262728$(this).css(&quot;color&quot;,&quot;red&quot;).siblings().css(&quot;color&quot;,&quot;&quot;);1&lt;body&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;button&gt;快速&lt;/button&gt; &lt;script&gt; $(function() &#123; // 1. 隐式迭代 给所有的按钮都绑定了点击事件 $(&quot;button&quot;).click(function() &#123; // 2. 让当前元素颜色变为红色(点击哪个哪个就变为红色) // $(this).css(&quot;color&quot;, &quot;red&quot;); // 3. 让其余的兄弟元素不变色 // $(this).siblings().css(&quot;color&quot;, &quot;&quot;); // 链式编程完成上述功能 $(this).css(&quot;color&quot;, &quot;red&quot;).siblings().css(&quot;color&quot;, &quot;&quot;); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; jQuery样式操作🔥jQuery修改样式css方法jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式 参数只写属性名,则返回属性值 1$(this).css(&quot;color&quot;); 参数是属性名,属性值,逗号分隔,是设定一组样式。属性需要加引号,值是数字可不加单位和引号 1$(this).css(&quot;color&quot;,300); 参数可以是对象形式,方便设置多组样式。属性名和属性值用冒号隔开,属性可以不用加引号 12345678$(this).css(&#123; &quot;color&quot;:&quot;red&quot;, &quot;width&quot;: 400, &quot;height&quot;: 400, // 如果是复合属性则必须采取驼峰命名法，如果值不是数字，则需要加引号 backgroundColor: &quot;red&quot; &#125;) jQuery设置类样式方法作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 1.添加类$(&quot;div&quot;).addClass(&quot;current&quot;);// 2.移除类$(&quot;div&quot;).removeClass(&quot;current&quot;);// 3.切换类$(&quot;div&quot;).toggleClass(&quot;current&quot;);12345678&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 150px; height: 150px; background-color: pink; margin: 100px auto; transition: all 0.5s; &#125; .current &#123; background-color: red; transform: rotate(360deg); &#125; &lt;/style&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;current&quot;&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. 添加类 addClass() // $(&quot;div&quot;).click(function() &#123; // // $(this).addClass(&quot;current&quot;); // &#125;); // 2. 删除类 removeClass() // $(&quot;div&quot;).click(function() &#123; // $(this).removeClass(&quot;current&quot;); // &#125;); // 3. 切换类 toggleClass() $(&quot;div&quot;).click(function() &#123; $(this).toggleClass(&quot;current&quot;); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; jQuery类操作和className区别 原生 JS 中的 className 会覆盖元素原先里面的类名 jQuery里面类操作只是对指定类进行操作，不影响原先的类名 123456789&lt;body&gt; &lt;div class=&quot;one two&quot;&gt;&lt;/div&gt; &lt;script&gt; // var one = document.querySelector(&quot;.one&quot;); // one.className = &quot;two&quot;; // $(&quot;.one&quot;).addClass(&quot;two&quot;); 这个addClass相当于追加类名 不影响以前的类名 $(&quot;.one&quot;).removeClass(&quot;two&quot;); &lt;/script&gt;&lt;/body&gt; jQuery效果🔥jQuery显示与隐藏效果jQuery 给我们封装了很多动画效果，最为常见的如下： ①显示效果语法： 123// 显示语法规范show([speed,[easing],[fn]]) //中括号表示参数都可以省略$(&quot;div&quot;).show(); 参数： 参数都可以省略， 无动画直接显示。 speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。 easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 ②隐藏效果语法： 123// 隐藏语法规范hide([speed,[easing],[fn]])$(&quot;div&quot;).hide(); 参数： 参数都可以省略， 无动画直接显示。 speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。 easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 ③切换效果语法： 123// 切换语法规范toggle([speed,[easing],[fn]])$(&quot;div&quot;).toggle(); 参数： 参数都可以省略， 无动画直接显示。 speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。 easing：(Optional) 用来指定切换效果，默认是“swing”，可用参数“linear”。 fn: 回调函数，在动画完成时执行的函数，每个元素执行一次。 建议：平时一般不带参数，直接显示隐藏即可 123456789101112131415161718192021222324&lt;body&gt; &lt;button&gt;显示&lt;/button&gt; &lt;button&gt;隐藏&lt;/button&gt; &lt;button&gt;切换&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).eq(0).click(function() &#123; $(&quot;div&quot;).show(1000, function() &#123; alert(1); &#125;); &#125;) $(&quot;button&quot;).eq(1).click(function() &#123; $(&quot;div&quot;).hide(1000, function() &#123; alert(1); &#125;); &#125;) $(&quot;button&quot;).eq(2).click(function() &#123; $(&quot;div&quot;).toggle(1000); &#125;) // 一般情况下，我们都不加参数直接显示隐藏就可以了 &#125;); &lt;/script&gt;&lt;/body&gt; jQuery滑动效果与事件切换①下滑动语法： 123// 下滑动slideDown([speed,[easing],[fn]]) $(&quot;div&quot;).slideDown(); ②上滑动语法： 123// 上滑动slideUp([speed,[easing],[fn]]) $(&quot;div&quot;).slideUp(); ③滑动切换语法： 12345678910111213141516171819202122232425262728293031// 滑动切换效果slideToggle([speed,[easing],[fn]]) $(&quot;div&quot;).slideToggle();123&lt;body&gt; &lt;button&gt;下拉滑动&lt;/button&gt; &lt;button&gt;上拉滑动&lt;/button&gt; &lt;button&gt;切换滑动&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).eq(0).click(function() &#123; // 下滑动 slideDown() $(&quot;div&quot;).slideDown(); &#125;) $(&quot;button&quot;).eq(1).click(function() &#123; // 上滑动 slideUp() $(&quot;div&quot;).slideUp(500); &#125;) $(&quot;button&quot;).eq(2).click(function() &#123; // 滑动切换 slideToggle() $(&quot;div&quot;).slideToggle(500); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; ④事件切换语法： 1hover([over,]out) over: 鼠标移到元素上要触发的函数(相当于mouseenter) out: 鼠标移出元素要触发的函数(相当于mouseleave) 如果只写一个函数，则鼠标经过和离开都会触发它 1234567$(&quot;div&quot;).hover(function()&#123;&#125;,function()&#123;&#125;);// 第一个function是鼠标经过的函数// 第二个function是鼠标离开的函数// 如果hover只写一个函数,那么鼠标经过和鼠标离开都会触发这个函数$(&quot;div&quot;).hover(function()&#123; $(this).slideToggle();&#125;) jQuery动画队列及其停止排队方法动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行 ①停止排队语法： 1stop() stop()方法用于停止动画或者效果 注意: stop() 写到动画或者效果的前面，相当于停止结束上一次的动画 1234$(&quot;.nav&gt;li&quot;).hover(function()&#123; // stop 方法必须写到动画的前面 $(this).children(&quot;ul&quot;).stop().slideToggle();&#125;) jQuery淡入淡出以及突出效果①淡入淡出切换语法： 1234567891011// 淡入fadeIn([speed,[easing],[fn]])$(&quot;div&quot;).fadeIn();// 淡出fadeOut([speed,[easing],[fn]])$(&quot;div&quot;).fadeOut;// 淡入淡出切换fadeToggle([speed,[easing],[fn]])12345678910 ②渐进方式调整到指定的不透明度语法： 12// 修改透明度 这个速度和透明度必须写fadeTo(speed,opacity,[easing],[fn]) 参数： opacity ：透明度必须写，取值 0~1 之间 speed：三种预定速度之一的字符串(“slow”,“normal”, or “fast”)或表示动画时长的毫秒数值(如：1000)。必须写 1234567891011121314151617181920212223242526272829303132$(&quot;div&quot;).fadeTo(1000,0.5)1&lt;body&gt; &lt;button&gt;淡入效果&lt;/button&gt; &lt;button&gt;淡出效果&lt;/button&gt; &lt;button&gt;淡入淡出切换&lt;/button&gt; &lt;button&gt;修改透明度&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).eq(0).click(function() &#123; // 淡入 fadeIn() $(&quot;div&quot;).fadeIn(1000); &#125;) $(&quot;button&quot;).eq(1).click(function() &#123; // 淡出 fadeOut() $(&quot;div&quot;).fadeOut(1000); &#125;) $(&quot;button&quot;).eq(2).click(function() &#123; // 淡入淡出切换 fadeToggle() $(&quot;div&quot;).fadeToggle(1000); &#125;); $(&quot;button&quot;).eq(3).click(function() &#123; // 修改透明度 fadeTo() 这个速度和透明度要必须写 $(&quot;div&quot;).fadeTo(1000, 0.5); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; jQuery自定义动画animate方法语法： 1animate(params,[speed],[easing],[fn]) 参数： params: 想要更改的样式属性，以对象形式传递，必须写。 属性名可以不用带引号， 如果是复合属性则需要采取驼峰命名法 borderLeft。其余参数都可以省略。 12345678910111213141516171819202122232425262728293031&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; div &#123; position: absolute; width: 200px; height: 200px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;动起来&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).click(function() &#123; $(&quot;div&quot;).animate(&#123; left: 500, top: 300, opacity: .4, width: 500 &#125;, 500); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; jQuery属性操作🔥获取元素固有属性值prop()所谓元素固有属性就是元素本身自带的属性，比如 &lt;a&gt; 元素里面的 href ，比如 &lt;input&gt; 元素里面的 type。 语法：prop(&quot;属性&quot;) 123prop(&quot;属性&quot;)$(&quot;a&quot;).prop(&quot;href&quot;); 设置元素固有属性值语法：prop(&quot;属性&quot;,&quot;属性值&quot;) 123prop(&quot;属性&quot;,&quot;属性值&quot;)$(&quot;a&quot;).prop(&quot;title&quot;,&quot;我们都挺好~&quot;); 获取元素自定义属性值用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。 语法：attr(&quot;属性&quot;) 123attr(&quot;属性&quot;) // 类似原生getAttribute()$(&quot;div&quot;).attr(&quot;index&quot;); 设置元素自定义属性值语法：attr(&quot;属性&quot;,&quot;属性值&quot;) 1234567891011121314151617181920212223242526272829303132attr(&quot;属性&quot;,&quot;属性值&quot;) //类似原生setAttribute()$(&quot;div&quot;).attr(&quot;index&quot;,4);123&lt;body&gt; &lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked&gt; &lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt; &lt;span&gt;123&lt;/span&gt; &lt;script&gt; $(function() &#123; //1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值 console.log($(&quot;a&quot;).prop(&quot;href&quot;)); $(&quot;a&quot;).prop(&quot;title&quot;, &quot;我们都挺好&quot;); $(&quot;input&quot;).change(function() &#123; console.log($(this).prop(&quot;checked&quot;)); &#125;); // console.log($(&quot;div&quot;).prop(&quot;index&quot;)); // 2. 元素的自定义属性 我们通过 attr() console.log($(&quot;div&quot;).attr(&quot;index&quot;)); $(&quot;div&quot;).attr(&quot;index&quot;, 4); console.log($(&quot;div&quot;).attr(&quot;data-index&quot;)); // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面 $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;); console.log($(&quot;span&quot;).data(&quot;uname&quot;)); // 这个方法获取data-index h5自定义属性 第一个 不用写data- 而且返回的是数字型 console.log($(&quot;div&quot;).data(&quot;index&quot;)); &#125;) &lt;/script&gt;&lt;/body&gt; 数据缓存data()data() 方法可以在指定的元素上存取数据,并不会修改DOM元素结构，一旦页面刷新，之前存放的数据都将被移除。 ①附加数据语法 语法：data(&quot;name&quot;,&quot;value&quot;) 向被选元素附加数据 1$(&quot;span&quot;).data(&quot;uname&quot;,&quot;andy&quot;); ②获取数据语法 语法：date(&quot;name&quot;) 向被选元素获取数据 123$(&quot;span&quot;).data(&quot;uname&quot;);// 这个方法获取data-index h5自定义属性，不用写 data- 返回的是数字型(2)$(&quot;div&quot;).data(&quot;index&quot;); 同时，还可以读取H5自定义属性 data-index,得到的是数字型 123456789101112&lt;body&gt; &lt;span&gt;123&lt;/span&gt; &lt;script&gt; $(function() &#123; // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面 $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;); console.log($(&quot;span&quot;).data(&quot;uname&quot;)); // 这个方法获取data-index h5自定义属性 第一个 不用写data- 而且返回的是数字型 console.log($(&quot;div&quot;).data(&quot;index&quot;)); &#125;) &lt;/script&gt;&lt;/body&gt; jQuery内容文本值🔥主要针对元素的内容还有表单的值操作 普通元素内容html()相当于原生innerHTML 语法： 获取元素的内容：html() 设置元素的内容：html(&quot;内容&quot;) 12345$(&quot;div&quot;).html();$(&quot;div&quot;).html(&quot;123&quot;);// 获取过来的带的标签 &lt;span&gt;123&lt;/span&gt; 普通元素文本内容text()相当于原生innerText 语法： 获取元素的文本内容：text() 设置元素的文本内容：text(&quot;文本内容&quot;) 12345$(&quot;div&quot;).text();$(&quot;div&quot;).text(&quot;123&quot;);// 123 // 获取过来的不带标签 123 获取设置表单值 val()语法： 获取表单的的值：val() 设置表单的值：val(&quot;内容&quot;) 12345678910111213141516171819202122$(&quot;input&quot;).val();$(&quot;input&quot;).val(&quot;请输入内容~~~&quot;);123&lt;body&gt; &lt;div&gt; &lt;span&gt;我是内容&lt;/span&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; value=&quot;请输入内容&quot;&gt; &lt;script&gt; // 1. 获取设置元素内容 html() console.log($(&quot;div&quot;).html()); // $(&quot;div&quot;).html(&quot;123&quot;); // 2. 获取设置元素文本内容 text() console.log($(&quot;div&quot;).text()); $(&quot;div&quot;).text(&quot;123&quot;); // 3. 获取设置表单值 val() console.log($(&quot;input&quot;).val()); $(&quot;input&quot;).val(&quot;123&quot;); &lt;/script&gt;&lt;/body&gt; jQuery元素操作🔥主要是遍历，创建，添加，删除元素操作 遍历元素jQuery隐式迭代是对同一类元素做了同样的操作，如果想要给同一类元素做不同操作，就需要用到遍历 ①语法一 语法一： 12// 语法一$(&quot;div&quot;).each(function(index,domEle)&#123;xxx;&#125;) each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个 里面的回调函数有2个参数: index是每个元素的索引号,demEle是每个DOM元素，不是jQuery对象 所以想要使用jQuery方法，需要给这个dom元素转换为jquery对象 $(domEle) ②语法二 语法二： 12// 语法二$.each(Object,function(index,element)&#123;xxx;&#125;) $.each() 方法可用于遍历任何对象，主要用于数据处理,比如数组,对象 里面的函数有2个参数: index 是每个元素的索引号,element遍历内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; $(function() &#123; // $(&quot;div&quot;).css(&quot;color&quot;, &quot;red&quot;); // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大） var sum = 0; // 1. each() 方法遍历元素 var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; $(&quot;div&quot;).each(function(i, domEle) &#123; // 回调函数第一个参数一定是索引号 可以自己指定索引号号名称 // console.log(index); // console.log(i); // 回调函数第二个参数一定是 dom元素对象 也是自己命名 // console.log(domEle); // domEle.css(&quot;color&quot;); dom对象没有css方法 $(domEle).css(&quot;color&quot;, arr[i]); sum += parseInt($(domEle).text()); &#125;) console.log(sum); // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据 // $.each($(&quot;div&quot;), function(i, ele) &#123; // console.log(i); // console.log(ele); // &#125;); // $.each(arr, function(i, ele) &#123; // console.log(i); // console.log(ele); // &#125;) $.each(&#123; name: &quot;andy&quot;, age: 18 &#125;, function(i, ele) &#123; console.log(i); // 输出的是 name age 属性名 console.log(ele); // 输出的是 andy 18 属性值 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 创建元素语法： 12345$(&quot;&lt;li&gt;&lt;/li&gt;&quot;);// 动态创建一个li标签12var li = $(&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;);var div =$(&quot;&lt;div&gt;我是后来的div&lt;/div&gt;&quot;) 添加元素①内部添加语法： 把内容放入匹配元素内部最后面：element.append(&quot;内容&quot;) 把内容放入匹配元素内部最前面：element.prepend(&quot;内容&quot;) 12345678// 1.内部添加element.append(&quot;内容&quot;)$(&quot;ul&quot;).append(li);// 把内容放入匹配元素内部最后面，类似原生appendChildelement.prepend(&quot;内容&quot;)$(&quot;ul&quot;).prepend(li);// 把内容放入匹配元素内部最前面 ②外部添加语法： 外部添加把内容放到目标元素后面：element.after(&quot;内容&quot;) 外部添加把内容放到目标元素前面：element.before(&quot;内容&quot;) 1234567// 2.外部添加element.after(&quot;内容&quot;);$(&quot;.test&quot;).after(div);// 把内容放入目标元素后面element.before(&quot;内容&quot;);// 把内容放入目标元素前面 内部添加元素，生成之后，它们是父子关系 外部添加元素，生成之后，它们是兄弟关系 删除元素语法： 删除匹配的元素(本身)：element.remove() 删除匹配的元素集合中所有的子节点：element.empty() 清空匹配的元素内容：element.html(&quot;&quot;) 12345671.element.remove() //删除匹配的元素(本身)$(&quot;ul&quot;).remove();2.element.empty() //删除匹配元素里面的子结点(孩子)$(&quot;ul&quot;).empty();3.element.html(&quot;&quot;) //删除匹配元素里面的子结点(孩子) remove 删除元素本身 empt() 和 html(“”) 作用等价，都可以删除元素黎曼的内容，只不过 html 还可以设置内容。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;ul&gt; &lt;li&gt;原先的li&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;test&quot;&gt;我是原先的div&lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. 创建元素 var li = $(&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;); // 2. 添加元素 // (1) 内部添加 // $(&quot;ul&quot;).append(li); 内部添加并且放到内容的最后面 $(&quot;ul&quot;).prepend(li); // 内部添加并且放到内容的最前面 // (2) 外部添加 var div = $(&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;); // $(&quot;.test&quot;).after(div); $(&quot;.test&quot;).before(div); // 3. 删除元素 // $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀 // $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子 $(&quot;ul&quot;).html(&quot;&quot;); // 可以删除匹配的元素里面的子节点 孩子 &#125;) &lt;/script&gt;&lt;/body&gt; jQuery 尺寸🔥 语法 用法 width() / height() 取得匹配元素宽度和高度值，只算 width / height innerWidth() / innerHeight() 取得匹配元素宽度和高度值，包含padding outerWidth() / outerHeight() 取得匹配元素宽度和高度值，包含padding、border outerWidth(true) / outerHeight(true) 取得匹配元素宽度和高度值，包含padding、border、margin 以上参数为空，则是获取相应值，返回的是数字型 如果参数为数字，则是修改相应值 参数可以不必写单位 123456789101112131415161718192021&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. width() / height() 获取设置元素 width和height大小 console.log($(&quot;div&quot;).width()); // $(&quot;div&quot;).width(300); // 2. innerWidth() / innerHeight() 获取设置元素 width和height + padding 大小 console.log($(&quot;div&quot;).innerWidth()); // 3. outerWidth() / outerHeight() 获取设置元素 width和height + padding + border 大小 console.log($(&quot;div&quot;).outerWidth()); // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin console.log($(&quot;div&quot;).outerWidth(true)); &#125;) &lt;/script&gt;&lt;/body&gt; jQuery位置🔥位置主要有三个： offset()、position()、scrollTop()/scrollLeft() offset() 设置或获取元素偏移1- offset() 方法设置或返回被选元素相对于文档的偏移坐标，跟父级没有关系 1234567$(&quot;.son&quot;).offset();$(&quot;.son&quot;).offset().top;$(&quot;.son&quot;).offset(&#123; top: 200, left: 200&#125;); 该方法有两个属性 left、top. offset().top用于获取距离文档顶部的距离， offset().left 用于获取距离文档左侧的距离 ①可以设置元素的偏移：offset({ top: 10, left: 30 }); position()获取元素偏移 position() 方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准 该方法有2个属性 left、top。 position().top 用于获取距离定位父级顶部的距离， position().left 用于获取距离定位父级左侧的距离。 这个方法只能获取偏移，不能设置偏移 1234567891011121314151617181920212223242526$(&quot;.son&quot;).position();// 这个方法只能获取偏移，不能设置偏移&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. 获取设置距离文档的位置（偏移） offset console.log($(&quot;.son&quot;).offset()); console.log($(&quot;.son&quot;).offset().top); // $(&quot;.son&quot;).offset(&#123; // top: 200, // left: 200 // &#125;); // 2. 获取距离带有定位父级位置（偏移） position 如果没有带有定位的父级，则以文档为准 // 这个方法只能获取不能设置偏移 console.log($(&quot;.son&quot;).position()); // $(&quot;.son&quot;).position(&#123; // top: 200, // left: 200 // &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; scrollTop() / scrollLeft() 设置或获取元素被卷去的头部和左侧 scrollTop()方法设置或返回被选元素被卷去的头部。 不跟参数是获取，参数为不带单位的数字则是设置被卷去的头部。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 页面滚动事件$(window).scroll(function()&#123; $(document).scrollTop();&#125;)1234&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; height: 2000px; &#125; .back &#123; position: fixed; width: 50px; height: 50px; background-color: pink; right: 30px; bottom: 100px; display: none; &#125; .container &#123; width: 900px; height: 500px; background-color: skyblue; margin: 400px auto; &#125; &lt;/style&gt; &lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;back&quot;&gt;返回顶部&lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;/div&gt; &lt;script&gt; $(function() &#123; $(document).scrollTop(100); // 被卷去的头部 scrollTop() / 被卷去的左侧 scrollLeft() // 页面滚动事件 var boxTop = $(&quot;.container&quot;).offset().top; $(window).scroll(function() &#123; // console.log(11); console.log($(document).scrollTop()); if ($(document).scrollTop() &gt;= boxTop) &#123; $(&quot;.back&quot;).fadeIn(); &#125; else &#123; $(&quot;.back&quot;).fadeOut(); &#125; &#125;); // 返回顶部 $(&quot;.back&quot;).click(function() &#123; // $(document).scrollTop(0); $(&quot;body, html&quot;).stop().animate(&#123; scrollTop: 0 &#125;); // $(document).stop().animate(&#123; // scrollTop: 0 // &#125;); 不能是文档而是 html和body元素做动画 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/categories/HTML/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://example.com/tags/JQuery/"}]},{"title":"AJAX基础","slug":"AJAX 基础","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T06:39:29.730Z","comments":true,"path":"2022/04/24/AJAX 基础/","link":"","permalink":"http://example.com/2022/04/24/AJAX%20%E5%9F%BA%E7%A1%80/","excerpt":"","text":"AJAXAJAX 简介AJAX 全称为Asynchronous JavaScript And XML，就是异步的JS 和XML通过AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式 XML 简介XML 可扩展标记语言。XML 被设计用来传输和存储数据。XML 和HTML 类似，不同的是HTML 中都是预定义标签，而XML 中没有预定义标签，全都是自定义标签，用来表示一些数据。 比如说我有一个学生数据：name = “孙悟空” ; age = 18 ; gender = “男” ;用XML 表示： 12345&lt;student&gt; &lt;name&gt;孙悟空&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt;&lt;/student&gt; 现在已经被JSON 取代了。 1&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125; AJAX 的特点AJAX 的优点 可以无需刷新页面而与服务器端进行通信 允许你根据用户事件来更新部分页面内容 AJAX 的缺点 没有浏览历史，不能回退 存在跨域问题(同源) SEO 不友好 HTTP相关问题MDN 文档https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview HTTP 请求交互的基本过程 前后应用从浏览器端向服务器发送HTTP 请求(请求报文) 后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回HTTP响应(响应报文) 浏览器端接收到响应, 解析显示响应体/调用监视回调 HTTP 请求报文请求行123method url``GET /product_detail?id=2``POST /login 多个请求头123Host: www.baidu.com``Cookie: BAIDUID=AD3B0FA706E; BIDUPSID=AD3B0FA706;``Content-Type: application/x-www-form-urlencoded 或者application/json 请求体12username=tom&amp;pwd=123``&#123;&quot;username&quot;: &quot;tom&quot;, &quot;pwd&quot;: 123&#125; HTTP 响应报文 响应状态行: status statusText 多个响应头Content-Type: text/html;charset=utf-8Set-Cookie: BD_CK_SAM=1;path=/ 响应体html 文本/json 文本/js/css/图片... post 请求体参数格式 Content-Type: application/x-www-form-urlencoded;charset=utf-8用于键值对参数，参数的键值用=连接, 参数之间用&amp;连接例如: name=%E5%B0%8F%E6%98%8E&amp;age=12 Content-Type: application/json;charset=utf-8用于 json 字符串参数例如: &#123;&quot;name&quot;: &quot;%E5%B0%8F%E6%98%8E&quot;, &quot;age&quot;: 12&#125; Content-Type: multipart/form-data用于文件上传请求 常见的响应状态码200 OK 请求成功。一般用于GET 与POST 请求201 Created 已创建。成功请求并创建了新的资源401 Unauthorized 未授权/请求要求用户的身份认证404 Not Found 服务器无法根据客户端的请求找到资源500 Internal Server Error 服务器内部错误，无法完成请求 不同类型的请求及其作用 GET: 从服务器端读取数据（查） POST: 向服务器端添加新数据 （增） PUT: 更新服务器端已经数据 （改） DELETE: 删除服务器端数据 （删） API 的分类 REST API: restful （Representational State Transfer (资源)表现层状态转化）(1) 发送请求进行CRUD 哪个操作由请求方式来决定(2) 同一个请求路径可以进行多个操作(3) 请求方式会用到GET/POST/PUT/DELETE 非REST API: restless(1) 请求方式不决定请求的CRUD 操作(2) 一个请求路径只对应一个操作(3) 一般只有GET/POST 区别 一般http请求 与 ajax请求 ajax请求 是一种特别的 http请求 对服务器端来说, 没有任何区别, 区别在浏览器端 浏览器端发请求: 只有XHR 或fetch 发出的才是ajax 请求, 其它所有的都是非ajax 请求 浏览器端接收到响应(1) 一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面(2) ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据 原生AJAX 的基本使用 XHR准备工作安装node.jshttp://nodejs.cn/ 安装express（服务端框架）https://www.expressjs.com.cn/![在这里插入图片描述](https://img-blog.csdnimg.cn/20210209164615378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk3MjAwOA==,size_16,color_FFFFFF,t_70) 初始化环境 1npm init --yes 下载express包 1npm install express --save 编写js代码 123456789101112131415161718// 1. 引入expressconst express = require(&#x27;express&#x27;);// 2. 创建应用对象const app = express();// 3. 创建路由规则// request 是对请求报文的封装// response 是对响应报文的封装app.get(&#x27;/&#x27;, (request, response) =&gt; &#123; // 设置响应 response.send(&quot;Hello Express&quot;);&#125;);// 4. 监听端口，启动服务app.listen(8000, () =&gt; &#123; console.log(&quot;服务已经启动, 8000 端口监听中...&quot;); &#125;) 运行js程序 1node .\\01express使用.js 打开网页显示页面 调试程序可以查看请求和响应 安装nodemon自动重启工具文件内容有修改自动重新启动服务https://www.npmjs.com/package/nodemon安装 1npm install -g nodemon 启动服务 1ndoemon server.js 理解 使用XMLHttpRequest (XHR)对象可以与服务器交互, 也就是发送ajax 请求 前端可以获取到数据，而无需让整个的页面刷新。 这使得Web 页面可以只更新页面的局部，而不影响用户的操作。 https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestXMLHttpRequest，AJAX 的所有操作都是通过该对象进行的 核心对象使用步骤创建XMLHttpRequest 对象1var xhr = new XMLHttpRequest(); 设置请求信息（请求方法和url）1234// 请求方式xhr.open(method, url);//可以设置请求头，一般不设置xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); 发送请求1xhr.send(body) //get请求不传 body 参数，只有post请求使用 接收响应（事件绑定，处理服务端返回的结果）123456789//xhr.responseXML 接收 xml格式 的响应数据//xhr.responseText 接收 文本格式 的响应数据xhr.onreadystatechange = function ()&#123; // readyState 是 xhr对象中的属性, 表示状态 0 1 2 3 4 if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; var text = xhr.responseText; console.log(text); &#125;&#125; 使用案例GET 请求点击返回响应信息创建两个文件，浏览器端使用的html文件和服务器端使用的js文件服务器端 server.js 123456789101112131415161718// 1. 引入expressconst express = require(&#x27;express&#x27;);// 2. 创建应用对象const app = express();// 3. 创建路由规则app.get(&#x27;/server&#x27;, (request, response) =&gt; &#123; // 设置响应头 设置允许跨域 request.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); // 设置响应体 response.send(&quot;Hello Ajax&quot;);&#125;);// 4. 监听服务app.listen(8000, () =&gt; &#123; console.log(&quot;服务已经启动, 8000 端口监听中...&quot;); &#125;) 启动服务 1node server.js 前端页面 html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Ajax GET 请求&lt;/title&gt; &lt;style&gt; #result &#123; width: 200px; height: 100px; border: solid 1px #90b; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; //获取button元素 const btn = document.getElementsByTagName(&#x27;button&#x27;)[0]; const result = document.getElementById(&#x27;result&#x27;); //绑定事件 btn.onclick = function()&#123; // 1. 创建对象 const xhr = new XMLHttpRequest(); // 2. 初始化 设置请求方法和url xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;) // 3. 发送 xhr.send(); // 4. 事件绑定 处理服务端返回的结果 xhr.onreadystatechange = function()&#123; // readyState 是 xhr 对象中的属性, 表示状态 0 1 2 3 4 //判断 (服务端返回了所有的结果) if(xhr.readyState === 4)&#123; //判断响应状态码 200 404 403 401 500 if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; // 处理结果 行 头 空行 体 // 响应 console.log(&#x27;状态码&#x27;, xhr.status); // 状态码 console.log(&#x27;状态字符串&#x27;, xhr.statusText); // 状态字符串 console.log(&#x27;所有响应头&#x27;, xhr.getAllResponseHeaders()); // 所有响应头 console.log(&#x27;响应体&#x27;, xhr.response); // 响应体 //设置 result 的文本 result.innerHTML=xhr.response; &#125;else&#123; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; # GET 请求设置请求参数设置url参数 1xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;); POST请求鼠标放到div中，发post请求，将响应体放在div中呈现 server.js添加post 123456app.post(&#x27;/server&#x27;, (request, response) =&gt; &#123; // 设置响应头, 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); // 设置响应体 response.send(&quot;Hello Ajax POST&quot;);&#125;); post.html 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Ajax POST 请求&lt;/title&gt; &lt;style&gt; #result &#123; width: 200px; height: 100px; border: solid 1px #903; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; // 获取元素对象 const result = document.getElementById(&#x27;result&#x27;); // 绑定事件 result.addEventListener(&quot;mouseover&quot;, function()&#123; // 1. 创建对象 const xhr = new XMLHttpRequest(); // 2. 初始化 设置类型（请求方式）与url xhr.open(&#x27;POST&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;); // 3. 发送 设置请求参数（请求体） xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;); // 4. 事件绑定 xhr.onreadystatechange = function()&#123; // 判断 if(xhr.readyState === 4)&#123; if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300)&#123; // 处理服务端返回的结果 result.innerHTML = xhr.response; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; # 设置请求头信息1234// 设置请求体内容的类型xhr.setRequesHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-from-urlencoded&#x27;);// 自定义头信息xhr.setRequesHeader(&#x27;name&#x27;, &#x27;ykyk&#x27;); server.js中设置响应头允许自定义请求头 post改成all 1response.setHeader(&#x27;Access-Control-Allow-Header&#x27;,&#x27;*&#x27;); json数据请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061app.all(&#x27;/json-server&#x27;, (request, response) =&gt; &#123; // 设置响应头, 设置允许跨域 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); // 设置响应头, 设置允许自定义头信息 response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); // 响应一个数据 const data = &#123; name: &#x27;atguigu&#x27; &#125;; // 对 对象 进行 字符串 转换 let str = JSON.stringify(data) // 设置响应体 response.send(str);&#125;);1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;JSON&lt;/title&gt; &lt;style&gt; #result &#123; width: 200px; height: 100px; border: solid 1px #89b; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; const result = document.getElementById(&#x27;result&#x27;); // 绑定键盘按下事件 window.onkeydown = function()&#123; // 发送请求 const xhr = new XMLHttpRequest(); // *2*.(自动转换) 设置响应体数据的类型(自动转换) xhr.responseType = &#x27;json&#x27;; // 初始化 xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/json-server&#x27;); // 发送 xhr.send(); // 事件绑定 xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; console.log(xhr.response); // 1. 手动对数据转化 (字符串再转换成json) // let data = JSON.parse(xhr.response); //转换成json // result.innerHTML = data.name; // *2*. (自动转换)自动转换(自动转换) result.innerHTML = xhr.response.name; //已经自动变成json &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 请求超时与网络异常12345678910// 超时设置 （2秒）xhr.timeout = 2000;// 超时回调xhr.ontimeout = function()&#123; alert(&#x27;网络超时，请稍后重试&#x27;)&#125;// 网络异常回调xhr.onerror = function()&#123; alert(&#x27;网络异常，请稍后重试&#x27;)&#125; 取消请求12// 手动取消xhr.abort() 请求重复发送问题解决 IE 缓存问题问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。解决方式：浏览器的缓存是根据url 地址来记录的，所以我们只需要修改url 地址即可避免缓存问题 1xhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now()); AJAX 请求状态xhr.readyState 可以用来查看请求当前的状态https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState 0: 表示XMLHttpRequest 实例已经生成，但是open()方法还没有被调用 1: 表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息 2: 表示send()方法已经执行，并且头信息和状态码已经收到 3: 表示正在接收服务器传来的body 部分的数据 4: 表示服务器数据已经完全接收，或者本次接收已经失败了 API总结 XMLHttpRequest()：创建 XHR 对象的构造函数 status：响应状态码值，如 200、404 statusText：响应状态文本，如 ’ok‘、‘not found’ readyState：标识请求状态的只读属性 0-1-2-3-4 onreadystatechange：绑定 readyState 改变的监听 responseType：指定响应数据类型，如果是 ‘json’，得到响应后自动解析响应 response：响应体数据，类型取决于 responseType 的指定 timeout：指定请求超时时间，默认为 0 代表没有限制 ontimeout：绑定超时的监听 onerror：绑定请求网络错误的监听 open()：初始化一个请求，参数为：(method, url[, async]) send(data)：发送请求 abort()：中断请求 （发出到返回之间） getResponseHeader(name)：获取指定名称的响应头值 getAllResponseHeaders()：获取所有响应头组成的字符串 setRequestHeader(name, value)：设置请求头 jQuery 中的AJAXget 请求1$.get(url, [data], [callback], [type]) url:请求的URL 地址 data:请求携带的参数 callback:载入成功时回调函数 type:设置返回内容格式，xml, html, script, json, text, _default post 请求1$.post(url, [data], [callback], [type]) url:请求的URL 地址 data:请求携带的参数 callback:载入成功时回调函数 type:设置返回内容格式，xml, html, script, json, text, _default 通用方法123456789101112131415161718192021$.ajax(&#123; // url url: &#x27;http://127.0.0.1:8000/jquery-server&#x27;, // 参数 data: &#123;a:100, b:200&#125;, // 请求类型 type: &#x27;GET&#x27;, // 响应体结果 dataType: &#x27;json&#x27;, // 成功的回调 success: function(data)&#123;console.log(data);&#125;, // 超时时间 timeout: 2000, // 失败的回调 error: function()&#123;console.log(&#x27;出错拉~&#x27;);&#125;, // 头信息 headers: &#123; c: 300, d: 400 &#125; &#125;) 跨域同源策略 同源策略(Same-Origin Policy)最早由Netscape 公司提出，是浏览器的一种安全策略 同源： 协议、域名、端口号必须完全相同 跨域： 违背同源策略就是跨域 如何解决跨域JSONP1) JSONP 是什么JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get 请求。 2) JSONP 怎么工作的？在网页有一些标签天生具有跨域能力，比如：img link iframe script。JSONP 就是利用script 标签的跨域能力来发送请求的。 3) JSONP 的使用1.动态的创建一个script 标签1var script = document.createElement(&quot;script&quot;); 2.设置script 的src，设置回调函数1234script.src = &quot;http://localhost:3000/testAJAX?callback=abc&quot;;function abc(data) &#123; alert(data.name);&#125;; 3.将script 添加到body 中1document.body.appendChild(script); 4.服务器中路由的处理123456789router.get(&quot;/testAJAX&quot; , function (req , res) &#123; console.log(&quot;收到请求&quot;); var callback = req.query.callback; var obj = &#123; name:&quot;孙悟空&quot;, age:18 &#125; res.send(callback+&quot;(&quot;+JSON.stringify(obj)+&quot;)&quot;);&#125;); 4) jQuery 中的JSONP12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt; &lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./jquery-1.12.3.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var btn = document.getElementById(&#x27;btn&#x27;) btn.onclick = function () &#123; $.getJSON(&quot;http://api.douban.com/v2/movie/in_theaters?callback=?&quot;,function(data) &#123; console.log(data); //获取所有的电影的条目 var subjects = data.subjects; //遍历电影条目 for(var i=0 ; i&lt;subjects.length ; i++)&#123; $(&quot;#list&quot;).append(&quot;&lt;li&gt;&quot;+ subjects[i].title+&quot;&lt;br /&gt;&quot;+ &quot;&lt;img src=\\&quot;&quot;+subjects[i].images.large+&quot;\\&quot; &gt;&quot;+ &quot;&lt;/li&gt;&quot;); &#125; &#125;); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CORShttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS 1) CORS 是什么？CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持get 和post 请求。跨域资源共享标准新增了一组HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源 2) CORS 怎么工作的？CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。 3) CORS 的使用主要是服务器端的设置： 123456router.get(&quot;/testAJAX&quot; , function (req , res) &#123; //通过res 来设置响应头，来允许跨域请求 //res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:3000&quot;); res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); res.send(&quot;testAJAX 返回的响应&quot;);&#125;);","categories":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/categories/AJAX/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"Ajax前后端交互利器详解(二)","slug":"Ajax前后端交互利器详解(二)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T06:48:11.772Z","comments":true,"path":"2022/04/24/Ajax前后端交互利器详解(二)/","link":"","permalink":"http://example.com/2022/04/24/Ajax%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%88%A9%E5%99%A8%E8%AF%A6%E8%A7%A3(%E4%BA%8C)/","excerpt":"","text":"参考配套视频：web前后端交互 Ajax 同源政策Ajax请求限制Ajax 只能向自己的服务器发送请求。比如现在有一个A网站、有一个B网站，A网站中的 HTML 文件只能向A网站服务器中发送 Ajax 请求，B网站中的 HTML 文件只能向 B 网站中发送 Ajax 请求，但是 A 网站是不能向 B 网站发送 Ajax请求的，同理，B 网站也不能向 A 网站发送 Ajax请求。 什么是同源如果两个页面拥有相同的协议、域名和端口，那么这两个页面就属于同一个源，其中只要有一个不相同，就是不同源 例如我们开启两个服务器，一个端口是3000，另一个端口是3001 12345678910111213141516171819202122232425// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 监听端口app.listen(3000);12345678910// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 创建路由app.get(&#x27;/test&#x27;, (req, res) =&gt; &#123; res.send(&quot;ok&quot;);&#125;);// 监听端口app.listen(3001); 我们在端口为3000的客户端发送ajax请求至端口为3001的服务器 123456789101112&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/ajax.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; ajax(&#123; url: &#x27;http://localhost:3001/test&#x27;, type: &#x27;get&#x27;, success: function (result) &#123; console.log(result); &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 同源政策的目的 同源政策是为了保证用户信息的安全，防止恶意的网站窃取数据。最初的同源政策是指 A 网站在客户端设置的 Cookie，B网站是不能访问的。 随着互联网的发展，同源政策也越来越严格，在不同源的情况下，其中有一项规定就是无法向非同源地址发送Ajax 请求，如果请求，浏览器就会报错 使用JSONP解决同源限制问题jsonp 是 json with padding 的缩写，它不属于 Ajax 请求，但它可以模拟 Ajax 请求 将不同源的服务器端请求地址写在 script 标签的 src 属性中 1234&lt;script src=&quot;www.example.com&quot;&gt;&lt;/script&gt;&lt;script src=“https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; 服务器端响应数据必须是一个函数的调用，真正要发送给客户端的数据需要作为函数调用的参数。 12const data = &#x27;fn(&#123;name: &quot;张三&quot;, age: &quot;20&quot;&#125;)&#x27;;res.send(data); 在客户端全局作用域下定义函数 fn 注意要将函数定义放在 script 标签的前面，因为 script 标签加载完服务器端的响应内容以后会直接调用这个准备好的函数，如果客户端没有定义这个函数，函数在调用时找不到这个函数的定义部分，代码将会报错 123function fn (data) &#123; &#125; 在 fn 函数内部对服务器端返回的数据进行处理 123function fn (data) &#123; console.log(data); &#125; 示例我们开启两个服务器，一个端口是3000，另一个端口是3001，我们在端口为3000的客户端发送ajax请求至端口为3001的服务器 1234567891011&lt;body&gt; &lt;script&gt; function fn (data) &#123; // 在客户端定义函数 console.log(&#x27;客户端的fn函数被调用了&#x27;) console.log(data); &#125; &lt;/script&gt; &lt;!-- 1.将非同源服务器端的请求地址写在script标签的src属性中 --&gt; &lt;script src=&quot;http://localhost:3001/test&quot;&gt;&lt;/script&gt;&lt;/body&gt; 在服务器端调用函数 12345678910111213141516// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 创建路由app.get(&#x27;/test&#x27;, (req, res) =&gt; &#123; // 在服务器调用函数 const result = &#x27;fn(&#123;name: &quot;张三&quot;&#125;)&#x27;; res.send(result);&#125;);// 监听端口app.listen(3001); JSONP代码优化 客户端需要将函数名称传递到服务器端 将 script 请求的发送变成动态请求。 12345678910&lt;body&gt; &lt;script&gt; function fn (data) &#123; console.log(&#x27;客户端的fn函数被调用了&#x27;) console.log(data); &#125; &lt;/script&gt; &lt;!-- 1.将非同源服务器端的请求地址写在script标签的src属性中 --&gt; &lt;script src=&quot;http://localhost:3001/better?callback=fn&quot;&gt;&lt;/script&gt;&lt;/body&gt; 在非同源服务器端进行接收客户端传递的函数名称 123456789101112131415161718// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 创建路由app.get(&#x27;/better&#x27;, (req, res) =&gt; &#123; // 接收客户端传递过来的函数的名称 const fnName = req.query.callback; // 将函数名称对应的函数调用代码返回给客户端 const result = fnName + &#x27;(&#123;&quot;name&quot;: &quot;张三&quot;&#125;)&#x27;; res.send(result);&#125;);// 监听端口app.listen(3001); 我们将函数名称进行改变为f1，也使得 callback 的值改变为f1 封装 jsonp 函数，方便请求发送 123456789101112131415161718192021222324function jsonp (options) &#123; // 动态创建script标签 var script = document.createElement(&#x27;script&#x27;); // 拼接字符串的变量 var params = &#x27;&#x27;; for (var attr in options.data) &#123; params += &#x27;&amp;&#x27; + attr + &#x27;=&#x27; + options.data[attr]; &#125; // myJsonp0124741 var fnName = &#x27;myJsonp&#x27; + Math.random().toString().replace(&#x27;.&#x27;, &#x27;&#x27;); // 它已经不是一个全局函数了 // 我们要想办法将它变成全局函数 window[fnName] = options.success; // 为script标签添加src属性 script.src = options.url + &#x27;?callback=&#x27; + fnName + params; // 将script标签追加到页面中 document.body.appendChild(script); // 为script标签添加onload事件 script.onload = function () &#123; document.body.removeChild(script); &#125;&#125; 我们也可以说是封装了 JSONP 函数，我们可以将 JSONP 抽离为 jsonp.js文件，这样我们在客户端就可以引入 jsonp.js 文件使用了 服务器端代码优化之 res.jsonp 方法。 服务器端接收客户端传递过来的函数名称，并且拼接函数调用，在函数调用的内部，我们还需要将真实的数据写在里面，如果数据是从数据库查出来的 json 对象，我们还需要先转换成 json 字符串，比较麻烦，express 框架给我们 res 下提供了 res.jsonp 方法 123app.get(&#x27;/better&#x27;,(req,res)=&gt;&#123; res.jsonp(&#123;name:&quot;lisi&quot;,age:20&#125;)&#125;) CORS跨域资源共享CORS：全称为 Cross-origin resource sharing，即跨域资源共享，它允许浏览器向跨域服务器发送 Ajax 请求，克服了 Ajax 只能同源使用的限制。 访问非同源数据服务器端同源政策是浏览器给予 Ajax 技术的限制，服务器端是不存在同源政策限制，服务器端可以直接访问非同源网站中的数据。 所以对于客户端来讲，如果要获取非同源网站中的数据，可以让自己的服务器端获取非同源网站中的数据，等到自己的服务器端获取到数据之后，自己网站的服务器端再将数据响应到客户端，这样就绕过了浏览器的同源政策限制。 我们开启两个服务器，一个端口是3000，另一个端口是3001 客户端代码如下： 客户端访问自己的服务器 123456789101112131415161718&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;点我发送请求&lt;/button&gt; &lt;script src=&quot;/js/ajax.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 获取按钮 var btn = document.getElementById(&#x27;btn&#x27;); // 为按钮添加点击事件 btn.onclick = function () &#123; ajax(&#123; type: &#x27;get&#x27;, url: &#x27;http://localhost:3000/server&#x27;, success: function (data) &#123; console.log(data); &#125; &#125;) &#125;; &lt;/script&gt;&lt;/body&gt; 服务器3000端代码如下: 服务器端获取非同源网站的数据，需要引入第三方模块 request 1234567891011121314151617181920212223// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 向其他服务器端请求数据的模块const request = require(&#x27;request&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.get(&#x27;/server&#x27;, (req, res) =&gt; &#123; request(&#x27;http://localhost:3001/cross&#x27;, (err, response, body) =&gt; &#123; /** * 第一个参数是请求地址 * 第二个参数是回调函数 */ res.send(body); &#125;)&#125;);// 监听端口app.listen(3000); 服务器3001端的代码如下： 1234567891011121314// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 创建路由app.get(&#x27;/cross&#x27;, (req, res) =&gt; &#123; res.send(&#x27;ok&#x27;)&#125;);// 监听端口app.listen(3001); CORS跨域资源共享12345origin: http://localhost:3000Access-Control-Allow-Origin: &#x27;http://localhost:3000&#x27; Access-Control-Allow-Origin: &#x27;*&#x27; Node 服务器端设置响应头示例代码： 123456app.use((req, res, next) =&gt; &#123; res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;GET, POST&#x27;); next(); &#125;) withCredentials属性使用Ajax技术发送跨域请求时，默认情况下不会在请求中携带cookie信息。但是如果两台服务器都是我们自己的，我们想要实现跨域请求，需要在客户端和服务器端进行处理 在客户端 ajax 对象下有一个属性： withCredentials：指定在涉及到跨域请求时，是否携带cookie信息，默认值为false 在服务器端响应头中设置字段 Access-Control-Allow-Credentials：true 允 许客户端发送请求时携带cookie jQuery中的Ajax$.ajax()方法概述$.ajax()方法作用：发送 Ajax 请求 发送Ajax请求1234567891011$.ajax(&#123; type: &#x27;get&#x27;, url: &#x27;http://www.example.com&#x27;, data: &#123; name: &#x27;zhangsan&#x27;, age: &#x27;20&#x27; &#125;, contentType: &#x27;application/x-www-form-urlencoded&#x27;, beforeSend: function () &#123; return false &#125;, success: function (response) &#123;&#125;, error: function (xhr) &#123;&#125;&#125;); type：代表请求方式 url：代表请求地址 data：代表向服务器端发送的请求参数，它可以是一个对象，在内部会将其转化为参数字符串，除了传递对象以外，我们也可以传递字符串参数值,在内部都会将其转化为参数字符串进行发送 123&#123; data: &#x27;name=zhangsan&amp;age=20&#x27;&#125; contentType：告诉服务器端客户端要向服务器端传递的参数格式类型，默认是application/x-www-form-urlencoded,也就是 参数名 = 参数值，多个参数之间用 &amp; 分隔的参数字符串，如果传递的是 json 格式的请求参数,需要将 contentType 进行如下替换 123&#123; contentType: &#x27;application/json&#x27;&#125; 然后在 data 中传递 json 格式字符串,需要通过 JSON.stringify 将json对象转换为字符串 1JSON.stringfy(&#123; name: &#x27;zhangsan&#x27;, age: &#x27;20&#x27; &#125;) beforeSend：允许我们在请求发送之前做一些事，是一个函数，比如在请求发送之前我们可以对请求参数进行格式验证，格式不正确，return false 请求便不会发送了 success：是一个函数，请求发送成功之后就会被调用，有一个形参，这个形参就是服务器端返回的数据 error：是一个函数，请求失败之后就会被调用，接收一个 ajax 对象，我们可以在对象中获取错误信息，并且根据错误信息做出错误处理 例如，点击按钮发送 ajax 请求,客户端代码如下： 123456789101112131415161718192021222324&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;发送请求&lt;/button&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;#btn&#x27;).on(&#x27;click&#x27;, function () &#123; $.ajax(&#123; // 请求方式 type: &#x27;get&#x27;, // 请求地址 url: &#x27;http://localhost:3000/base&#x27;, // 请求成功以后函数被调用 success: function (response) &#123; // response为服务器端返回的数据 // 方法内部会自动将json字符串转换为json对象 console.log(response); &#125;, // 请求失败以后函数被调用 error: function (xhr) &#123; console.log(xhr) &#125; &#125;) &#125;); &lt;/script&gt;&lt;/body&gt; 服务器端代码如下： 1234567891011121314151617// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.get(&#x27;/base&#x27;, (req, res) =&gt; &#123; res.send(&#123; name: &#x27;zhangsan&#x27;, age: 30 &#125;)&#125;);// 监听端口app.listen(3000); 如果我们是 post 请求方式: 客户端代码如下： 123456789101112131415161718192021222324&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;发送请求&lt;/button&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;#btn&#x27;).on(&#x27;click&#x27;, function() &#123; $.ajax(&#123; // 请求方式 type: &#x27;post&#x27;, // 请求地址 url: &#x27;http://localhost:3000/base&#x27;, // 请求成功以后函数被调用 success: function(response) &#123; // response为服务器端返回的数据 // 方法内部会自动将json字符串转换为json对象 console.log(response); &#125;, // 请求失败以后函数被调用 error: function(xhr) &#123; console.log(xhr) &#125; &#125;) &#125;); &lt;/script&gt;&lt;/body&gt; 服务器端代码如下： 123456789101112131415161718// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.post(&#x27;/base&#x27;, (req, res) =&gt; &#123; res.send(&#123; name: &#x27;zhaoliu&#x27;, age: 35 &#125;)&#125;);// 监听端口app.listen(3000); 若我们请求地址的协议，域名，端口都一样，我们请求地址url也可以省略,只用书写路由即可 123456789101112131415161718192021222324&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;发送请求&lt;/button&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;#btn&#x27;).on(&#x27;click&#x27;, function() &#123; $.ajax(&#123; // 请求方式 type: &#x27;post&#x27;, // 请求地址 url: &#x27;/base&#x27;, // 请求成功以后函数被调用 success: function(response) &#123; // response为服务器端返回的数据 // 方法内部会自动将json字符串转换为json对象 console.log(response); &#125;, // 请求失败以后函数被调用 error: function(xhr) &#123; console.log(xhr) &#125; &#125;) &#125;); &lt;/script&gt;&lt;/body&gt; $.ajax方法传递请求参数客户端代码如下： 1234567891011121314151617181920212223242526&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;发送请求&lt;/button&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;#btn&#x27;).on(&#x27;click&#x27;, function () &#123; $.ajax(&#123; // 请求方式 type: &#x27;post&#x27;, // 请求地址 url: &#x27;/user&#x27;, // 向服务器端发送的请求参数 data: &#123; name: &#x27;zhangsan&#x27;, age: 100 &#125;, // data: &#x27;name=zhangsan&amp;age=100&#x27; 也可以这样传递 // 请求成功以后函数被调用 success: function (response) &#123; // response为服务器端返回的数据 // 方法内部会自动将json字符串转换为json对象 console.log(response); &#125; &#125;) &#125;); &lt;/script&gt;&lt;/body&gt; 如果我们要传递json格式的字符串， 改变 contentType 为 application/json 需要通过 JSON.stringify 将json对象转换为字符串传递，请求成功服务器端响应回来 success 方法内部又会自动将 json字符串 转换为 json对象 客户端代码如下： 1234567891011121314151617181920212223242526&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;发送请求&lt;/button&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // json 对象 var params = &#123;name: &#x27;wangwu&#x27;, age: 300&#125; $(&#x27;#btn&#x27;).on(&#x27;click&#x27;, function() &#123; $.ajax(&#123; // 请求方式 type: &#x27;post&#x27;, // 请求地址 url: &#x27;/user&#x27;, data: JSON.stringify(params), // 指定参数的格式类型 // 将json对象转换为字符串传递 contentType: &#x27;application/json&#x27;, // 请求成功以后函数被调用 success: function(response) &#123; // response为服务器端返回的数据 // 方法内部会自动将json字符串转换为json对象 console.log(response); &#125; &#125;) &#125;); &lt;/script&gt;&lt;/body&gt; serialize方法作用：将表单中的数据自动拼接成 参数名 = 参数值且多个参数之间用&amp;连接的字符串 类型的参数 123var params = $(&#x27;#form&#x27;).serialize();// name=zhangsan&amp;age=3012 客户端代码如下： 1234567891011121314151617&lt;body&gt; &lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&#x27;#form&#x27;).on(&#x27;submit&#x27;, function() &#123; // 将表单内容拼接成字符串类型的参数 var params = $(&#x27;#form&#x27;).serialize(); console.log(params); return false; &#125;); &lt;/script&gt;&lt;/body&gt; 此时我们将表单内容拼接成字符串类型的参数，但是如果我们需要将表单用户输入的内容转换为对象类型，jquery 并没有给我们封装，我们需要自己封装 视频讲解地址：https://www.bilibili.com/video/BV1ji4y1876Y?p=49 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&#x27;#form&#x27;).on(&#x27;submit&#x27;, function() &#123; // 将表单中用户输入的内容转换为对象类型 var params = $(&#x27;#form&#x27;).serialize(); serializeObject($(this)); return false; &#125;); // 将表单中用户输入的内容转换为对象类型 function serializeObject(obj) &#123; // 处理结果对象 var result = &#123;&#125;; // [&#123;name: &#x27;username&#x27;, value: &#x27;用户输入的内容&#x27;&#125;, &#123;name: &#x27;password&#x27;, value: &#x27;123456&#x27;&#125;] var params = obj.serializeArray(); // 循环数组 将数组转换为对象类型 $.each(params, function(index, value) &#123; result[value.name] = value.value; &#125;) // 将处理的结果返回到函数外部 return result; &#125; &lt;/script&gt;&lt;/body&gt; 发送jsonp请求12345678910$.ajax(&#123; url: &#x27;http://www.example.com&#x27;, // 指定当前发送jsonp请求 dataType: &#x27;jsonp&#x27;, // 修改callback参数名称 jsonp: &#x27;cb&#x27;, // 指定函数名称 jsonCallback: &#x27;fnName&#x27;, success: function (response) &#123;&#125; &#125;) dataType：jsonp 表示指定当前发送jsonp请求 jsonp：cb 表示修改callback参数名称(可选) jsonCallback：fnName 表示指定函数名称(可选) 例如，客户端代码如下： 1234567891011121314151617&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;发送请求&lt;/button&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;#btn&#x27;).on(&#x27;click&#x27;, function() &#123; $.ajax(&#123; url: &#x27;/jsonp&#x27;, // 代表现在要发送的是jsonp请求 dataType: &#x27;jsonp&#x27;, // 请求成功会调用success函数,形参是服务器端传给我们的数据 success: function(response) &#123; console.log(response) &#125; &#125;) &#125;); &lt;/script&gt;&lt;/body&gt; 服务器端路由如下： 123456app.get(&#x27;/jsonp&#x27;, (req, res) =&gt; &#123; res.jsonp(&#123; name: &#x27;lisi&#x27;, age: 50 &#125;)&#125;); 有的服务器端不是通过 callback 来接收客户端传递过来的函数名称，而是换成了简写 cb，这样我们就需要传递 jsonp:cb jsonCallback：fnName 表示指定函数名称，正常来说，请求成功后会调用 success 函数，但是如果我们不想调用它，我们也可以自己传递函数名字，然后在客户端自己准备好这个函数的定义部分 例如：客户端代码如下： 123456789101112131415161718192021222324&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;发送请求&lt;/button&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function fn(response) &#123; console.log(response) &#125; $(&#x27;#btn&#x27;).on(&#x27;click&#x27;, function() &#123; $.ajax(&#123; url: &#x27;/jsonp&#x27;, // 向服务器端传递函数名字的参数名称 jsonp: &#x27;cb&#x27;, // 指定函数名称 jsonpCallback: &#x27;fn&#x27;, // 代表现在要发送的是jsonp请求 dataType: &#x27;jsonp&#x27;, success: function(response) &#123; console.log(response) &#125; &#125;) &#125;); &lt;/script&gt;&lt;/body&gt; 服务器端路由如下： 12345app.get(&#x27;/jsonp&#x27;, (req, res) =&gt; &#123; const cb = req.query.cb const data = cb + &quot;(&#123;name: &#x27;zhaoliu&#x27;&#125;)&quot; res.send(data);&#125;); .get().post()方法概述作用：$.get方法用于发送get请求，$.post方法用于发送post请求 1234$.get(&#x27;http://www.example.com&#x27;, &#123;name: &#x27;zhangsan&#x27;, age: 30&#125;, function (response) &#123;&#125;) $.post(&#x27;http://www.example.com&#x27;, &#123;name: &#x27;lisi&#x27;, age: 22&#125;, function (response) &#123;&#125;)123 例如： 123456789101112131415&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;发送请求&lt;/button&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&#x27;#btn&#x27;).on(&#x27;click&#x27;, function () &#123; $.get(&#x27;/base&#x27;, &#x27;name=zhangsan&amp;age=30&#x27;, function (response) &#123; console.log(response) &#125;) //$.post(&#x27;/base&#x27;, function (response) &#123; // console.log(response) //&#125;) &#125;); &lt;/script&gt;&lt;/body&gt; RESTful风格的API传统请求地址回顾 这样的请求地址在使用上是没有问题的，但是语义比较混乱，例如：删除用户信息问号后面还要跟获取用户信息的 id，又比如删除用户有些人开发使用 remove、有的人开发使用 delete，这样就没有一套统一的请求地址。而 RESTful 就是为了解决这样的问题。 RESTful API概述一套关于设计请求的规范。 我们看请求方式的设置如下： GET请求方式： 获取数据 POST请求方式： 添加数据 PUT请求方式： 更新数据 DELETE请求方式： 删除数据 注意：传统的HTML表单是不支持 PUT请求方式 和DELETE请求方式的，但是在Ajax中是支持的 我们看请求地址的设置如下： users =&gt; /users articles =&gt; /articles RESTful API的实现 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;script src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 获取用户列表信息 $.ajax(&#123; type: &#x27;get&#x27;, url: &#x27;/users&#x27;, success: function (response) &#123; console.log(response) &#125; &#125;) // 获取id为1的用户信息 $.ajax(&#123; type: &#x27;get&#x27;, url: &#x27;/users/1&#x27;, success: function (response) &#123; console.log(response) &#125; &#125;) // 获取id为1的用户信息 $.ajax(&#123; type: &#x27;delete&#x27;, url: &#x27;/users/10&#x27;, success: function (response) &#123; console.log(response) &#125; &#125;) // 获取id为1的用户信息 $.ajax(&#123; type: &#x27;put&#x27;, url: &#x27;/users/10&#x27;, success: function (response) &#123; console.log(response) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/categories/AJAX/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"Nodejs基础之JavaScript模块化(一)","slug":"Nodejs基础之JavaScript模块化(一)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T08:52:25.374Z","comments":true,"path":"2022/04/24/Nodejs基础之JavaScript模块化(一)/","link":"","permalink":"http://example.com/2022/04/24/Nodejs%E5%9F%BA%E7%A1%80%E4%B9%8BJavaScript%E6%A8%A1%E5%9D%97%E5%8C%96(%E4%B8%80)/","excerpt":"","text":"✍目录脑图 参考视频： Node.js 黑马程序员 Node.js大地老师讲解 JavaScript模块化什么是模块化开发呢？ 事实上模块化开发最终的目的是将程序划分成一个个小的结构 这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构 这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用 也可以通过某种方式，导入另外结构中的变量、函数、对象等 上面说提到的结构，就是模块；按照这种结构划分开发程序的过程，就是模块化开发的过程 CommonJS我们需要知道CommonJS是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为ServerJS，后来为了体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS。 Node是CommonJS在服务器端一个具有代表性的实现 Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发 在Node中每一个js文件都是一个单独的模块 这个模块中包括 CommonJS规范的核心变量：exports、module.exports、require 我们可以使用这些变量来方便的进行模块化开发 模块化的核心是导出和导入，Node中对其进行了实现： exports和module.exports可以负责对模块中的内容进行导出 require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容 自定义模块的规定 我们可以把公共的功能抽离成为一个单独的 js 文件作为一个模块，Node.js规定一个 JavaScript 文件就是一个模块，模块内部定义的变量和函数默认情况下外部无法得到。如果要让外部可以访问模块里面的方法或属性，就必须在模块里面通过exports 或者 module.exports 暴露属性或者方法 在需要使用这些模块的文件中，通过 require 的方式引入这个模块。这个时候就可以使用模块里面暴露的属性和方法 注意： require 里面的路径要加 单引号 require 里面引入的模块可以跟后缀 .js，也可以不跟后缀 .js 若我们要暴露的是对象(属性)，则建议使用 module.exports ;若我们要暴露的是方法，则建议使用exports 我们以后的自定义模块都会放在 node_modules 文件夹下，此时引入不需要添加 node_modules 路径也可以引入 ES ModuleJavaScript没有模块化一直是它的痛点，所以才会产生我们前面学习的社区规范：CommonJS、AMD、CMD等， 所以在ES推出自己的模块化系统时，大家也是兴奋异常。 ES Module和CommonJS的模块化有一些不同之处： 一方面它使用了import和export关键字 另一方面它采用编译期的静态分析，并且也加入了动态引用的方式 ES Module模块采用export和import关键字来实现模块化 export负责将模块内的内容导出 import负责从其他模块导入内容 export关键字export关键字将一个模块中的变量、函数、类等导出 export 指令用于导出变量，比如下面的代码 1234// info.jsexport let name = &#x27;why&#x27;export let age = 18export let height = 1.88 上面的代码还有另外一种写法 123456// info.jslet name = &#x27;why&#x27;let age = 18let height = 1.88export&#123;name,age,height&#125; 导出函数或类上面我们主要是输出变量，也可以输出函数或者输出类 123456789101112export function test(content)&#123; console.log(content);&#125;export class Person &#123; constructor(name,age)&#123; this.name = name; this.age = age &#125; run()&#123; console.log(this.name + &#x27;在奔跑&#x27;); &#125;&#125; 上面的代码也可以写成这种形式 123456789101112131415function test(content) &#123; console.log(content);&#125;class Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; run() &#123; console.log(this.name + &#x27;在奔跑&#x27;) &#125;&#125;export &#123;test,Person&#125; export default 某些情况下，一个模块中包含某个功能，我们并不希望给这个功能命名，而是让导入者可以自己来命名 这个时候就可以使用 export default 1234// info.jsexport default function() &#123; console.log(&#x27;default function&#x27;)&#125; 我们来到 main.js 中，这样使用就可以了 这里的 myFunc 是我自己命名的，你可以根据需要命名它对应的名字 123import myFunc form &#x27;./info.js&#x27;myFunc() 另外，需要注意： export default 在同一个模块中，不允许同时存在多个 ES6 import的使用我们使用 export 指令导出了模块对外提供的接口，下面我们就可以通过 import 命令来加载对应的这个模块了 首先，我们需要在 HTML 代码中引入两个j文件，并且类型需要设置为 module 12&lt;script src = &quot;info.js&quot; type = &quot;module&quot;&gt;&lt;/script&gt;&lt;script src = &quot;main.js&quot; type = &quot;module&quot;&gt;&lt;/script&gt; import 指令用于导入模块中的内容，比如 main.js 的代码 123import &#123;name,age,height&#125; from &quot;./info.js&quot;console.log(name,age,height); 如果我们希望某个模块中所有的信息都导入，一个个导入显然有些麻烦 p通过*可以导入模块中所有的export变量 p但是通常情况下我们需要给*起一个别名，方便后续的使用 123import * as info from &#x27;./info.js&#x27;console.log(info.name,info.age,info.height);","categories":[{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"模块化开发","slug":"模块化开发","permalink":"http://example.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"Express框架","slug":"Express框架","permalink":"http://example.com/tags/Express%E6%A1%86%E6%9E%B6/"}]},{"title":"Nodejs基础之常用模块(三)","slug":"Nodejs基础之常用模块(三)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T09:02:55.306Z","comments":true,"path":"2022/04/24/Nodejs基础之常用模块(三)/","link":"","permalink":"http://example.com/2022/04/24/Nodejs%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97(%E4%B8%89)/","excerpt":"","text":"✍ 目录脑图 参考视频： Node.js 黑马程序员 Node.js大地老师讲解 ✍Node是什么 Node 是一个基于 Chrome V8 引擎的 JavaScript 代码运行环境。 浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境 Node（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境 Node文档中文网：http://nodejs.cn/api/url.html#url_new_url_input_base 第一个Node程序 新建 app.js 输入代码块 node-http-server,自动生成 Node 结构（安装插件：Node-snippets就可以快捷生成） 在终端使用 node app.js 运行程序 假如要停止我们的服务器，在终端处按 ctrl + c 停止服务器 解析第一个Node程序 引入 http 模块 1var http = require(&quot;http&quot;); 创建服务器 接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 3000 端口。函数通过 request、response 参数来接收和响应数据 12345678910111213141516//表示引入http模块var http = require(&#x27;http&#x27;);/* request 获取客户端(浏览器)传过来的信息 response 给浏览器响应信息*/http.createServer(function (request, response) &#123; //发送响应头 //设置HTTP头部,状态码是200,文件类型是 html,字符集是 utf8 response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27;&#125;); //表示给我们页面上面输出一句话并且结束响应 response.end(&#x27;Hello World&#x27;);&#125;).listen(3000); //监听端口 内置模块HTTPNode.js中，将很多的功能，划分为一个个 module(模块)。 Node.js 中的很多功能都是通过模块实现。 12345678910111213141516//表示引入http模块var http = require(&#x27;http&#x27;);/* request 获取客户端(浏览器)传过来的信息 response 给浏览器响应信息*/http.createServer(function (request, response) &#123; //发送响应头 //设置HTTP头部,状态码是200,文件类型是 html,字符集是 utf8 response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27;&#125;); //表示给我们页面上面输出一句话并且结束响应 response.end(&#x27;Hello World&#x27;);&#125;).listen(3000); //监听端口 那我们如果想在屏幕上输出汉字呢？ 1234567891011var http = require(&#x27;http&#x27;);http.createServer(function(request, response) &#123; //发送响应头 response.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); //表示给我们页面上面输出一句话并且结束响应 response.write(&#x27;你好 Nodejs&#x27;); response.end(&#x27;&lt;h2&gt;你好 Nodejs&lt;/h2&gt;&#x27;);&#125;).listen(3000); //监听端口 如何解决 Preview 里面的乱码状态呢？只需要在http.createServer中添加下方代码即可 1res.write(&quot;&lt;head&gt; &lt;meta charset=&#x27;UTF-8&#x27;&gt;&lt;/head&gt;&quot;); //解决乱码 创建服务器创建服务器对象，我们是通过 createServer 来完成的 req：request请求对象，包含请求相关的信息 res：response响应对象，包含我们要发送给客户端的信息 监听主机和端口号通过listen方法来开启服务器，并且在某一个主机和端口上监听网络请求 listen函数有三个参数： 端口port: 可以不传, 系统会默认分配端 主机host: 通常可以传入localhost、ip地址127.0.0.1,或者ip地址0.0.0.0，默认是0.0.0.0 回调函数：服务器启动成功时的回调函数 1234// 启动服务器,并且制定端口号和主机server.listen(8888, &#x27;0.0.0.0&#x27;, () =&gt; &#123; console.log(&quot;服务器启动成功~&quot;);&#125;); request对象在向服务器发送请求时，我们会携带很多信息，比如： 本次请求的URL，服务器需要根据不同的URL进行不同的处理 本次请求的请求方式，比如GET、POST请求传入的参数和处理的方式是不同的 本次请求的 headers 中也会携带一些信息，比如客户端信息、接受数据的格式、支持的编码格式等 这些信息，Node会帮助我们封装到一个request的对象中，我们可以直接来处理这个request对象 12345678910111213141516const http = require(&#x27;http&#x27;);// 创建一个web服务器const server = http.createServer((req, res) =&gt; &#123; // request对象中封装了客户端给我们服务器传递过来的所有信息 console.log(req.url); console.log(req.method); console.log(req.headers); res.end(&quot;Hello Server&quot;);&#125;);// 启动服务器,并且制定端口号和主机server.listen(8888, &#x27;0.0.0.0&#x27;, () =&gt; &#123; console.log(&quot;服务器启动成功~&quot;);&#125;); URL的处理客户端在发送请求时，会请求不同的数据，那么会传入不同的请求地址： 比如http://localhost:8000/login 比如http://localhost:8000/products 服务器端需要根据不同的请求地址，作出不同的响应 1234567891011// 创建一个web服务器const server = http.createServer((req, res) =&gt; &#123; //最基本的使用方式 if (req.url === &#x27;/login&#x27;) &#123; res.end(&quot;欢迎回来~&quot;); &#125; else if (req.url === &#x27;/users&#x27;) &#123; res.end(&quot;用户列表~&quot;); &#125; else &#123; res.end(&quot;错误请求, 检查~&quot;); &#125; 那么如果用户发送的地址中还携带一些额外的参数呢？ 比如：http://localhost:8000/login?name=why&amp;password=123 这个时候，url的值是 /login?name=why&amp;password=123 我们如何对它进行解析呢？使用内置模块url url模块旧版url API我们来看一下 req 里面能够使用的东西。 最重要的是 req.url 属性，表示用户的请求URL 地址。所有路由设计，都是通过 req.url 来实现的。 1234567891011121314const http = require(&#x27;http&#x27;);http.createServer(function(request, response) &#123; console.log(request.url); //发送响应头 response.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=&quot;UTF-8&quot;&#x27; &#125;); //表示给我们页面上面输出一句话并且结束响应 response.write(&#x27;你好 Nodejs&#x27;); response.end(&#x27;&lt;h2&gt;你好 Nodejs&lt;/h2&gt;&#x27;);&#125;).listen(3000); //监听端口 这里注意一下输出是在 Nodejs 控制台输出，而不是在浏览器上输出。因为输出是在服务端，浏览器是客户端 我们比较关心的不是拿到 URL，而是识别这个 URL。 识别 URL，下面的 url 模块 旧版本 Node 的 url 用法如下： url模块的使用 说明 url.parse() 解析 url(第二个参数为true,可以将 query 里面的数据转换为对象) url.format(urlObject) 是上面 url.parse() 操作的逆向操作 url.resolve(from,to) 添加或者替换地址 123456789101112const url = require(&#x27;url&#x27;);var api = &#x27;http://www.itying.com?name=zhangsan&amp;age=20&#x27;;//console.log(url.parse(api, true));var getValue = url.parse(api, true).query;console.log(getValue);// ES6中模板字符串写法console.log(`姓名：$&#123;getValue.name&#125;--年龄:$&#123;getValue.age&#125;`); 新版url API新版本 Node 的 url 用法如下： ```new URL(input,[,base])123456789101112131415 ： - `input` 类型：String，要解析的绝对或相对的输入网址。如果 input 是相对的，则需要 base。如果 input 是绝对的，则忽略 base。```jsconst myURL = new URL(&#x27;/foo&#x27;, &#x27;https://example.org/&#x27;);// https://example.org/foo12const url = require(&#x27;url&#x27;);const myURL = new URL( &quot;http://localhost:3000/p/a/t/h?name=zhangsan&amp;age=20#hash&quot;);console.log(myURL); searchParamssearchParams 可以获取到 url 参数的 value 123456789101112const myURL = new URL(&#x27;https://example.org/?abc=123&#x27;);console.log(myURL.searchParams.get(&#x27;abc&#x27;));// 打印 123myURL.searchParams.append(&#x27;abc&#x27;, &#x27;xyz&#x27;);console.log(myURL.href);// 打印 https://example.org/?abc=123&amp;abc=xyzmyURL.searchParams.delete(&#x27;abc&#x27;);myURL.searchParams.set(&#x27;a&#x27;, &#x27;b&#x27;);console.log(myURL.href);// 打印 https://example.org/?a=b Nodejs工具supervisor 工具supervisor 会不停的watch 你应用下面的所有文件，发现有文件被修改，就重新载入程序文件这样就实现了部署，修改了程序文件后马上就能看到变更后的结果。麻麻再也不用担心我的重启nodejs 了 首先安装 supervisor(在cmd控制台输入下方代码) 12npm install -g supervisor1 使用 supervisor 代替 node 命令启动应用 1supervisor app.js nodemon nodemon 和 supervisor 的功能一样，两者安装一个即可 使用npm install -g nodemon 下载它（-g 是全局安装） 在命令行工具中用nodemon命令替代node命令执行文件 1nodemon app.js 内置模块fsfs：file system ，文件操作系统，是系统模块，直接引入即可使用. 文件系统的API非常的多，我们不可能，也没必要一个个去学习，更多的是使用是时候去查对应的API fs.stat🔥fs.stat ：检测是文件还是目录： 第一个参数是 path ：路径 第二个参数是 callback：回调函数 12345678910111213const fs = require(&#x27;fs&#x27;);// 1. fs.stat 检测是文件还是目录fs.stat(&#x27;./html&#x27;,(err,data)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(`是文件:$&#123;data.isFile()&#125;`); console.log(`是目录:$&#123;data.isDirectory()&#125;`);&#125;) fs.mkdir🔥fs.mkdir()： 创建目录 第一个参数 path：将要创建的目录路径 第二个参数 mode：目录权限(读写权限)，默认为777 第三个参数 callback：回调函数，传递异常参数 err 12345678fs.mkdir(&#x27;./css&#x27;,(err)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(&#x27;创建成功&#x27;);&#125;) fs.writeFile🔥fs.writeFile ：创建写入文件 第一个参数 filename：文件名称 第二个参数 data：将要写入的内容，可以使用字符串或 buffer 数据 第三个参数 options：option 数组对象，包含 encoding ：可选值，默认为 ‘utf8’，当 data 使用 buffer 时，该值应该为 ignored mode：文件读写权限，默认为 438 flag ：默认为 ‘w’ 第四个参数 callback：回调函数，传递一个异常参数 err 123456789101112131415fs.writeFile(&#x27;./html/index.html&#x27;,&#x27;你好nodejs&#x27;,(err)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(&#x27;创建写入文件成功&#x27;);&#125;)fs.writeFile(&#x27;./html/index.html&#x27;,&#x27;你好nodejs 哈哈&#x27;,(err)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(&#x27;创建写入文件成功&#x27;);&#125;) 注意：如果没有这个文件，则会新建一个文件，如果已经有这个文件，那么会覆盖这个文件里面的内容 fs.appendFilefs.appendFile 追加文件 第一个参数 path：将要追加的文件路径 第二个参数 data：要追加的文件内容 第三个参数callback：回调函数，传递一个异常参数 err 12345678910111213141516171819fs.appendFile(&#x27;./css/base.css&#x27;,&#x27;body&#123;color:red&#125;&#x27;,(err)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(&#x27;appendFile 成功&#x27;);&#125;) fs.appendFile(&#x27;./css/base.css&#x27;,&#x27;h3&#123;color:red&#125;\\n&#x27;,(err)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(&#x27;appendFile 成功&#x27;);&#125;) 注意：如果这个文件不存在，则会新建文件，如果文件已经存在，则会在文件内容后面追加内容 fs.readFilefs.readFile 读取文件： 第一个参数路径 path：想要读取的文件的路径 第二个参数callback：回调函数，传递一个异常参数 err 和读取的文件数据 data，data类型是 Buffer 123456789101112131415161718fs.readFile(&#x27;./html/index.html&#x27;,(err,data)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(data); console.log(data.toString()); //把Buffer 转化成string类型&#125;)fs.readFile(&#x27;./aaa/index.html&#x27;,(err,data)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(data); console.log(data.toString()); //把Buffer 转化成string类型&#125;) fs.readdirfs.readdir 读取目录： 123456789fs.readdir(&#x27;./html&#x27;,(err,data)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(data);&#125;) fs.renamefs.rename ：重命名，功能：1、表示重命名 2、移动文件 123456789101112131415161718192021fs.rename(&#x27;./css/aaa.css&#x27;,&#x27;./css/index.css&#x27;,(err)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(&#x27;重命名成功&#x27;);&#125;)fs.rename(&#x27;./css/index.css&#x27;,&#x27;./html/index.css&#x27;,(err)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(&#x27;移动文件成功&#x27;);&#125;) fs.rmdirfs.rmdir 删除目录 1234567fs.rmdir(&#x27;./aaaa&#x27;,(err)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(&#x27;删除目录成功&#x27;);&#125;) 注意：要删除目录之前需要先删除目录下的所有文件 fs.unlinkfs.unlink 删除文件 1234567fs.unlink(&#x27;./aaaa/index.html&#x27;,(err)=&gt;&#123; if(err)&#123; console.log(err); return; &#125; console.log(&#x27;删除文件成功&#x27;);&#125;) fs.createReadStreamfs.createReadStream： 从文件流中读取数据 123456789101112131415161718192021222324const fs = require(&#x27;fs&#x27;);// 以流的方式读取 data 目录下的 aaa.txtvar ReadStream = fs.createReadStream(&quot;./data/aaa.txt&quot;);let count = 0;var str = &#x27;&#x27;;// 通过 on 方法监听 data,表示我们读取到了这个数据ReadStream.on(&#x27;data&#x27;, (data) =&gt; &#123; str += data; count++;&#125;)// 通过 on 方法监听 end,表示我们读取完了这个数据ReadStream.on(&#x27;end&#x27;, () =&gt; &#123; console.log(str); console.log(count);&#125;)// 通过 on 方法监听 error,表示读取过程中的错误信息ReadStream.on(&#x27;error&#x27;, (err) =&gt; &#123; console.log(err);&#125;) fs.createWriteStreamfs.createWriteStream：写入文件 12345678910111213141516171819const fs = require(&#x27;fs&#x27;);for(var i=0;i&lt;500;i++)&#123; str +=&#x27;我是从数据库获取的数据,我要保存起来&#x27;&#125;// 以流的方式写到 data目录下的 output.txtvar writeStream = fs.createWriteStream(&#x27;/data/output.txt&#x27;);writeStream.write(str); //标记写入完成writeStream.end();writeStream.on(&#x27;finish&#x27;,()=&gt;&#123; console.log(&#x27;写入完成&#x27;);&#125;) 管道流🔥管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。 123456789const fs = require(&#x27;fs&#x27;);// 创建一个可读流var readerStream = fs.createReadStream(&#x27;input.txt&#x27;);// 创建一个可写流var readStream = fs.createReadStream(&#x27;output.txt&#x27;)// 管道读写操作// 读取 input.txt 文件内容,并将内容写入到 output.txt 文件中readStream.pipi(writeStream);console.log(&#x27;程序执行完毕。&#x27;); 同步与异步同步API、异步API 同步API可以从返回值中拿到API执行的结果, 但是异步API是不可以的 1234567891011121314// 同步function sum (n1, n2) &#123; return n1 + n2;&#125; const result = sum (10, 20); // 30// 异步function getMsg () &#123; setTimeout(function () &#123; return &#123; msg: &#x27;Hello Node.js&#x27; &#125; &#125;, 2000); // return undefined;&#125;const msg = getMsg (); // undefined 同步API从上到下依次执行，前面代码会阻塞后面代码的执行 1234for (var i = 0; i &lt; 100000; i++) &#123; console.log(i);&#125;console.log(&#x27;for循环后面的代码&#x27;); 异步API不会等待API执行完成后再向下执行代码 12345678console.log(&#x27;代码开始执行&#x27;); setTimeout(() =&gt; &#123; console.log(&#x27;2秒后执行的代码&#x27;)&#125;, 2000);setTimeout(() =&gt; &#123; console.log(&#x27;&quot;0秒&quot;后执行的代码&#x27;)&#125;, 0); console.log(&#x27;代码结束执行&#x27;);//代码开始执行//代码结束执行//&quot;0秒&quot;后执行的代码//2秒后执行的代码 同步API 放在同步代码执行区，异步API放在异步代码执行区，同时将异步API 所对应的回调函数放在回调函数队列，这个时候注意，同步代码执行区和回调函数队列两者里面的代码没有执行，当同步代码区里面的内容执行完毕，这个时候去异步代码区，发现第二个 setTimeout 执行完毕，则将其对应的回调函数放入同步代码区执行，再去异步代码区发现第一个 setTimeout 执行完毕，再将其对应的回调函数放入同步代码区执行。 回调函数自己定义函数让别人去调用。 回调函数视频讲解：https://www.bilibili.com/video/BV1UE411H71P?p=36 1234// getData函数定义function getData (callback) &#123;&#125;// getData函数调用getData ( () =&gt; &#123;&#125;); getData 函数有一个形参 callback，传递的实参是一个函数，将一个函数作为另外一个函数的形参，则此形参就叫做回调函数。 12345678910function getData(callback) &#123; callback(&#x27;123&#x27;); // 使用callback可以调用下面的匿名函数function,并给callback传递参数 //callback函数被调用了&#125;// 调用函数getData(function(n) &#123; console.log(&#x27;callback函数被调用了&#x27;); console.log(n); // 123&#125;) 我们可以调用 callback 回调函数将异步API执行的结果传递出来 12345678910function getMsg (callback) &#123; // 调用callback将异步API执行的结果传递出来 setTimeout(function () &#123; callback (&#123; msg: &#x27;Hello Node.js&#x27; &#125;) &#125;, 2000);&#125;getMsg (function (msg) &#123; console.log(msg); // &#123; msg: &#x27;Hello Node.js&#x27; &#125;&#125;); Nodejs里面的异步API1fs.readFile(&#x27;./demo.txt&#x27;,(err,result) =&gt; &#123;&#125;); 读取文件是需要时间的，文件读取的结果不能通过返回值的方式获取，需要通过回调函数。 12var server = http.createServer();server.on(&#x27;request&#x27;,(req,res) =&gt; &#123;&#125;); 事件监测也是异步API 如果异步API后面代码的执行依赖当前异步API的执行结果，但实际上后续代码在执行的时候异步API还没有返回结果，这个问题要怎么解决呢？ 例如，我们需要依次读取A文件、B文件、C文件 1234567891011const fs = require(&#x27;fs&#x27;);fs.readFile(&#x27;./1.txt&#x27;,&#x27;utf8&#x27;,(err,result1) =&gt; &#123; console.log(result1); fs.readFile(&#x27;./2.txt&#x27;,&#x27;utf8&#x27;,(err,result2)=&gt; &#123; console.log(result2); fs.readFile(&#x27;./3.txt&#x27;,&#x27;utf8&#x27;,(err,result3)=&#123; console.log(result3); &#125;) &#125;)&#125;) 回调嵌套的情况就叫做 回调地狱 PromisePromise 出现的目的是解决 Node.js 异步编程中回调地狱的问题。 实际上，Promise 本身是一个构造函数，我们要解决回调地狱的问题，需要先使用 new 运算符创建 Promise 实例，在创建 Promise 实例的过程中，需要传入一个匿名函数，在匿名函数中有两个参数。 1234567891011let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (true) &#123; resolve(&#123;name: &#x27;张三&#x27;&#125;) &#125;else &#123; reject(&#x27;失败了&#x27;) &#125; &#125;, 2000);&#125;);promise.then(result =&gt; console.log(result) // &#123;name: &#x27;张三&#x27;&#125;) .catch(error =&gt; console.log(error); // 失败了) 例如，我们需要依次读取A文件、B文件、C文件 123456789101112131415161718192021222324252627282930313233343536function p1() &#123; return new Promise((resolve,reject) =&gt; &#123; fs.readFile(&#x27;./1.txt&#x27;,&#x27;utf8&#x27;,(err,result) =&gt; &#123; resolve(result); &#125;)&#125;);&#125;function p2() &#123; return new Promise((resolve,reject) =&gt; &#123; fs.readFile(&#x27;./2.txt&#x27;,&#x27;utf8&#x27;,(err,result) =&gt; &#123; resolve(result); &#125;)&#125;);&#125;function p3() &#123; lreturn new Promise((resolve,reject) =&gt; &#123; fs.readFile(&#x27;./3.txt&#x27;,&#x27;utf8&#x27;,(err,result) =&gt; &#123; resolve(result); &#125;)&#125;);&#125;p1().then((r1) =&gt; &#123; console.log(r1); return p2(); //返回一个promise对象&#125;).then((r2) =&gt; &#123; console.log(r2); return p3();&#125;).then((r3) =&gt; &#123; console.log(r3); return p3;&#125;) ES7异步函数异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。 123const fn = async () =&gt; &#123;&#125;;async function fn () &#123;&#125; async关键字 普通函数定义前加async关键字 普通函数变成异步函数 异步函数默认返回promise对象 在异步函数内部使用return关键字进行结果返回 结果会被包裹在promise对象中 return关键字代替了resolve方法 在异步函数内部使用throw关键字抛出程序异常 调用异步函数再链式调用then方法获取异步函数执行结果 调用异步函数再链式调用catch方法获取异步函数执行的错误信息 123456789101112// 1. 普通函数定义前加async关键字，普通函数变成异步函数// 2. 异步函数默认的返回值是promise 对象async function fn() &#123; throw &#x27;发生了一些错误&#x27;; return 123;&#125;fn ().then(function(data) &#123; console.log(data); //123&#125;).catch(function (err) &#123; console.log(err); //发生了一些错误&#125;) await关键字 await关键字只能出现在异步函数中 await promise await后面只能写promise对象 写其他类型的API是不可以的 await关键字是暂停异步函数向下执行 直到promise返回结果 123456789101112131415async function p1() &#123; return &#x27;p1&#x27;; // 返回的是 promise 对象&#125;async function p2() &#123; return &#x27;p2&#x27;;&#125;async function p3() &#123; return &#x27;p3&#x27;;&#125;async function run() &#123; await p1(); await p2(); await p3();&#125;run(); 简单理解： async 是让方法变成异步 await 是等待异步方法执行完成 Node.js全局对象global在浏览器中全局对象是 window，在 Node 中全局对象是 global。 Node 中全局对象有以下方法，可以在任何地方使用，global 可以省略 console.log() 在控制台输出、 setTimeout() 设置超时定时器 clearTimeout() 清除超时定时器 setInterval() 设置间歇定时器 clearInterval() 清除间歇定时器 注意：Node中不存在 BOM、DOM，所以全局对象是 global。但是在 DOM、BOM 中也有这些方法，只是全局对象是 window。 获取异步方法里面的数据回调函数获取123456789101112// 回调函数 获取异步方法里面的数据function getData(callbck)&#123; setTimeout(function()&#123; var name=&#x27;张三&#x27;; callbck(name); &#125;,1000);&#125;//外部获取异步方法里面的数据getData(function(data)&#123; console.log(data+&#x27;111&#x27;);&#125;) Promise获取123456789101112131415//Promise来处理异步 resolve 成功的回调函数 reject失败的回调函数var p=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; var name=&#x27;张三&#x27;; if(Math.random()&lt;0.7)&#123; resolve(name); &#125;else&#123; reject(&#x27;失败&#x27;); &#125; &#125;,1000);&#125;)p.then((data)=&gt;&#123; console.log(data);&#125;) Async、Await使用1234567891011121314//普通方法function test()&#123; return &#x27;您好nodejs&#x27;;&#125;console.log(test()); // 您好nodejs//异步方法async function test()&#123; return &#x27;您好nodejs&#x27;;&#125;console.log(test()); // Promise &#123; &#x27;您好nodejs&#x27; &#125; async 是让方法变成异步，它返回的是 Promise，那我们要获取 Promise 对象里面的字符串要如何做呢？ 1234567891011121314151617181920//错误用法async function test()&#123; // Promise &#123; &#x27;您好nodejs&#x27; &#125; return &#x27;您好nodejs&#x27;;&#125;console.log(await test()); //错误 : await必须得用在async的方法里面// 异步方法async function test()&#123; return &#x27;您好nodejs&#x27;;&#125;// 正确获取异步方法里面的数据async function main()&#123; var data=await test(); //获取异步方法里面的数据 console.log(data);&#125;main(); 我们当然最好是要返回的是 Promise 对象，否则也没必要将方法变为异步了。 12345678910111213141516// async 封装一个异步函数async function test()&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(function()&#123; var name=&#x27;张三 222&#x27;; resolve(name); &#125;,1000); &#125;)&#125;async function main()&#123; var data=await test(); //获取异步方法里面的数据 console.log(data);&#125;main(); 内置模块Pathpath常见的API 从路径中获取信息 dirname：获取文件的父文件夹 basename：获取文件名 extname：获取文件扩展名 123456789const path = require(&#x27;path&#x27;);// 1.获取路径的信息const filepath = &#x27;/User/why/abc.txt&#x27;;console.log(path.dirname(filepath)); // /User/whyconsole.log(path.basename(filepath)); // abc.txtconsole.log(path.extname(filepath)); // .txt 路径的拼接 如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符 这个时候我们可以使用 path.join 函数 1234567// 2.join路径拼接const basepath = &#x27;../User/why&#x27;;const filename = &#x27;./abc.txt&#x27;;const othername = &#x27;./why.js&#x27;;const filepath1 = path.join(basepath, filename);console.log(filepath1); // ..\\User\\why\\abc.txt 将文件和某个文件夹拼接 如果我们希望将某个文件和文件夹拼接，可以使用path.resolve resolve 函数会判断我们拼接的路径前面是否有 / 或 …/ 或 ./ 如果有表示是一个绝对路径，会返回对应的拼接路径 如果没有，那么会和当前执行文件所在的文件夹进行路径的拼接 1234567891011121314151617181920212223const path = require(&#x27;path&#x27;);const basepath = &#x27;../User/why&#x27;;const filename = &#x27;./abc.txt&#x27;;const othername = &#x27;./why.js&#x27;;// 3.resolve路径拼接// resolve会判断拼接的路径字符串中,是否有以/或./或../开头的路径const filepath2 = path.resolve(basepath, filename, othername);console.log(filepath2);// E:\\Code\\Node\\NodeCodeWhy\\User\\why\\abc.txt\\why.jsconst path = require(&#x27;path&#x27;);const basepath2 = &#x27;/User/coderwhy&#x27;;// const filename2 = &#x27;/why/abc.txt&#x27;; // E:\\why\\abc.txt// const filename2 = &#x27;./why/abc.txt&#x27;; // E:\\User\\coderwhy\\why\\abc.txt// const filename2 = &#x27;why/abc.txt&#x27;; // E:\\User\\coderwhy\\why\\abc.txt// const filename2 = &#x27;../why/abc.txt&#x27;; // E:\\User\\why\\abc.txtconst result = path.resolve(basepath2, filename2);console.log(result); path.extname path.extname() 获取文件(可以是一个路径文件)的扩展名 123456const path = require(&#x27;path&#x27;);console.log(path.extname(&#x27;hello.md&#x27;)); // md// 获取路径信息的扩展名let strPath = &quot;http://www.xinhuanet.html&quot;;console.log(path.extname(strPath)); // html path.resolve123456const path = require(&#x27;path&#x27;);let arr = [&#x27;/sxt&#x27;, &#x27;qianduan&#x27;, &#x27;zhongji&#x27;];let info1 = path.resolve(...arr);console.log(info1);// D:\\sxt\\qianduan\\zhongji 给定的路径的序列是”从右往左”被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径。 path.join🔥 path.join([...paths]) 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。 12345678path.join(__dirname,&#x27;./02art-template.js&#x27;)path.join(&#x27;/foo&#x27;,&#x27;bar&#x27;,&#x27;./baz&#x27;);// &#x27;foo/bar/baz&#x27;path.join(&#x27;/foo&#x27;,&#x27;bar&#x27;,&#x27;/baz&#x27;,&#x27;..&#x27;);// &#x27;foo/bar&#x27; __dirname 获得当前执行文件所在目录的完整目录名 __filename 获得当前执行文件的带有完整绝对路径的文件名 服务器端与客户端网站应用程序主要分为两大部分：客户端和服务器端 客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JS构建 服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑。（可以将服务器端理解为另一台电脑） 路由路由指的就是针对不同请求的URL，处理不同的业务逻辑。 12345678910111213141516171819const http = require(&#x27;http&#x27;);const url = require(&#x27;url&#x27;);http.createServer(function(request, response) &#123; response.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); // 解构写法,相当于 request.url const &#123; url &#125; = request; if (url == &#x27;/&#x27; || url == &#x27;index&#x27;) &#123; response.end(&#x27;欢迎来到首页&#x27;); &#125; else if (url == &#x27;/list&#x27;) &#123; response.end(&#x27;欢迎来到列表页&#x27;); &#125; else &#123; response.end(&#x27;抱歉，您访问的页面出游了~&#x27;); &#125; response.end(&#x27;Hello World&#x27;);&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); Get请求在客户端和服务器之间进行请求 - 响应时，两种最常被用到的方法是：GET 和 POST GET - 从指定的资源请求数据。(一般用于获取数据) request.url 获取请求地址 request.method 获取请求方法 POST - 向指定的资源提交要被处理的数据。(一般用于提交数据) 123456789101112http.createServer(function(request, response) &#123; //发送响应头 //设置HTTP头部,状态码是200,文件类型是 html,字符集是 utf8 response.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); console.log(request.url); // 获取请求地址 /index.html console.log(request.method); // 获取请求方法 GET/POST //表示给我们页面上面输出一句话并且结束响应 response.end(&#x27;Hello World&#x27;);&#125;).listen(3000); //监听端口 GET请求参数 参数被放置在浏览器地址栏中，例如：http://localhost:3000/?name=zhangsan&amp;age=20 参数获取需要借助系统模块url，url模块用来处理url地址 request.url 获取 /name=zhangsan&amp;age=20 request.headers.host 获取 127.0.0.1:3000 ```jsconst myURL = new URL(url, http://&#123;host&#125;); 12345678910111213141516171819202122232425 - 如上获取到 url 对象，再从对象中获取参数![在这里插入图片描述](https://img-blog.csdnimg.cn/5ee5f3f531c947b7b1ef6205b973d017.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55Sf5ZG95piv5pyJ5YWJ55qE,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)```jsconst http = require(&#x27;http&#x27;);const url = require(&#x27;url&#x27;);http.createServer(function(request, response) &#123; response.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html;charset=UTF-8&#x27; &#125;); // 解构写法,相当于 request.url const &#123; url &#125; = request; // 解构写法,相当于 request.headers.host const &#123; host &#125; = request.headers; if (url !== &#x27;/favicion.ico&#x27;) &#123; const myURL = new URL(url, `http://&#123;host&#125;`); response.write(`name: $&#123;myURL.searchParams.get(&quot;name&quot;)&#125;,age: $&#123;myURL.searchParams.get(&quot;age&quot;)&#125;`); &#125; response.end(&#x27;Hello World&#x27;);&#125;).listen(3000);console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;); Post请求 参数被放置在请求体中进行传输 获取 POST 参数需要使用 data 事件和 end 事件 使用 querystring 系统模块将参数转化为对象格式 123456789101112131415161718192021const http = require(&#x27;http&#x27;);// 处理请求参数模块const queryString = require(&#x27;querystring&#x27;);http.createServer(function (request, response) &#123; response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); // data 当请求参数传递的时候触发data事件 // end 当请求参数传递完成的时候触发end事件 let postParams = &#x27;&#x27;; request.on(&#x27;data&#x27;,(params)=&gt;&#123; postParams += params; &#125;) request.on(&#x27;end&#x27;,()=&gt;&#123; console.log(postParams); // 接收到的是一个字符串 console.log(queryString.parse(postParams)); // 使用queryString将字符串转化为对象 &#125;) response.end(&#x27;Hello World&#x27;);&#125;).listen(3000);","categories":[{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"模块化开发","slug":"模块化开发","permalink":"http://example.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"Express框架","slug":"Express框架","permalink":"http://example.com/tags/Express%E6%A1%86%E6%9E%B6/"}]},{"title":"Nodejs基础","slug":"nodeJS学习笔记","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T10:08:55.445Z","comments":true,"path":"2022/04/24/nodeJS学习笔记/","link":"","permalink":"http://example.com/2022/04/24/nodeJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Node介绍为什么要学习Node.js 企业需求 具有服务端开发经验更改 front-end back-end 全栈开发工程师 基本的网站开发能力 服务端 前端 运维部署 多人社区 Node.js是什么 Node.js是JavaScript 运行时 通俗易懂的讲，Node.js是JavaScript的运行平台 Node.js既不是语言，也不是框架，它是一个平台 浏览器中的JavaScript EcmaScript 基本语法 if var function Object Array Bom Dom Node.js中的JavaScript 没有Bom，Dom EcmaScript 在Node中这个JavaScript执行环境为JavaScript提供了一些服务器级别的API 例如文件的读写 网络服务的构建 网络通信 http服务器 构建与Chrome的V8引擎之上 代码只是具有特定格式的字符串 引擎可以认识它，帮你解析和执行 Google Chrome的V8引擎是目前公认的解析执行JavaScript代码最快的 Node.js的作者把Google Chrome中的V8引擎移植出来，开发了一个独立的JavaScript运行时环境 Node.js uses an envent-driven,non-blocking I/O mode that makes it lightweight and efficent. envent-driven 事件驱动 non-blocking I/O mode 非阻塞I/O模型（异步） ightweight and efficent. 轻量和高效 Node.js package ecosystem,npm,is the larget scosystem of open sourcr libraries in the world npm 是世界上最大的开源生态系统 绝大多数JavaScript相关的包都存放在npm上，这样做的目的是为了让开发人员更方便的去下载使用 npm install jquery Node能做什么 web服务器后台 命令行工具 npm(node) git(c语言) hexo（node） 对于前端工程师来讲，接触最多的是它的命令行工具 自己写的很少，主要是用别人第三方的 webpack gulp npm 起步安装Node环境 查看Node环境的版本号 下载：https://nodejs.org/en/ 安装： 傻瓜式安装，一路next 安装过再次安装会升级 确认Node环境是否安装成功 查看node的版本号：node --version 或者node -v 配置环境变量 解析执行JavaScript 创建编写JavaScript脚本文件 打开终端，定位脚本文件的所属目录 输入node 文件名执行对应的文件 注意：文件名不要用node.js来命名，也就是说除了node这个名字随便起，最好不要使用中文。 文件的读写文件读取: 12345678910111213141516171819//浏览器中的JavaScript是没有文件操作能力的//但是Node中的JavaScript具有文件操作能力//fs是file-system的简写，就是文件系统的意思//在Node中如果想要进行文件的操作就必须引用fs这个核心模块//在fs这个和兴模块中，就提供了人所有文件操作相关的API//例如 fs.readFile就是用来读取文件的// 1.使用fs核心模块var fs = require(&#x27;fs&#x27;);// 2.读取文件fs.readFile(&#x27;./data/a.txt&#x27;,function(err,data)&#123; if(err)&#123; console.log(&#x27;文件读取失败&#x27;); &#125; else&#123; console.log(data.toString()); &#125;&#125;) 文件写入： 123456789101112// 1.使用fs核心模块var fs = require(&#x27;fs&#x27;);// 2.将数据写入文件fs.writeFile(&#x27;./data/a.txt&#x27;,&#x27;我是文件写入的信息&#x27;,function(err,data)&#123; if(err)&#123; console.log(&#x27;文件写入失败&#x27;); &#125; else&#123; console.log(data.toString()); &#125;&#125;) http服务器： 12345678910111213141516171819202122// 1.加载http核心模块var http = require(&#x27;http&#x27;);// 2.使用http.createServer()创建一个web服务器var server = http.createServer();// 3.服务器要做的事儿// 提供服务：对数据服务// 发请求// 接收请求// 处理请求// 反馈（发送响应）// 当客户端请求过来，就会自动触发服务器的request请求事件，然后执行第二个参数：回调处理函数server.on(&#x27;request&#x27;,function()&#123; console.log(&#x27;收到客户的请求了&#x27;)&#125;)// 4.绑定端口号，启动服务server.listen(3000,function()&#123; console.log(&#x27;runing...&#x27;)&#125;) Node中的模块系统使用Node编写应用程序主要就是在使用： EcmaScript语言 和浏览器一样，在Node中没有Bom和Dom 核心模块 文件操作的fs http服务操作的http url路径操作模块 path路径处理模块 os操作系统信息 第三方模块 art-template 必须通过npm来下载才可以使用 自己写的模块 自己创建的文件 什么是模块化 文件作用域(模块是独立的，在不同的文件使用必须要重新引用)【在node中没有全局作用域，它是文件模块作用域】 通信规则 加载require 导出exports CommonJS模块规范在Node中的JavaScript还有一个重要的概念，模块系统。 模块作用域 使用require方法来加载模块 使用exports接口对象来导出模板中的成员 加载require语法： 1var 自定义变量名 = require(&#x27;模块&#x27;) 作用： 执行被加载模块中的代码 得到被加载模块中的exports导出接口对象 导出exports Node中是模块作用域，默认文件中所有的成员只在当前模块有效 对于希望可以被其他模块访问到的成员，我们需要把这些公开的成员都挂载到exports接口对象中就可以了 导出多个成员（必须在对象中）： 12345678exports.a = 123;exports.b = function()&#123; console.log(&#x27;bbb&#x27;)&#125;;exports.c = &#123; foo:&quot;bar&quot;&#125;;exports.d = &#x27;hello&#x27;; 导出单个成员（拿到的就是函数，字符串）： 1module.exports = &#x27;hello&#x27;; 以下情况会覆盖： 12345module.exports = &#x27;hello&#x27;;//后者会覆盖前者module.exports = function add(x,y) &#123; return x+y;&#125; 也可以通过以下方法来导出多个成员： 123456module.exports = &#123; foo = &#x27;hello&#x27;, add:function()&#123; return x+y; &#125;&#125;; 模块原理exports和module.exports的一个引用： 123456console.log(exports === module.exports); //trueexports.foo = &#x27;bar&#x27;;//等价于module.exports.foo = &#x27;bar&#x27;; 当给exports重新赋值后，exports！= module.exports. 最终return的是module.exports,无论exports中的成员是什么都没用。 123真正去使用的时候： 导出单个成员：exports.xxx = xxx; 导出多个成员：module.exports 或者 modeule.exports = &#123;&#125;; 总结12345678910111213141516171819202122232425262728293031323334// 引用服务var http = require(&#x27;http&#x27;);var fs = require(&#x27;fs&#x27;);// 引用模板var template = require(&#x27;art-template&#x27;);// 创建服务var server = http.createServer();// 公共路径var wwwDir = &#x27;D:/app/www&#x27;;server.on(&#x27;request&#x27;, function (req, res) &#123; var url = req.url; // 读取文件 fs.readFile(&#x27;./template-apche.html&#x27;, function (err, data) &#123; if (err) &#123; return res.end(&#x27;404 Not Found&#x27;); &#125; fs.readdir(wwwDir, function (err, files) &#123; if (err) &#123; return res.end(&#x27;Can not find www Dir.&#x27;) &#125; // 使用模板引擎解析替换data中的模板字符串 // 去xmpTempleteList.html中编写模板语法 var htmlStr = template.render(data.toString(), &#123; title: &#x27;D:/app/www/ 的索引&#x27;, files:files &#125;); // 发送响应数据 res.end(htmlStr); &#125;) &#125;)&#125;);server.listen(3000, function () &#123; console.log(&#x27;running....&#x27;);&#125;) 1234567891011121314151617181.jQuery中的each 和 原生JavaScript方法forEach的区别： 提供源头： 原生js是es5提供的（不兼容IE8）, jQuery的each是jQuery第三方库提供的（如果要使用需要用2以下的版本也就是1.版本）,它的each方法主要用来遍历jQuery实例对象（伪数组）,同时也可以做低版本forEach的替代品,jQuery的实例对象不能使用forEach方法，如果想要使用必须转为数组（[].slice.call(jQuery实例对象)）才能使用2.模块中导出多个成员和导出单个成员3.301和302的区别： 301永久重定向,浏览器会记住 302临时重定向4.exports和module.exports的区别: 每个模块中都有一个module对象 module对象中有一个exports对象 我们可以把需要导出的成员都挂载到module.exports接口对象中 也就是`module.exports.xxx = xxx`的方式 但是每次写太多了就很麻烦，所以Node为了简化代码，就在每一个模块中都提供了一个成员叫`exports` `exports === module.exports`结果为true,所以完全可以`exports.xxx = xxx` 当一个模块需要导出单个成员的时候必须使用`module.exports = xxx`的方式，=,使用`exports = xxx`不管用,因为每个模块最终return的是module.exports,而exports只是module.exports的一个引用,所以`exports`即使重新赋值,也不会影响`module.exports`。 有一种赋值方式比较特殊：`exports = module.exports`这个用来新建立引用关系的。 require的加载规则 核心模块 模块名 第三方模块 模块名 用户自己写的 路径 require的加载规则： 优先从缓存加载 判断模块标识符 核心模块 自己写的模块（路径形式的模块） 第三方模块（node_modules） 第三方模块的标识就是第三方模块的名称（不可能有第三方模块和核心模块的名字一致） npm 开发人员可以把写好的框架库发布到npm上 使用者通过npm命令来下载 使用方式：var 名称 = require(&#39;npm install【下载包】 的包名&#39;) node_modules/express/package.json main 如果package.json或者main不成立，则查找被选择项：index.js 如果以上条件都不满足，则继续进入上一级目录中的node_modules按照上面的规则依次查找，直到当前文件所属此盘根目录都找不到最后报错 12345678910111213141516171819202122232425262728293031323334// 如果非路径形式的标识// 路径形式的标识： // ./ 当前目录 不可省略 // ../ 上一级目录 不可省略 // /xxx也就是D:/xxx // 带有绝对路径几乎不用（D:/a/foo.js）// 首位表示的是当前文件模块所属磁盘根目录// require(&#x27;./a&#x27;); // 核心模块// 核心模块本质也是文件，核心模块文件已经被编译到了二进制文件中了，我们只需要按照名字来加载就可以了require(&#x27;fs&#x27;); // 第三方模块// 凡是第三方模块都必须通过npm下载（npm i node_modules），使用的时候就可以通过require(&#x27;包名&#x27;)来加载才可以使用// 第三方包的名字不可能和核心模块的名字是一样的// 既不是核心模块，也不是路径形式的模块// 先找到当前文所述目录的node_modules// 然后找node_modules/art-template目录// node_modules/art-template/package.json// node_modules/art-template/package.json中的main属性// main属性记录了art-template的入口模块// 然后加载使用这个第三方包// 实际上最终加载的还是文件// 如果package.json不存在或者mian指定的入口模块不存在// 则node会自动找该目录下的index.js// 也就是说index.js是一个备选项，如果main没有指定，则加载index.js文件// // 如果条件都不满足则会进入上一级目录进行查找// 注意：一个项目只有一个node_modules，放在项目根目录中，子目录可以直接调用根目录的文件var template = require(&#x27;art-template&#x27;); 模块标识符中的/和文件操作路径中的/文件操作路径： 1234567891011121314// 咱们所使用的所有文件操作的API都是异步的// 就像ajax请求一样// 读取文件// 文件操作中 ./ 相当于当前模块所处磁盘根目录// ./index.txt 相对于当前目录// /index.txt 相对于当前目录// /index.txt 绝对路径,当前文件模块所处根目录// d:express/index.txt 绝对路径fs.readFile(&#x27;./index.txt&#x27;,function(err,data)&#123; if(err)&#123; return console.log(&#x27;读取失败&#x27;); &#125; console.log(data.toString());&#125;) 模块操作路径： 123// 在模块加载中，相对路径中的./不能省略// 这里省略了.也是磁盘根目录require(&#x27;./index&#x27;)(&#x27;hello&#x27;) npm node package manage(node包管理器) 通过npm命令安装jQuery包（npm install –save jquery），在安装时加上–save会主动生成说明书文件信息（将安装文件的信息添加到package.json里面） npm网站 ​ npmjs.com 网站 是用来搜索npm包的 npm命令行工具npm是一个命令行工具，只要安装了node就已经安装了npm。 npm也有版本概念，可以通过npm --version来查看npm的版本 升级npm(自己升级自己)： 1npm install --global npm 常用命令 npm init(生成package.json说明书文件) npm init -y(可以跳过向导，快速生成) npm install 一次性把dependencies选项中的依赖项全部安装 简写（npm i） npm install 包名 只下载 简写（npm i 包名） npm install –save 包名 下载并且保存依赖项（package.json文件中的dependencies选项） 简写（npm i 包名） npm uninstall 包名 只删除，如果有依赖项会依然保存 简写（npm un 包名） npm uninstall –save 包名 删除的同时也会把依赖信息全部删除 简写（npm un 包名） npm help 查看使用帮助 npm 命令 –help 查看具体命令的使用帮助（npm uninstall –help） 解决npm被墙问题npm存储包文件的服务器在国外，有时候会被墙，速度很慢，所以需要解决这个问题。 https://developer.aliyun.com/mirror/NPM?from=tnpm淘宝的开发团队把npm在国内做了一个镜像（也就是一个备份）。 安装淘宝的cnpm： 1npm install -g cnpm --registry=https://registry.npm.taobao.org; 1234#在任意目录执行都可以#--global表示安装到全局，而非当前目录#--global不能省略，否则不管用npm install --global cnpm 安装包的时候把以前的npm替换成cnpm。 12345#走国外的npm服务器下载jQuery包，速度比较慢npm install jQuery;#使用cnpm就会通过淘宝的服务器来下载jQuerycnpm install jQuery; 如果不想安装cnpm又想使用淘宝的服务器来下载： 1npm install jquery --registry=https://npm.taobao.org; 但是每次手动加参数就很麻烦，所以我们可以把这个选项加入到配置文件中： 1234npm config set registry https://npm.taobao.org;#查看npm配置信息npm config list; 只要经过上面的配置命令，则以后所有的npm install都会通过淘宝的服务器来下载 package.json每一个项目都要有一个package.json文件（包描述文件，就像产品的说明书一样） 这个文件可以通过npm init自动初始化出来 123456789101112131415161718192021222324252627282930313233343536373839D:\\code\\node中的模块系统&gt;npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (node中的模块系统)Sorry, name can only contain URL-friendly characters.package name: (node中的模块系统) clsversion: (1.0.0)description: 这是一个测试项目entry point: (main.js)test command:git repository:keywords:author: xiaochenlicense: (ISC)About to write to D:\\code\\node中的模块系统\\package.json:&#123; &quot;name&quot;: &quot;cls&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;这是一个测试项目&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;xiaochen&quot;, &quot;license&quot;: &quot;ISC&quot;&#125;Is this OK? (yes) yes 对于目前来讲，最有用的是dependencies选项，可以用来帮助我们保存第三方包的依赖信息。 如果node_modules删除了也不用担心，只需要在控制面板中npm install就会自动把package.json中的dependencies中所有的依赖项全部都下载回来。 建议每个项目的根目录下都有一个package.json文件 建议执行npm install 包名的时候都加上--save选项，目的是用来保存依赖信息 package.json和package-lock.jsonnpm 5以前是不会有package-lock.json这个文件 npm5以后才加入这个文件 当你安装包的时候，npm都会生成或者更新package-lock.json这个文件 npm5以后的版本安装都不要加--save参数，它会自动保存依赖信息 当你安装包的时候，会自动创建或者更新package-lock.json文件 package-lock.json这个文件会包含node_modules中所有包的信息（版本，下载地址。。。） 这样的话重新npm install的时候速度就可以提升 从文件来看，有一个lock称之为锁 这个lock使用来锁版本的 如果项目依赖了1.1.1版本 如果你重新install其实会下载最细版本，而不是1.1.1 package-lock.json的另外一个作用就是锁定版本号，防止自动升级 path路径操作模块 参考文档：https://nodejs.org/docs/latest-v13.x/api/path.html path.basename：获取路径的文件名，默认包含扩展名 path.dirname：获取路径中的目录部分 path.extname：获取一个路径中的扩展名部分 path.parse：把路径转换为对象 root：根路径 dir：目录 base：包含后缀名的文件名 ext：后缀名 name：不包含后缀名的文件名 path.join：拼接路径 path.isAbsolute：判断一个路径是否为绝对路径 Node中的其它成员(__dirname,__filename)在每个模块中，除了require,exports等模块相关的API之外，还有两个特殊的成员： __dirname，是一个成员，可以用来动态获取当前文件模块所属目录的绝对路径 __filename，可以用来动态获取当前文件的绝对路径（包含文件名） __dirname和filename是不受执行node命令所属路径影响的 在文件操作中，使用相对路径是不可靠的，因为node中文件操作的路径被设计为相对于执行node命令所处的路径。 所以为了解决这个问题，只需要把相对路径变为绝对路径（绝对路径不受任何影响）就可以了。 就可以使用__dirname或者__filename来帮助我们解决这个问题 在拼接路径的过程中，为了避免手动拼接带来的一些低级错误，推荐使用path.join()来辅助拼接 1234567891011var fs = require(&#x27;fs&#x27;);var path = require(&#x27;path&#x27;);// console.log(__dirname + &#x27;a.txt&#x27;);// path.join方法会将文件操作中的相对路径都统一的转为动态的绝对路径fs.readFile(path.join(__dirname + &#x27;/a.txt&#x27;),&#x27;utf8&#x27;,function(err,data)&#123; if(err)&#123; throw err &#125; console.log(data);&#125;); 补充：模块中的路径标识和这里的路径没关系，不受影响（就是相对于文件模块） 注意： 模块中的路径标识和文件操作中的相对路径标识不一致 模块中的路径标识就是相对于当前文件模块，不受node命令所处路径影响 Express（快速的）作者：Tj 原生的http在某些方面表现不足以应对我们的开发需求，所以就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码高度统一。 在node中有很多web开发框架。主要学习express http://expressjs.com/,其中主要封装的是http。 ```javascript// 1 安装// 2 引包var express = require(‘express’);// 3 创建服务器应用程序// 也就是原来的http.createServer();var app = express(); // 公开指定目录// 只要通过这样做了，就可以通过/public/xx的方式来访问public目录中的所有资源// 在Express中开放资源就是一个API的事app.use(‘/public/‘,express.static(‘/public/‘)); //模板引擎在Express中开放模板也是一个API的事 // 当服务器收到get请求 / 的时候，执行回调处理函数app.get(‘/‘,function(req,res){ res.send(&#39;hello express&#39;); }) // 相当于server.listenapp.listen(3000,function(){ console.log(&#39;app is runing at port 3000&#39;); }) 12345678## 学习Express#### 起步安装```javascriptcnpm install express 1234567891011121314151617181920212223// 引入expressvar express = require(&#x27;express&#x27;);// 1. 创建appvar app = express();// 2. app.get(&#x27;/&#x27;,function(req,res)&#123; // 1 // res.write(&#x27;Hello&#x27;); // res.write(&#x27;World&#x27;); // res.end() // 2 // res.end(&#x27;hello world&#x27;); // 3 res.send(&#x27;hello world&#x27;);&#125;)app.listen(3000,function()&#123; console.log(&#x27;express app is runing...&#x27;);&#125;) 基本路由路由： 请求方法 请求路径 请求处理函数 get: 1234//当你以get方法请求/的时候，执行对应的处理函数app.get(&#x27;/&#x27;,function(req,res)&#123; res.send(&#x27;hello world&#x27;);&#125;) post: 1234//当你以post方法请求/的时候，执行对应的处理函数app.post(&#x27;/&#x27;,function(req,res)&#123; res.send(&#x27;hello world&#x27;);&#125;) Express静态服务API123456// app.use不仅仅是用来处理静态资源的，还可以做很多工作(body-parser的配置)app.use(express.static(&#x27;public&#x27;));app.use(express.static(&#x27;files&#x27;));app.use(&#x27;/stataic&#x27;,express.static(&#x27;public&#x27;)); 123456789101112131415161718192021222324252627// 引入expressvar express = require(&#x27;express&#x27;);// 创建appvar app = express();// 开放静态资源// 1.当以/public/开头的时候，去./public/目录中找对应资源// 访问：http://127.0.0.1:3000/public/login.htmlapp.use(&#x27;/public/&#x27;,express.static(&#x27;./public/&#x27;)); // 2.当省略第一个参数的时候，可以通过省略/public的方式来访问// 访问：http://127.0.0.1:3000/login.html// app.use(express.static(&#x27;./public/&#x27;)); // 3.访问：http://127.0.0.1:3000/a/login.html// a相当于public的别名// app.use(&#x27;/a/&#x27;,express.static(&#x27;./public/&#x27;)); // app.get(&#x27;/&#x27;,function(req,res)&#123; res.end(&#x27;hello world&#x27;);&#125;);app.listen(3000,function()&#123; console.log(&#x27;express app is runing...&#x27;);&#125;); 在Express中配置使用art-templete模板引擎 art-template官方文档 在node中，有很多第三方模板引擎都可以使用，不是只有art-template 还有ejs，jade（pug），handlebars，nunjucks 安装： 12345npm install --save art-templatenpm install --save express-art-template//两个一起安装npm i --save art-template express-art-template 配置： 1app.engine(&#x27;html&#x27;, require(&#x27;express-art-template&#x27;)); 使用： 123456app.get(&#x27;/&#x27;,function(req,res)&#123; // express默认会去views目录找index.html res.render(&#x27;index.html&#x27;,&#123; title:&#x27;hello world&#x27; &#125;);&#125;) 如果希望修改默认的views视图渲染存储目录，可以： 12// 第一个参数views千万不要写错app.set(&#x27;views&#x27;,目录路径); 在Express中获取表单请求数据获取get请求数据：Express内置了一个api，可以直接通过req.query来获取数据 123// 通过requery方法获取用户输入的数据// req.query只能拿到get请求的数据 var comment = req.query; 获取post请求数据：在Express中没有内置获取表单post请求体的api，这里我们需要使用一个第三方包body-parser来获取数据。 安装： 1npm install --save body-parser; 配置： // 配置解析表单 POST 请求体插件（注意：一定要在 app.use(router) 之前 ） 1234567891011121314var express = require(&#x27;express&#x27;)// 引包var bodyParser = require(&#x27;body-parser&#x27;)var app = express()// 配置body-parser// 只要加入这个配置，则在req请求对象上会多出来一个属性：body// 也就是说可以直接通过req.body来获取表单post请求数据// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json()) 使用： 123456app.use(function (req, res) &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;) res.write(&#x27;you posted:\\n&#x27;) // 可以通过req.body来获取表单请求数据 res.end(JSON.stringify(req.body, null, 2))&#125;) 在Express中配置使用express-session插件操作 参考文档：https://github.com/expressjs/session 安装： 1npm install express-session 配置： 1234567891011//该插件会为req请求对象添加一个成员:req.session默认是一个对象//这是最简单的配置方式//Session是基于Cookie实现的app.use(session(&#123; //配置加密字符串，他会在原有的基础上和字符串拼接起来去加密 //目的是为了增加安全性，防止客户端恶意伪造 secret: &#x27;keyboard cat&#x27;, resave: false, saveUninitialized: true,//无论是否适用Session，都默认直接分配一把钥匙 cookie: &#123; secure: true &#125;&#125;)) 使用： 123456789101112// 读//添加Session数据//session就是一个对象req.session.foo = &#x27;bar&#x27;;//写//获取session数据req.session.foo//删req.session.foo = null;delete req.session.foo 提示： 默认Session数据时内存储数据，服务器一旦重启，真正的生产环境会把Session进行持久化存储。 利用Express实现ADUS项目模块化思想模块如何划分: 模块职责要单一 javascript模块化： Node 中的 CommonJS 浏览器中的： AMD require.js CMD sea.js es6中增加了官方支持 起步 初始化 模板处理 路由设计 请求方法 请求路径 get参数 post参数 备注 GET /students 渲染首页 GET /students/new 渲染添加学生页面 POST /students/new name,age,gender,hobbies 处理添加学生请求 GET /students/edit id 渲染编辑页面 POST /students/edit id,name,age,gender,hobbies 处理编辑请求 GET /students/delete id 处理删除请求 提取路由模块router.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * router.js路由模块 * 职责： * 处理路由 * 根据不同的请求方法+请求路径设置具体的请求函数 * 模块职责要单一，我们划分模块的目的就是增强代码的可维护性，提升开发效率 */var fs = require(&#x27;fs&#x27;);// Express专门提供了一种更好的方式// 专门用来提供路由的var express = require(&#x27;express&#x27;);// 1 创建一个路由容器var router = express.Router();// 2 把路由都挂载到路由容器中router.get(&#x27;/students&#x27;, function(req, res) &#123; // res.send(&#x27;hello world&#x27;); // readFile的第二个参数是可选的，传入utf8就是告诉他把读取到的文件直接按照utf8编码，直接转成我们认识的字符 // 除了这样来转换，也可以通过data.toString（）来转换 fs.readFile(&#x27;./db.json&#x27;, &#x27;utf8&#x27;, function(err, data) &#123; if (err) &#123; return res.status(500).send(&#x27;Server error.&#x27;) &#125; // 读取到的文件数据是string类型的数据 // console.log(data); // 从文件中读取到的数据一定是字符串，所以一定要手动转换成对象 var students = JSON.parse(data).students; res.render(&#x27;index.html&#x27;, &#123; // 读取文件数据 students:students &#125;) &#125;)&#125;);router.get(&#x27;/students/new&#x27;,function(req,res)&#123; res.render(&#x27;new.html&#x27;)&#125;);router.get(&#x27;/students/edit&#x27;,function(req,res)&#123; &#125;);router.post(&#x27;/students/edit&#x27;,function(req,res)&#123; &#125;);router.get(&#x27;/students/delete&#x27;,function(req,res)&#123; &#125;);// 3 把router导出module.exports = router; app.js: 123456var router = require(&#x27;./router&#x27;);// router(app);// 把路由容器挂载到app服务中// 挂载路由app.use(router); 设计操作数据的API文件模块es6中的find和findIndex： find接受一个方法作为参数，方法内部返回一个条件 find会便利所有的元素，执行你给定的带有条件返回值的函数 符合该条件的元素会作为find方法的返回值 如果遍历结束还没有符合该条件的元素，则返回undefined 1234567891011121314151617181920212223242526272829303132333435/** * student.js * 数据操作文件模块 * 职责：操作文件中的数据，只处理数据，不关心业务 */var fs = require(&#x27;fs&#x27;); /** * 获取所有学生列表 * return [] */exports.find = function()&#123; &#125; /** * 获取添加保存学生 */exports.save = function()&#123; &#125;/** * 更新学生 */exports.update = function()&#123; &#125; /** * 删除学生 */exports.delete = function()&#123; &#125; 步骤 处理模板 配置静态开放资源 配置模板引擎 简单的路由，/studens渲染静态页出来 路由设计 提取路由模块 由于接下来的一系列业务操作都需要处理文件数据，所以我们需要封装Student.js’ 先写好student.js文件结构 查询所有学生列别哦的API findById save updateById deleteById 实现具体功能 通过路由收到请求 接受请求中的参数（get，post） req.query req.body 调用数据操作API处理数据 根据操作结果给客户端发送请求 业务功能顺序 列表 添加 编辑 删除 子模板和模板的继承（模板引擎高级语法）【include，extend，block】注意: 模板页： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;模板页&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/node_modules/bootstrap/dist/css/bootstrap.css&quot;/&gt; &#123;&#123; block &#x27;head&#x27; &#125;&#125;&#123;&#123; /block &#125;&#125;&lt;/head&gt;&lt;body&gt; &lt;!-- 通过include导入公共部分 --&gt; &#123;&#123;include &#x27;./header.html&#x27;&#125;&#125; &lt;!-- 留一个位置 让别的内容去填充 --&gt; &#123;&#123; block &#x27;content&#x27; &#125;&#125; &lt;h1&gt;默认内容&lt;/h1&gt; &#123;&#123; /block &#125;&#125; &lt;!-- 通过include导入公共部分 --&gt; &#123;&#123;include &#x27;./footer.html&#x27;&#125;&#125; &lt;!-- 公共样式 --&gt; &lt;script src=&quot;/node_modules/jquery/dist/jquery.js&quot; &gt;&lt;/script&gt; &lt;script src=&quot;/node_modules/bootstrap/dist/js/bootstrap.js&quot; &gt;&lt;/script&gt; &#123;&#123; block &#x27;script&#x27; &#125;&#125;&#123;&#123; /block &#125;&#125;&lt;/body&gt;&lt;/html&gt; 模板的继承： ​ header页面： 123&lt;div id=&quot;&quot;&gt; &lt;h1&gt;公共的头部&lt;/h1&gt;&lt;/div&gt; ​ footer页面： 123&lt;div id=&quot;&quot;&gt; &lt;h1&gt;公共的底部&lt;/h1&gt;&lt;/div&gt; 模板页的使用： 12345678910111213141516171819202122232425&lt;!-- 继承(extend:延伸，扩展)模板也layout.html --&gt;&lt;!-- 把layout.html页面的内容都拿进来作为index.html页面的内容 --&gt;&#123;&#123;extend &#x27;./layout.html&#x27;&#125;&#125;&lt;!-- 向模板页面填充新的数据 --&gt;&lt;!-- 填充后就会替换掉layout页面content中的数据 --&gt;&lt;!-- style样式方面的内容 --&gt;&#123;&#123; block &#x27;head&#x27; &#125;&#125; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: skyblue; &#125; &lt;/style&gt;&#123;&#123; /block &#125;&#125;&#123;&#123; block &#x27;content&#x27; &#125;&#125; &lt;div id=&quot;&quot;&gt; &lt;h1&gt;Index页面的内容&lt;/h1&gt; &lt;/div&gt;&#123;&#123; /block &#125;&#125;&lt;!-- js部分的内容 --&gt;&#123;&#123; block &#x27;script&#x27; &#125;&#125; &lt;script type=&quot;text/javascript&quot;&gt; &lt;/script&gt;&#123;&#123; /block &#125;&#125; MongoDB关系型和非关系型数据库关系型数据库（表就是关系，或者说表与表之间存在关系）。 所有的关系型数据库都需要通过sql语言来操作 所有的关系型数据库在操作之前都需要设计表结构 而且数据表还支持约束 唯一的 主键 默认值 非空 非关系型数据库 非关系型数据库非常的灵活 有的关系型数据库就是key-value对儿 但MongDB是长得最像关系型数据库的非关系型数据库 数据库 -》 数据库 数据表 -》 集合（数组） 表记录 -》文档对象 一个数据库中可以有多个数据库，一个数据库中可以有多个集合（数组），一个集合中可以有多个文档（表记录） 1234567&#123; qq:&#123; user:[ &#123;&#125;,&#123;&#125;,&#123;&#125;... ] &#125;&#125; 也就是说你可以任意的往里面存数据，没有结构性这么一说 安装 下载 下载地址：https://www.mongodb.com/download-center/community 安装 1npm i mongoose 配置环境变量 最后输入mongod --version测试是否安装成功 启动和关闭数据库启动： 123# mongodb 默认使用执行mongod 命令所处盼复根目录下的/data/db作为自己的数据存储目录# 所以在第一次执行该命令之前先自己手动新建一个 /data/dbmongod 如果想要修改默认的数据存储目录，可以： 1mongod --dbpath = 数据存储目录路径 停止： 12在开启服务的控制台，直接Ctrl+C;或者直接关闭开启服务的控制台。 连接数据库连接： 12# 该命令默认连接本机的 MongoDB 服务mongo 退出： 12# 在连接状态输入 exit 退出连接exit 基本命令 show dbs 查看数据库列表(数据库中的所有数据库) db 查看当前连接的数据库 use 数据库名称 切换到指定的数据库，（如果没有会新建） show collections 查看当前目录下的所有数据表 db.表名.find() 查看表中的详细信息 在Node中如何操作MongoDB数据库使用官方的MongoDB包来操作 ​ http://mongodb.github.io/node-mongodb-native/ 使用第三方包mongoose来操作MongoDB数据库​ 第三方包：mongoose基于MongoDB官方的mongodb包再一次做了封装，名字叫mongoose，是WordPress项目团队开发的。 学习指南（步骤）官方学习文档：https://mongoosejs.com/docs/index.html 设计Scheme 发布Model (创建表)1234567891011121314151617181920212223242526272829303132333435// 1.引包// 注意：按照后才能require使用var mongoose = require(&#x27;mongoose&#x27;);// 拿到schema图表var Schema = mongoose.Schema;// 2.连接数据库// 指定连接数据库后不需要存在，当你插入第一条数据库后会自动创建数据库mongoose.connect(&#x27;mongodb://localhost/test&#x27;);// 3.设计集合结构（表结构）// 用户表var userSchema = new Schema(&#123; username: &#123; //姓名 type: String, require: true //添加约束，保证数据的完整性，让数据按规矩统一 &#125;, password: &#123; type: String, require: true &#125;, email: &#123; type: String &#125;&#125;);// 4.将文档结构发布为模型// mongoose.model方法就是用来将一个架构发布为 model// 第一个参数：传入一个大写名词单数字符串用来表示你的数据库的名称// mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称// 例如 这里会变成users集合名称// 第二个参数：架构// 返回值：模型构造函数var User = mongoose.model(&#x27;User&#x27;, userSchema); 添加数据（增）123456789101112131415// 5.通过模型构造函数对User中的数据进行操作var user = new User(&#123; username: &#x27;admin&#x27;, password: &#x27;123456&#x27;, email: &#x27;xiaochen@qq.com&#x27;&#125;);user.save(function(err, ret) &#123; if (err) &#123; console.log(&#x27;保存失败&#x27;); &#125; else &#123; console.log(&#x27;保存成功&#x27;); console.log(ret); &#125;&#125;); 删除（删）根据条件删除所有： 12345678910User.remove(&#123; username: &#x27;xiaoxiao&#x27;&#125;, function(err, ret) &#123; if (err) &#123; console.log(&#x27;删除失败&#x27;); &#125; else &#123; console.log(&#x27;删除成功&#x27;); console.log(ret); &#125;&#125;); 根据条件删除一个： 1Model.findOneAndRemove(conditions,[options],[callback]); 根据id删除一个： 1User.findByIdAndRemove(id,[options],[callback]); 更新（改）更新所有： 1User.remove(conditions,doc,[options],[callback]); 根据指定条件更新一个： 1User.FindOneAndUpdate([conditions],[update],[options],[callback]); 根据id更新一个： 12345678910// 更新 根据id来修改表数据User.findByIdAndUpdate(&#x27;5e6c5264fada77438c45dfcd&#x27;, &#123; username: &#x27;junjun&#x27;&#125;, function(err, ret) &#123; if (err) &#123; console.log(&#x27;更新失败&#x27;); &#125; else &#123; console.log(&#x27;更新成功&#x27;); &#125;&#125;); 查询（查）查询所有： 12345678// 查询所有User.find(function(err,ret)&#123; if(err)&#123; console.log(&#x27;查询失败&#x27;); &#125;else&#123; console.log(ret); &#125;&#125;); 条件查询所有： 12345678// 根据条件查询User.find(&#123; username:&#x27;xiaoxiao&#x27; &#125;,function(err,ret)&#123; if(err)&#123; console.log(&#x27;查询失败&#x27;); &#125;else&#123; console.log(ret); &#125;&#125;); 条件查询单个： 1234567891011// 按照条件查询单个，查询出来的数据是一个对象（&#123;&#125;）// 没有条件查询使用findOne方法，查询的是表中的第一条数据User.findOne(&#123; username: &#x27;xiaoxiao&#x27;&#125;, function(err, ret) &#123; if (err) &#123; console.log(&#x27;查询失败&#x27;); &#125; else &#123; console.log(ret); &#125;&#125;); 使用Node操作MySQL数据库文档：https://www.npmjs.com/package/mysql 安装： 1npm install --save mysql 1234567891011121314151617181920212223// 引入mysql包var mysql = require(&#x27;mysql&#x27;);// 创建连接var connection = mysql.createConnection(&#123; host : &#x27;localhost&#x27;, //本机 user : &#x27;me&#x27;, //账号root password : &#x27;secret&#x27;, //密码12345 database : &#x27;my_db&#x27; //数据库名&#125;); // 连接数据库 （打开冰箱门）connection.connect(); //执行数据操作 （把大象放到冰箱）connection.query(&#x27;SELECT * FROM `users` &#x27;, function (error, results, fields) &#123; if (error) throw error;//抛出异常阻止代码往下执行 // 没有异常打印输出结果 console.log(&#x27;The solution is: &#x27;,results);&#125;);//关闭连接 （关闭冰箱门）connection.end(); 异步编程回调函数不成立的情况下： 12345678910111213function add(x,y)&#123; console.log(1); setTimeout(function()&#123; console.log(2); var ret = x + y; return ret; &#125;,1000); console.log(3); //到这里执行就结束了，不会i等到前面的定时器，所以直接返回了默认值 undefined&#125;console.log(add(2,2));// 结果是 1 3 undefined 4 使用回调函数解决： 回调函数：通过一个函数，获取函数内部的操作。（根据输入得到输出结果） 12345678910111213141516var ret;function add(x,y,callback)&#123; // callback就是回调函数 // var x = 10; // var y = 20; // var callback = function(ret)&#123;console.log(ret);&#125; console.log(1); setTimeout(function()&#123; var ret = x + y; callback(ret); &#125;,1000); console.log(3);&#125;add(10,20,function(ret)&#123; console.log(ret);&#125;); 注意： ​ 凡是需要得到一个函数内部异步操作的结果（setTimeout,readFile,writeFile,ajax,readdir） ​ 这种情况必须通过 回调函数 (异步API都会伴随着一个回调函数) ajax: 基于原生XMLHttpRequest封装get方法： 1234567var oReq = new XMLHttpRequest();// 当请求加载成功要调用指定的函数oReq.onload = function()&#123; console.log(oReq.responseText);&#125;oReq.open(&quot;GET&quot;, &quot;请求路径&quot;,true);oReq.send(); 12345678910111213function get(url,callback)&#123; var oReq = new XMLHttpRequest(); // 当请求加载成功要调用指定的函数 oReq.onload = function()&#123; //console.log(oReq.responseText); callback(oReq.responseText); &#125; oReq.open(&quot;GET&quot;, url,true); oReq.send();&#125;get(&#x27;data.json&#x27;,function(data)&#123; console.log(data);&#125;); Promisecallback hell（回调地狱）: 文件的读取无法判断执行顺序（文件的执行顺序是依据文件的大小来决定的）(异步api无法保证文件的执行顺序) 12345678910111213141516171819202122232425var fs = require(&#x27;fs&#x27;);fs.readFile(&#x27;./data/a.text&#x27;,&#x27;utf8&#x27;,function(err,data)&#123; if(err)&#123; // 1 读取失败直接打印输出读取失败 return console.log(&#x27;读取失败&#x27;); // 2 抛出异常 // 阻止程序的执行 // 把错误信息打印到控制台 throw err; &#125; console.log(data);&#125;);fs.readFile(&#x27;./data/b.text&#x27;,&#x27;utf8&#x27;,function(err,data)&#123; if(err)&#123; // 1 读取失败直接打印输出读取失败 return console.log(&#x27;读取失败&#x27;); // 2 抛出异常 // 阻止程序的执行 // 把错误信息打印到控制台 throw err; &#125; console.log(data);&#125;); 通过回调嵌套的方式来保证顺序： 1234567891011121314151617181920212223242526272829303132333435var fs = require(&#x27;fs&#x27;);fs.readFile(&#x27;./data/a.text&#x27;,&#x27;utf8&#x27;,function(err,data)&#123; if(err)&#123; // 1 读取失败直接打印输出读取失败 return console.log(&#x27;读取失败&#x27;); // 2 抛出异常 // 阻止程序的执行 // 把错误信息打印到控制台 throw err; &#125; console.log(data); fs.readFile(&#x27;./data/b.text&#x27;,&#x27;utf8&#x27;,function(err,data)&#123; if(err)&#123; // 1 读取失败直接打印输出读取失败 return console.log(&#x27;读取失败&#x27;); // 2 抛出异常 // 阻止程序的执行 // 把错误信息打印到控制台 throw err; &#125; console.log(data); fs.readFile(&#x27;./data/a.text&#x27;,&#x27;utf8&#x27;,function(err,data)&#123; if(err)&#123; // 1 读取失败直接打印输出读取失败 return console.log(&#x27;读取失败&#x27;); // 2 抛出异常 // 阻止程序的执行 // 把错误信息打印到控制台 throw err; &#125; console.log(data); &#125;); &#125;);&#125;); Promise：承诺，保证 Promise本身不是异步的，但往往都是内部封装一个异步任务 基本语法： 12345678910111213141516171819202122232425262728// 在EcmaScript 6中新增了一个API Promise// Promise 是一个构造函数var fs = require(&#x27;fs&#x27;);// 1 创建Promise容器 resolve:解决 reject：失败var p1 = new Promise(function(resolve, reject) &#123; fs.readFile(&#x27;./a.text&#x27;, &#x27;utf8&#x27;, function(err, data) &#123; if (err) &#123; // console.log(err); // 把容器的Pending状态变为rejected reject(err); &#125; else &#123; // console.log(data); // 把容器的Pending状态变为resolve resolve(1234); &#125; &#125;);&#125;);// 当p1成功了，然后就（then）做指定的操作// then方法接收的function就是容器中的resolve函数p1 .then(function(data) &#123; console.log(data); &#125;, function(err) &#123; console.log(&#x27;读取文件失败了&#x27;, err); &#125;); 封装Promise的readFile： 123456789101112131415161718192021222324252627var fs = require(&#x27;fs&#x27;);function pReadFile(filePath) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(filePath, &#x27;utf8&#x27;, function(err, data) &#123; if (err) &#123; reject(err); &#125; else &#123; resolve(data); &#125; &#125;); &#125;);&#125;pReadFile(&#x27;./a.txt&#x27;) .then(function(data) &#123; console.log(data); return pReadFile(&#x27;./b.txt&#x27;); &#125;) .then(function(data) &#123; console.log(data); return pReadFile(&#x27;./a.txt&#x27;); &#125;) .then(function(data) &#123; console.log(data); &#125;) mongoose所有的API都支持Promise： 12345// 查询所有User.find() .then(function(data)&#123; console.log(data) &#125;) 注册： 12345678910111213User.findOne(&#123;username:&#x27;admin&#x27;&#125;,function(user)&#123; if(user)&#123; console.log(&#x27;用户已存在&#x27;) &#125; else &#123; new User(&#123; username:&#x27;aaa&#x27;, password:&#x27;123&#x27;, email:&#x27;fffff&#x27; &#125;).save(function()&#123; console.log(&#x27;注册成功&#x27;); &#125;) &#125;&#125;) 1234567891011121314151617181920User.findOne(&#123; username:&#x27;admin&#x27;&#125;) .then(function(user)&#123; if(user)&#123; // 用户已经存在不能注册 console.log(&#x27;用户已存在&#x27;); &#125; else&#123; // 用户不存在可以注册 return new User(&#123; username:&#x27;aaa&#x27;, password:&#x27;123&#x27;, email:&#x27;fffff&#x27; &#125;).save(); &#125; &#125;) .then(funciton(ret)&#123; console.log(&#x27;注册成功&#x27;); &#125;) Generatorasync函数 其他修改完代码自动重启我们在这里可以使用一个第三方命名行工具：nodemon来帮助我们解决频繁修改代码重启服务器的问题。 nodemon是一个基于Node.js开发的一个第三方命令行工具，我们使用的时候需要独立安装： 1234567#在任意目录执行该命令都可以#也就是说，所有需要 --global安装的包都可以在任意目录执行npm install --global nodemonnpm install -g nodemon#如果安装不成功的话，可以使用cnpm安装cnpm install -g nodemon 安装完毕之后使用： 1234node app.js#使用nodemonnodemon app.js 只要是通过nodemon启动的服务，则他会监视你的文件变化，当文件发生变化的时候，会自动帮你重启服务器。 封装异步API回调函数：获取异步操作的结果 1234567891011function fn(callback)&#123; // var callback = funtion(data)&#123; console.log(data); &#125; setTimeout(function()&#123; var data = &#x27;hello&#x27;; callback(data); &#125;,1000);&#125;// 如果需要获取一个函数中异步操作的结果，则必须通过回调函数的方式来获取fn(function(data)&#123; console.log(data);&#125;) 数组的遍历方法，都是对函数作为一种参数EcmaScript 6 参考文档：https://es6.ruanyifeng.com/ 项目案例目录结构12345678910.app.js 项目的入口文件controllersmodels 存储使用mongoose设计的数据模型node_modules 第三方包package.json 包描述文件package-lock.json 第三方包版本锁定文件（npm5之后才有）public 公共静态资源routesviews 存储视图目录 模板页 子模板 模板继承 路由设计 路由 方法 get参数 post参数 是否需要登录 备注 / get 渲染首页 /register(登录) get 渲染注册页面 /register post email,nickname,password 处理注册请求 /login get 渲染登陆界面 /login post email,password 处理登录请求 /loginout get 处理退出请求 模型设计功能实现步骤 创建目录结构 整合静态也-模板页 include block extend 设计用户登陆，退出，注册的路由 用户注册 先处理客户端页面的内容（表单控件的name，收集表单数据，发起请求） 服务端 获取从客户端收到的数据 操作数据库 如果有错，发送500告诉客户端服务器错了‘ 其他的根据业务发送不同的响应数据 登录 退出 Express中间件中间件的概念 参考文档：http://expressjs.com/en/guide/using-middleware.html 中间件：把很复杂的事情分割成单个，然后依次有条理的执行。就是一个中间处理环节，有输入，有输出。 说的通俗易懂点儿，中间件就是一个（从请求到响应调用的方法）方法。 把数据从请求到响应分步骤来处理，每一个步骤都是一个中间处理环节。 123456789101112131415161718192021222324252627var http = require(&#x27;http&#x27;);var url = require(&#x27;url&#x27;);var cookie = require(&#x27;./expressPtoject/cookie&#x27;);var query = require(&#x27;./expressPtoject/query&#x27;);var postBody = require(&#x27;./expressPtoject/post-body&#x27;);var server = http.createServer(function()&#123; // 解析请求地址中的get参数 // var obj = url.parse(req.url,true); // req.query = obj.query; query(req,res); //中间件 // 解析请求地址中的post参数 req.body = &#123; foo:&#x27;bar&#x27; &#125;&#125;);if(req.url === &#x27;xxx&#x27;)&#123; // 处理请求 ...&#125;server.listen(3000,function()&#123; console.log(&#x27;3000 runing...&#x27;);&#125;); 同一个请求对象所经过的中间件都是同一个请求对象和响应对象。 12345678910111213141516171819202122var express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/abc&#x27;,function(req,res,next)&#123; // 同一个请求的req和res是一样的， // 可以前面存储下面调用 console.log(&#x27;/abc&#x27;); // req.foo = &#x27;bar&#x27;; req.body = &#123; name:&#x27;xiaoxiao&#x27;, age:18 &#125; next();&#125;);app.get(&#x27;/abc&#x27;,function(req,res,next)&#123; // console.log(req.foo); console.log(req.body); console.log(&#x27;/abc&#x27;);&#125;);app.listen(3000, function() &#123; console.log(&#x27;app is running at port 3000.&#x27;);&#125;); 中间件的分类:应用程序级别的中间件万能匹配（不关心任何请求路径和请求方法的中间件）： 1234app.use(function(req,res,next)&#123; console.log(&#x27;Time&#x27;,Date.now()); next();&#125;); 关心请求路径和请求方法的中间件： 1234app.use(&#x27;/a&#x27;,function(req,res,next)&#123; console.log(&#x27;Time&#x27;,Date.now()); next();&#125;); 路由级别的中间件严格匹配请求路径和请求方法的中间件 get: 123app.get(&#x27;/&#x27;,function(req,res)&#123; res.send(&#x27;get&#x27;);&#125;); post： 123app.post(&#x27;/a&#x27;,function(req,res)&#123; res.send(&#x27;post&#x27;);&#125;); put: 123app.put(&#x27;/user&#x27;,function(req,res)&#123; res.send(&#x27;put&#x27;);&#125;); delete: 123app.delete(&#x27;/delete&#x27;,function(req,res)&#123; res.send(&#x27;delete&#x27;);&#125;); 总12345678910111213141516171819202122232425262728293031323334353637383940414243var express = require(&#x27;express&#x27;);var app = express();// 中间件：处理请求，本质就是个函数// 在express中，对中间件有几种分类// 1 不关心任何请求路径和请求方法的中间件// 也就是说任何请求都会进入这个中间件// 中间件本身是一个方法，该方法接收三个参数// Request 请求对象// Response 响应对象// next 下一个中间件// // 全局匹配中间件// app.use(function(req, res, next) &#123;// console.log(&#x27;1&#x27;);// // 当一个请求进入中间件后// // 如果需要请求另外一个方法则需要使用next（）方法// next();// // next是一个方法，用来调用下一个中间件// // 注意：next（）方法调用下一个方法的时候，也会匹配（不是调用紧挨着的哪一个）// &#125;);// app.use(function(req, res, next) &#123;// console.log(&#x27;2&#x27;);// &#125;);// // 2 关心请求路径的中间件// // 以/xxx开头的中间件// app.use(&#x27;/a&#x27;,function(req, res, next) &#123;// console.log(req.url);// &#125;);// 3 严格匹配请求方法和请求路径的中间件app.get(&#x27;/&#x27;,function()&#123; console.log(&#x27;/&#x27;);&#125;);app.post(&#x27;/a&#x27;,function()&#123; console.log(&#x27;/a&#x27;);&#125;);app.listen(3000, function() &#123; console.log(&#x27;app is running at port 3000.&#x27;);&#125;); 错误处理中间件1234app.use(function(err,req,res,next)&#123; console.error(err,stack); res.status(500).send(&#x27;Something broke&#x27;);&#125;); 配置使用404中间件： 123app.use(function(req,res)&#123; res.render(&#x27;404.html&#x27;);&#125;); 配置全局错误处理中间件: 1234567891011121314151617app.get(&#x27;/a&#x27;, function(req, res, next) &#123; fs.readFile(&#x27;.a/bc&#x27;, funtion() &#123; if (err) &#123; // 当调用next()传参后，则直接进入到全局错误处理中间件方法中 // 当发生全局错误的时候，我们可以调用next传递错误对象 // 然后被全局错误处理中间件匹配到并进行处理 next(err); &#125; &#125;)&#125;);//全局错误处理中间件app.use(function(err,req,res,next)&#123; res.status(500).json(&#123; err_code:500, message:err.message &#125;);&#125;); 内置中间件 express.static(提供静态文件) http://expressjs.com/en/starter/static-files.html#serving-static-files-in-express 第三方中间件 参考文档：http://expressjs.com/en/resources/middleware.html body-parser compression cookie-parser mogran response-time server-static session","categories":[{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"模块化开发","slug":"模块化开发","permalink":"http://example.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"Express框架","slug":"Express框架","permalink":"http://example.com/tags/Express%E6%A1%86%E6%9E%B6/"}]},{"title":"Ajax前后端交互利器详解(一)","slug":"Ajax前后端交互利器详解(一)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T06:55:39.614Z","comments":true,"path":"2022/04/24/Ajax前后端交互利器详解(一)/","link":"","permalink":"http://example.com/2022/04/24/Ajax%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%88%A9%E5%99%A8%E8%AF%A6%E8%A7%A3(%E4%B8%80)/","excerpt":"","text":"参考配套视频：web前后端交互 Ajax Ajax运行原理Ajax 相当于浏览器发送请求与接收响应的代理人，以实现在不影响用户浏览页面的情况下，局部更新页面数据，从而提高用户体验 Ajax实现步骤 创建Ajax对象 1var xhr = new XMLHttpRequest(); 告诉Ajax 请求地址以及请求方式 1xhr.open(method,url); 发送请求 1xhr.send(body); // get请求不传 body参数,只有 post 请求使用 获取服务器端给客户端的响应数据 12345xhr.onload = function() &#123; // xhr.responseText 接收文本格式的响应数据 // xhr.responseXML 接收 xml 格式的响应数据 console.log(xhr.responseText);&#125; 快速入门1234567891011121314&lt;script&gt; // 1.创建ajax对象 var xhr = new XMLHttpRequest(); // 2.告诉Ajax对象要向哪发送地址，以什么样的方式发送请求 // (1)请求方式 (2)请求地址 xhr.open(&#x27;get&#x27;,&#x27;http://localhost:3000/first&#x27;); // 3.发送请求 xhr.send(); // 4.获取服务器端响应到客户端的数据 xhr.onload = function() &#123; // xhr.responseText console.log(xhr.responseText); &#125;&lt;/script&gt; 在服务器端创建路由： 123456789101112131415// 引入express框架const express = require(&#x27;express&#x27;);// 创建web服务器const app = express();// 创建路由app.get(&#x27;/first&#x27;,(req,res) =&gt; &#123; res.send(&#x27;Hello,ajax&#x27;);&#125;);// 监听端口app.listen(3000,()=&gt;&#123; console.log(&#x27;服务器启动成功&#x27;);&#125;); 服务器端响应的数据格式 在真实的项目中，服务器端大多数情况下会以 JSON 对象作为响应数据的格式。 当客户端拿到响应数据时，要将 JSON 数据和 HTML 字符串进行拼接，然后将拼接的结果展示在页面中。 在 http 请求与响应的过程中，无论是请求参数还是响应内容，如果是对象类型，最终都会被转换为对象字符串进行传输。 1234567891011121314&lt;script&gt; // 1.创建ajax对象 var xhr = new XMLHttpRequest(); // 2.告诉Ajax对象要向哪发送地址，以什么样的方式发送请求 // (1)请求方式 (2)请求地址 xhr.open(&#x27;get&#x27;, &#x27;http://localhost:3000/responseData&#x27;); // 3.发送请求 xhr.send(); // 4.获取服务器端响应到客户端的数据 xhr.onload = function() &#123; console.log(xhr.responseText); console.log(typeof xhr.responseText) &#125;&lt;/script&gt; 在 app.js 中设置路由 1234567891011121314151617181920// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 创建路由app.get(&#x27;/responseData&#x27;, (req, res) =&gt; &#123; // 响应一个 json 对象 res.send(&#123; &quot;name&quot;: &quot;zhangsan&quot; &#125;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务器启动成功&#x27;);&#125;); 我们需要将 json 字符串转换为 json 对象 12345678910111213141516171819202122JSON.parse() //将 json 字符串转换为json对象1&lt;script&gt; // 1.创建ajax对象 var xhr = new XMLHttpRequest(); // 2.告诉Ajax对象要向哪发送地址，以什么样的方式发送请求 // (1)请求方式 (2)请求地址 xhr.open(&#x27;get&#x27;, &#x27;http://localhost:3000/responseData&#x27;); // 3.发送请求 xhr.send(); // 4.获取服务器端响应到客户端的数据 xhr.onload = function() &#123; // 将JSON字符串转换为JSON对象 var responseText = JSON.parse(xhr.responseText); // 测试:在控制台输出处理结果 console.log(responseText) // 将数据和html字符串进行拼接 var str = &#x27;&lt;h2&gt;&#x27; + responseText.name + &#x27;&lt;/h2&gt;&#x27;; // 将拼接的结果追加到页面中 document.body.innerHTML = str; &#125;&lt;/script&gt; 传递get请求参数 传统网站表单提交 123456&lt;form method=&quot;get&quot; action=&quot;http://www.example.com&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/form&gt;&lt;!– http://www.example.com?username=zhangsan&amp;password=123456 --&gt; GET请求方式 123456789101112131415161718192021222324252627282930313233xhr.open(&#x27;get&#x27;, &#x27;http://www.example.com?name=zhangsan&amp;age=20&#x27;);1&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; id=&quot;age&quot;&gt;&lt;br/&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; id=&quot;btn&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 获取按钮元素 var btn = document.getElementById(&#x27;btn&#x27;); // 获取姓名文本框 var username = document.getElementById(&#x27;username&#x27;); // 获取年龄文本框 var age = document.getElementById(&#x27;age&#x27;); // 为按钮添加点击事件 btn.onclick = function() &#123; // 创建ajax对象 var xhr = new XMLHttpRequest(); // 获取用户在文本框中输入的值 var nameValue = username.value; var ageValue = age.value; // 拼接请求参数 var params = &#x27;username=&#x27; + nameValue + &#x27;&amp;age=&#x27; + ageValue; // 配置ajax对象请求方式和请求地址 xhr.open(&#x27;get&#x27;, &#x27;http://localhost:3000/get?&#x27; + params); // 发送请求 xhr.send(); // 获取服务器端响应的数据 xhr.onload = function() &#123; console.log(xhr.responseText) &#125; &#125; &lt;/script&gt;&lt;/body&gt; 在 app.js 中创建路由 12345678910111213141516171819// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 创建路由app.get(&#x27;/get&#x27;, (req, res) =&gt; &#123; // 获取 get 请求参数 res.send(req.query);&#125;)// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务器启动成功&#x27;);&#125;); 请求报文 在 HTTP 请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，这些数据和信息要遵守规定好的格式 传递POST请求参数 POST请求方式 123456789101112131415161718192021222324252627282930313233343536373839// post请求必须要设置请求参数格式的类型xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;) // 发送请求(POST请求要带参数)xhr.send(&#x27;name=zhangsan&amp;age=20&#x27;);1234&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; id=&quot;age&quot;&gt;&lt;br/&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; id=&quot;btn&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 获取按钮元素 var btn = document.getElementById(&#x27;btn&#x27;); // 获取姓名文本框 var username = document.getElementById(&#x27;username&#x27;); // 获取年龄文本框 var age = document.getElementById(&#x27;age&#x27;); // 为按钮添加点击事件 btn.onclick = function() &#123; // 创建ajax对象 var xhr = new XMLHttpRequest(); // 获取用户在文本框中输入的值 var nameValue = username.value; var ageValue = age.value; // 拼接请求参数 var params = &#x27;username=&#x27; + nameValue + &#x27;&amp;age=&#x27; + ageValue; // 配置ajax对象请求方式和请求地址 xhr.open(&#x27;post&#x27;, &#x27;http://localhost:3000/post&#x27;); // 设置请求参数格式的类型(post请求必须要设置) xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); // 发送请求(POST请求要带参数) xhr.send(params); // 获取服务器端响应的数据 xhr.onload = function() &#123; console.log(xhr.responseText) &#125; &#125; &lt;/script&gt;&lt;/body&gt; 在 app.js 中创建路由 12345678910111213141516171819202122232425// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 第三方模块const bodyParser = require(&#x27;body-parser&#x27;);// parse application/x-www-form-urlencodedapp.use(express.urlencoded(&#123; extended: false &#125;))// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 创建路由app.post(&#x27;/post&#x27;, (req, res) =&gt; &#123; // 获取 post 请求参数 res.send(req.body);&#125;)// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务器启动成功&#x27;);&#125;); 注意：借助了第三方模块 body-parser 请求参数的格式我们客户端在向服务器端发送请求参数有以下几种格式，不同的格式需要设置的请求头也是不一样的 设置请求头为 application/x-www-form-urlencoded ,传递如下请求参数 1name=zhangsan&amp;age=20&amp;sex=男 设置请求头为 application/json ,传递如下请求参数，是 json 对象 1&#123;name: &#x27;zhangsan&#x27;, age: &#x27;20&#x27;, sex: &#x27;男&#x27;&#125; 在请求头中指定 Content-Type 属性的值是 application/json，告诉服务器端当前请求参数的格式是 json，我们还需要将 json 对象转换为 json 字符串，因为请求参数必须要以字符串格式传递 123456789101112131415161718JSON.stringify() // 将json对象转换为json字符串&lt;script type=&quot;text/javascript&quot;&gt; // 1.创建ajax对象 var xhr = new XMLHttpRequest(); // 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求 // 1)请求方式 2)请求地址 xhr.open(&#x27;post&#x27;, &#x27;http://localhost:3000/json&#x27;); // 通过请求头告诉服务器端客户端向服务器端传递的请求参数的格式是什么 xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;); // JSON.stringify() 将json对象转换为json字符串 // 3.发送请求 xhr.send(JSON.stringify(&#123;name: &#x27;lisi&#x27;,age: 50&#125;)); // 4.获取服务器端响应到客户端的数据 xhr.onload = function() &#123; console.log(xhr.responseText) &#125;&lt;/script&gt; 在app.js 中配置路由 123456789101112131415161718192021222324// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 第三方模块const bodyParser = require(&#x27;body-parser&#x27;);// 创建web服务器const app = express();// parse application/jsonapp.use(express.json())// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 创建路由app.post(&#x27;/json&#x27;, (req, res) =&gt; &#123; res.send(req.body);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务器启动成功&#x27;);&#125;); 注意：get 请求是不能提交 json 对象数据格式的，传统网站的表单提交也是不支持 json 对象数据格式的。 获取服务器端的响应Ajax状态码在创建ajax对象，配置ajax对象，发送请求，以及接收完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。 0：请求未初始化(还没有调用open()) 1：请求已经建立，但是还没有发送(还没有调用send()) 2：请求已经发送 3：请求正在处理中，通常响应中已经有部分数据可以用了 4：响应已经完成，可以获取并使用服务器的响应了 1xhr.readyState // 获取Ajax状态码 onreadystatechange事件当 Ajax 状态码发生变化时将自动触发该事件。 在事件处理函数中可以获取 Ajax 状态码并对其进行判断，当状态码为 4 时就可以通过 xhr.responseText 获取服务器端的响应数据了 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt; var xhr = new XMLHttpRequest(); // 0 已经创建了ajax对象 但是还没有对ajax对象进行配置 console.log(xhr.readyState); xhr.open(&#x27;get&#x27;, &#x27;http://localhost:3000/readystate&#x27;); // 1 已经对ajax对象进行配置 但是还没有发送请求 console.log(xhr.readyState); // 当ajax状态码发生变化的时候出发 xhr.onreadystatechange = function() &#123; // 2 请求已经发送了 // 3 已经接收到服务器端的部分数据了 // 4 服务器端的响应数据已经接收完成 console.log(xhr.readyState); // 对ajax状态码进行判断 如果状态码的值为4就代表数据已经接收完成了 if (xhr.readyState == 4) &#123; console.log(xhr.responseText); &#125; &#125; xhr.send();&lt;/script&gt; 在 app.js 中配置路由 123456789101112131415161718192021222324// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 第三方模块const bodyParser = require(&#x27;body-parser&#x27;);// 创建web服务器const app = express();// parse application/jsonapp.use(express.json())// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 创建路由app.get(&#x27;/readystate&#x27;, (req, res) =&gt; &#123; res.send(&#x27;hello&#x27;);&#125;);// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务器启动成功&#x27;);&#125;); 区别两种获取服务器端响应方式的区别 区别描述 onload事件 onreadystatechange事件 是否兼容IE低版本 不兼容 兼容 是否需要判断Ajax状态码 不需要 需要 被调用次数 一次 多次 Ajax错误处理 网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果。 我们可以判断服务器端返回的状态码，分别进行处理。xhr.status 获取http状态码 12345678910111213141516171819202122232425&lt;body&gt; &lt;button id=&quot;btn&quot;&gt;发送Ajax请求&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; var btn = document.getElementById(&#x27;btn&#x27;); btn.onclick = function() &#123; // 1.创建ajax对象 var xhr = new XMLHttpRequest(); // 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求 // 1)请求方式 2)请求地址 xhr.open(&#x27;get&#x27;, &#x27;http://localhost:3000/error&#x27;); // 3.发送请求 xhr.send(); // 4.获取服务器端响应到客户端的数据 xhr.onload = function() &#123; // xhr.status 获取http状态码 console.log(xhr.status); console.log(xhr.responseText); if (xhr.status == 400) &#123; alert(&#x27;请求出错&#x27;); &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 在app.js 中设置路由 12345678910111213141516171819202122232425// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;);// 第三方模块const bodyParser = require(&#x27;body-parser&#x27;);// 创建web服务器const app = express();// parse application/jsonapp.use(express.json())// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 创建路由app.get(&#x27;/error&#x27;, (req, res) =&gt; &#123; // res.status 设置http状态码 res.status(400).send(&#x27;not ok&#x27;);&#125;)// 监听端口app.listen(3000, () =&gt; &#123; console.log(&#x27;服务器启动成功&#x27;);&#125;); 几种错误示例Ajax 请求报错通常会出现以下几种情况，我们来进行查看并排查 网络畅通，服务器端没有接收到请求，返回404状态码 检查请求地址是否错误。 网络畅通，服务器端能接收到请求，服务器端返回500状态码。 服务器端错误，找后端程序员进行沟通 12345app.get(&#x27;/error&#x27;, (req, res) =&gt; &#123; // 打印一个未定义的变量,服务器端就会出现错误 console.log(abc); res.send(&quot;hello&quot;)&#125;) 网络中断，请求无法发送到服务器端。 会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理。 1234// 当网络中断时会触发onerrr事件xhr.onerror = function() &#123; alert(&#x27;网络中断, 无法发送Ajax请求&#x27;)&#125; Ajax状态码: 表示Ajax请求的过程状态 ajax对象返回的(0、1、2、3、4) Http状态码: 表示请求的处理结果 是服务器端返回的 低版本 IE 浏览器的缓存问题问题：在低版本的 IE 浏览器中，Ajax 请求有严重的缓存问题，即在请求地址不发生变化的情况下，只有第一次请求会真正发送到服务器端，后续的请求都会从浏览器的缓存中获取结果。即使服务器端的数据更新了，客户端依然拿到的是缓存中的旧数据。 解决方案：在请求地址的后面加请求参数，保证每一次请求中的请求参数的值不相同 1xhr.open(&#x27;get&#x27;, &#x27;http://www.example.com?t=&#x27; + Math.random()); Ajax异步编程同步异步概述同步 一个人同一时间只能做一件事情，只有一件事情做完，才能做另外一件事情 落实到代码上，就是上一行代码执行完成后，才能执行下一行代码，即代码逐行执行 12console.log(&quot;before&quot;);console.log(&quot;after&quot;); 异步 一个人一件事情做了一半，转而去做其他事情，当其他事情做完以后，再回过头来继续做之前未完成的事情。 落实到代码上，就是异步代码虽然需要花费时间去执行，但程序不会等待异步代码执行完成后再继续执行后续代码，而是直接执行后续代码，当后续代码执行完成后再回头看异步代码是否返回结果，如果已有返回结果，再调用事先准备好的回调函数处理异步代码执行的结果。 12345console.log(&#x27;before&#x27;); setTimeout( () =&gt; &#123; console.log(&#x27;last&#x27;); &#125;, 2000); console.log(&#x27;after&#x27;); Ajax封装问题: 发送一次请求代码过多，发送多次请求代码冗余且重复 解决方案：将请求代码封装到函数中，发请求时调用函数即可 Ajax 封装代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function ajax (options) &#123; // 默认值 var defaults = &#123; type: &#x27;get&#x27;, url: &#x27;&#x27;, async: true, data: &#123;&#125;, header: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;, success: function () &#123;&#125;, error: function () &#123;&#125; &#125; // 使用用户传递的参数替换默认值参数 Object.assign(defaults, options); // 创建ajax对象 var xhr = new XMLHttpRequest(); // 参数拼接变量 var params = &#x27;&#x27;; // 循环参数 for (var attr in defaults.data) &#123; // 参数拼接 params += attr + &#x27;=&#x27; + defaults.data[attr] + &#x27;&amp;&#x27;; // 去掉参数中最后一个&amp; params = params.substr(0, params.length-1) &#125; // 如果请求方式为get if (defaults.type == &#x27;get&#x27;) &#123; // 将参数拼接在url地址的后面 defaults.url += &#x27;?&#x27; + params; &#125; // 配置ajax请求 xhr.open(defaults.type, defaults.url, defaults.async); // 如果请求方式为post if (defaults.type == &#x27;post&#x27;) &#123; // 设置请求头 xhr.setRequestHeader(&#x27;Content-Type&#x27;, defaults.header[&#x27;Content-Type&#x27;]); // 如果想服务器端传递的参数类型为json if (defaults.header[&#x27;Content-Type&#x27;] == &#x27;application/json&#x27;) &#123; // 将json对象转换为json字符串 xhr.send(JSON.stringify(defaults.data)) &#125;else &#123; // 发送请求 xhr.send(params); &#125; &#125; else &#123; xhr.send(); &#125; // 请求加载完成 xhr.onload = function () &#123; // 获取服务器端返回数据的类型 var contentType = xhr.getResponseHeader(&#x27;content-type&#x27;); // 获取服务器端返回的响应数据 var responseText = xhr.responseText; // 如果服务器端返回的数据是json数据类型 if (contentType.includes(&#x27;application/json&#x27;)) &#123; // 将json字符串转换为json对象 responseText = JSON.parse(responseText); &#125; // 如果请求成功 if (xhr.status == 200) &#123; // 调用成功回调函数, 并且将服务器端返回的结果传递给成功回调函数 defaults.success(responseText, xhr); &#125; else &#123; // 调用失败回调函数并且将xhr对象传递给回调函数 defaults.error(responseText, xhr); &#125; &#125; // 当网络中断时 xhr.onerror = function () &#123; // 调用失败回调函数并且将xhr对象传递给回调函数 defaults.error(xhr); &#125;&#125; 我们可以将上述代码抽离成一个 ajax.js 文件，这样我们的客户端只需要引入 ajax.js 文件，并传递相应的参数，这样就可以大大节省我们的代码量 123456789101112&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/ajax.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; ajax(&#123; url: &#x27;&#x27;, type: &#x27;&#x27;, success: function() &#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 模板引擎模板引擎概述 作用: 使用模板引擎提供的模板语法，可以将数据和 HTML 拼接起来 官方地址：https://aui.github.io/art-template/zh-cn/index.html 使用步骤 下载 art-template 模板引擎库文件并在 HTML 页面中引入库文件 1&lt;script src=&quot;./js/template-web.js&quot;&gt;&lt;/script&gt; 准备 art-template 模板 123&lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/script&gt; 告诉模板引擎将哪一个模板和哪个数据进行拼接 第一个参数是 模板ID 第二个参数是 对象 方法的返回值就是拼接好的 html 字符串 1var html = template(&#x27;tpl&#x27;, &#123;username: &#x27;zhangsan&#x27;, age: &#x27;20&#x27;&#125;); 将拼接好的html字符串添加到页面中 1document.getElementById(&#x27;container&#x27;).innerHTML = html; 通过模板语法告诉模板引擎，数据和html字符串要如何拼接 123&lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;div class=&quot;box&quot;&gt; &#123;&#123; username &#125;&#125; &lt;/div&gt; &lt;/script&gt; FormDataFormData对象的作用 模拟HTML表单，相当于将HTML表单映射成表单对象，自动将表单对象中的数据拼接成请求参数的格式。 异步上传二进制文件 FormData对象的使用 准备HTML表单 12345&lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;input type=&quot;button&quot;/&gt;&lt;/form&gt; 将 HTML 表单转化为 formData 对象 12var form = document.getElementById(&#x27;form&#x27;); var formData = new FormData(form); 提交表单对象 1xhr.send(formData); 例如客户端代码如下： 1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;!-- 创建普通的html表单 --&gt; &lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 获取按钮 var btn = document.getElementById(&#x27;btn&#x27;); // 获取表单 var form = document.getElementById(&#x27;form&#x27;); // 为按钮添加点击事件 btn.onclick = function() &#123; // 将普通的html表单转换为表单对象 var formData = new FormData(form); // 创建ajax对象 var xhr = new XMLHttpRequest(); // 对ajax对象进行配置 xhr.open(&#x27;post&#x27;, &#x27;http://localhost:3000/formData&#x27;); // 发送ajax请求 xhr.send(formData); // 监听xhr对象下面的onload事件 xhr.onload = function() &#123; // 对象http状态码进行判断 if (xhr.status == 200) &#123; console.log(xhr.responseText); &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 服务器端代码如下： 之前我们使用 body-parser 第三方模块处理客户端向服务器端提供的 POST 请求参数，但是 body-parser 不能处理客户端向服务器端提供的 formData 对象 这里要使用 formidable 第三方模块：https://www.npmjs.com/package/formidable 1234567891011121314151617181920212223// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;)const formidable = require(&#x27;formidable&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.post(&#x27;/formData&#x27;, (req, res) =&gt; &#123; // 创建formidable表单解析对象 const form = new formidable.IncomingForm(); // 解析客户端传递过来的FormData对象 form.parse(req, (err, fields, files) =&gt; &#123; res.send(fields); &#125;);&#125;);// 监听端口app.listen(3000); 注意： Formdata 对象不能用于 get 请求，因为对象需要被传递到 send 方法中，而 get 请求方式的请求参数只能放在请求地址的后面。 服务器端 bodyParser 模块不能解析 formData 对象表单数据，我们需要使用 formidable 模块进行解析 FormData对象的实例方法 获取表单对象中属性的值 1formData.get(&#x27;key&#x27;); 设置表单对象中属性的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647formData.set(&#x27;key&#x27;, &#x27;value&#x27;);&lt;body&gt; &lt;!-- 创建普通的html表单 --&gt; &lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 获取按钮 var btn = document.getElementById(&#x27;btn&#x27;); // 获取表单 var form = document.getElementById(&#x27;form&#x27;); // 为按钮添加点击事件 btn.onclick = function() &#123; // 将普通的html表单转换为表单对象 var formData = new FormData(form); /* get(&#x27;key&#x27;) 获取表单对象属性的值 set(&#x27;key&#x27;, &#x27;value&#x27;) 设置表单对象属性的值 delete(&#x27;key&#x27;) 删除表单对象属性中的值 */ console.log(formData.get(&#x27;username&#x27;)); // 如果设置的表单属性存在 将会覆盖属性原有的值 formData.set(&#x27;username&#x27;, &#x27;itcast&#x27;); // 如果设置的表单属性不存在 将会创建这个表单属性 formData.set(&#x27;age&#x27;, 100); // 创建ajax对象 var xhr = new XMLHttpRequest(); // 对ajax对象进行配置 xhr.open(&#x27;post&#x27;, &#x27;http://localhost:3000/formData&#x27;); // 发送ajax请求 xhr.send(formData); // 监听xhr对象下面的onload事件 xhr.onload = function() &#123; // 对象http状态码进行判断 if (xhr.status == 200) &#123; console.log(xhr.responseText); &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 删除表单对象中属性的值 1formData.delete(&#x27;key&#x27;); 向表单对象中追加属性值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748formData.append(&#x27;key&#x27;, &#x27;value&#x27;);&lt;body&gt; &lt;!-- 创建普通的html表单 --&gt; &lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 获取按钮 var btn = document.getElementById(&#x27;btn&#x27;); // 获取表单 var form = document.getElementById(&#x27;form&#x27;); // 为按钮添加点击事件 btn.onclick = function() &#123; // 将普通的html表单转换为表单对象 var formData = new FormData(form); /* get(&#x27;key&#x27;) 获取表单对象属性的值 set(&#x27;key&#x27;, &#x27;value&#x27;) 设置表单对象属性的值 delete(&#x27;key&#x27;) 删除表单对象属性中的值 */ console.log(formData.get(&#x27;username&#x27;)); // 如果设置的表单属性存在 将会覆盖属性原有的值 formData.set(&#x27;username&#x27;, &#x27;itcast&#x27;); formData.append(&#x27;username&#x27;, &#x27;itheima&#x27;); // 如果设置的表单属性不存在 将会创建这个表单属性 formData.set(&#x27;age&#x27;, 100); // 删除用户输入的密码 formData.delete(&#x27;password&#x27;); // 创建ajax对象 var xhr = new XMLHttpRequest(); // 对ajax对象进行配置 xhr.open(&#x27;post&#x27;, &#x27;http://localhost:3000/formData&#x27;); // 发送ajax请求 xhr.send(formData); // 监听xhr对象下面的onload事件 xhr.onload = function() &#123; // 对象http状态码进行判断 if (xhr.status == 200) &#123; console.log(xhr.responseText); &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 注意：set 方法与 append 方法的区别是，在属性名已存在的情况下，set 会覆盖已有键名的值，append会保留两个值。 FormData二进制文件上传1&lt;input type=&quot;file&quot; id=&quot;file&quot;/&gt; 二进制文件上传客户端代码如下： 123456789101112var file = document.getElementById(&#x27;file&#x27;)// 当用户选择文件的时候 file.onchange = function () &#123; // 创建空表单对象 var formData = new FormData(); // 将用户选择的二进制文件追加到表单对象中,files属性获取到的文件是一个集合,并且默认情况下input文件选择控件只能选择一个文件,索引就为0 formData.append(&#x27;attrName&#x27;, this.files[0]); // 配置ajax对象，请求方式必须为post xhr.open(&#x27;post&#x27;, &#x27;www.example.com&#x27;); xhr.send(formData); &#125; 示例客户端代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;请选择文件&lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 获取文件选择控件 var file = document.getElementById(&#x27;file&#x27;); // 为文件选择控件添加onchanges事件 // 在用户选择文件时触发 file.onchange = function() &#123; // 创建空的formData表单对象 var formData = new FormData(); // 将用户选择的文件追加到formData表单对象中 formData.append(&#x27;attrName&#x27;, this.files[0]); // 创建ajax对象 var xhr = new XMLHttpRequest(); // 对ajax对象进行配置 xhr.open(&#x27;post&#x27;, &#x27;http://localhost:3000/upload&#x27;); // 发送ajax请求 xhr.send(formData); // 监听服务器端响应给客户端的数据 xhr.onload = function() &#123; // 如果服务器端返回的http状态码为200 // 说明请求是成功的 if (xhr.status == 200) &#123; // 将服务器端返回的数据显示在控制台中 console.log(xhr.responseText); &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 服务器端代码如下： 12345678910111213141516171819202122232425262728// 引入express框架const express = require(&#x27;express&#x27;);// 路径处理模块const path = require(&#x27;path&#x27;)const formidable = require(&#x27;formidable&#x27;);// 创建web服务器const app = express();// 静态资源访问服务功能app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));// 实现文件上传的路由app.post(&#x27;/upload&#x27;, (req, res) =&gt; &#123; // 创建formidable表单解析对象 const form = new formidable.IncomingForm(); // 设置客户端上传文件的存储路径 form.uploadDir = path.join(__dirname, &#x27;public&#x27;, &#x27;uploads&#x27;); // 保留上传文件的后缀名字 form.keepExtensions = true; // 解析客户端传递过来的FormData对象 form.parse(req, (err, fields, files) =&gt; &#123; res.send(&#x27;ok&#x27;) &#125;);&#125;);// 监听端口app.listen(3000); FormData文件上传进度展示123456789// 当用户选择文件的时候 file.onchange = function () &#123; // 文件上传过程中持续触发onprogress事件 xhr.upload.onprogress = function (ev) &#123; // 当前上传文件大小/文件总大小 再将结果转换为百分数 // 将结果赋值给进度条的宽度属性 bar.style.width = (ev.loaded / ev.total) * 100 + &#x27;%&#x27;; &#125; &#125; FormData文件上传图片即时预览在我们将图片上传到服务器端以后，服务器端通常都会将图片地址做为响应数据传递到客户端，客户端可以从响应数据中获取图片地址，然后将图片再显示在页面中 12345678xhr.onload = function () &#123; var result = JSON.parse(xhr.responseText); var img = document.createElement(&#x27;img&#x27;); img.src = result.src; img.onload = function () &#123; document.body.appendChild(this); &#125; &#125;","categories":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/categories/AJAX/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"Nodejs基础之包管理工具npm(二)","slug":"Nodejs基础之包管理工具npm(二)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T08:51:13.470Z","comments":true,"path":"2022/04/24/Nodejs基础之包管理工具npm(二)/","link":"","permalink":"http://example.com/2022/04/24/Nodejs%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7npm(%E4%BA%8C)/","excerpt":"","text":"参考视频： Node.js 黑马程序员 Node.js大地老师讲解 包管理工具npm包管理工具npm Node Package Manager，也就是Node包管理器 但是目前已经不仅仅是Node包管理器了，在前端项目中我们也在使用它来管理依赖的包 比如express、koa、react、react-dom、axios、babel、webpack等等 npm管理的包可以在哪里查看、搜索呢？ https://www.npmjs.com/ 这是我们安装相关的npm包的官网 完全符合 CommonJs 规范的包目录一般包含如下这些文件 package.json ：包描述文件 bin：用于存放可执行二进制文件的目录 lib：用于存放 JavaScript 代码的目录 doc：用于存放文档的目录 npm init 生成package.jsonpackage.json 定义了这个项目所需要的各种模块，以及项目的配置信息(比如名称、版本、许可证等元数据) 我们这里以引入并使用 MD5加密包来举例 package.json 的用法 首先在项目根路径下创建 package.json 1npm init 或者 npm init --yse 去 www.npmjs.com 搜索我们 MD5加密包 在我们的根目录下打开 cmd 下载 我们使用 npm install md5 --save 下载，将 md5 写入 package.json 使用 MD5 123456// 加密 123456var md5 = require(&#x27;md5&#x27;);// 实现 md5 加密的功能console.log(md5(&#x27;123456&#x27;)); 这样我们就实现了导模块并使用模块，此时查看我们的package.json 文件 123456789101112131415161718&#123; &quot;name&quot;: &quot;mytest&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;md5&quot;: &quot;^2.3.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &#125; &#125; dependencies -&gt; 配置当前程序所依赖的其他包 devDependencie -&gt; 配置当前程序所依赖的其他包，比如一些工具之类的配置在这里 dependencies 与 devDependencies 之间的区别？ 使用 npm install node_module --save 会自动更新 dependencies 字段值 使用 npm install node_module --save -dev 会自动更新 devDependencies 字段值 package.json package.json 是项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。 锁定包的版本，确保再次下载时不会因为包版本不同而产生问题 加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作 每次创建新项目，记得先 npm init 生成package.json package.json常见属性必须填写的属性：name、version name 是项目的名称 version 是当前项目的版本号 description是描述信息，很多时候是作为项目的基本描述 author是作者相关信息（发布时用到） license是开源协议（发布时用到） private 属性： private属性记录当前的项目是否是私有的 当值为true时，npm是不能发布它的，这是防止私有项目或模块发布出去的方式 main 属性： 设置程序的入口。 scripts 属性： scripts 属性用于配置一些脚本命令，以键值对的形式存在 配置后我们可以通过 npm run 命令的key来执行这个命令 npm start和npm run start的区别是什么? 它们是等价的 对于常用的start、test、stop、restart可以省略掉run直接通过npm start等方式运行 dependencies 属性：项目依赖 dependencies 属性是指定无论开发环境还是生成环境都需要依赖的包 使用npm install 包名命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中 与之对应的是devDependencies devDependencies 属性：开发依赖 一些包在生成环境是不需要的，比如webpack、babel等 这个时候我们会通过npm install webpack --save-dev，将它安装到devDependencies属性中 那么在生成环境如何保证不安装这些包呢？ 生成环境不需要安装时，我们需要通过npm install --production 来安装文件的依赖 版本管理的问题我们会发现安装的依赖版本出现：^2.0.3或~2.0.3，这是什么意思呢？ 我们这里解释一下^和~的区别： ^x.y.z：表示x是保持不变的，y和z永远安装最新的版本 ~x.y.z：表示x和y保持不变的，z永远安装最新的版本 npm install 命令安装npm包分两种情况： 全局安装（global install）： npm install ModuleName -g 项目（局部）安装（local install）： npm install 全局安装： 全局安装是直接将某个包安装到全局 但是很多人对全局安装有一些误会： 通常使用npm全局安装的包都是一些工具包：yarn、webpack等 并不是类似于axios、express、koa等库文件 所以全局安装了之后并不能让我们在所有的项目中使用axios等库 npm -v 查看 npm 版本 使用 npm 命令安装模块 npm install ModuleName 我们推荐安装模块后面加上 --save，这样可以安装模块并把模块写入 package.json 12// 如安装 jq 模块npm install jquery --save 卸载模块 npm uninstall moduleName 查看当前目录下已安装的 node 包 npm list 查看 模块 的版本 npm info 模块 12// 如查看 jquery 的版本npm info 模块 指定版本安装 npm install jquery@1.8.0 --save 🔥 项目安装项目安装会在当前目录下生产一个node_modules 文件夹 局部安装分为开发时依赖和生产时依赖 npm install 原理执行npm install它背后帮助我们完成了什么操作？ 我们会发现还有一个成为package-lock.json的文件，它的作用是什么？ 从npm5开始，npm支持缓存策略（来自yarn的压力），缓存有什么作用呢？ npm install会检测是有package-lock.json文件： 没有lock文件 分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产生相同依赖的情况 从registry仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包） 获取到压缩包后会对压缩包进行缓存（从npm5开始有的） 将压缩包解压到项目的node_modules文件夹中 有lock文件 检测lock中包的版本是否和package.json中一致 不一致，那么会重新构建依赖关系，直接会走顶层的流程 一致的情况下，会去优先查找缓存 没有找到，会从registry仓库下载，直接走顶层流程 查找到，会获取缓存中的压缩文件，并且将压缩文件解压到node_modules文件夹中 package-lock.jsonpackage-lock.json文件解析： name：项目的名称 version：项目的版本 lockfileVersion：lock文件的版本 requires：使用requires来跟着模块的依赖关系 dependencies：项目的依赖 npm其他命令卸载某个依赖包： npm uninstall package npm uninstall package –save-dev npm uninstall package -D 强制重新build npm rebuild 清除缓存 npm cache clean cnpm工具查看npm镜像 1npm config get registry 我们可以直接设置npm的淘宝镜像 1npm config set registry https://registry.npm.taobao.org 但是对于大多数人来说），并不希望将npm镜像修改了 第一，不太希望随意修改npm原本从官方下来包的渠道 第二，担心某天淘宝的镜像挂了或者不维护了，又要改来改去 这个时候，我们可以使用cnpm，并且将cnpm设置为淘宝的镜像 1npm install -g cnpm --registry=https://registry.npm.taobao.org 查看cnpm镜像 1cnpm config get registry","categories":[{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"模块化开发","slug":"模块化开发","permalink":"http://example.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"Express框架","slug":"Express框架","permalink":"http://example.com/tags/Express%E6%A1%86%E6%9E%B6/"}]},{"title":"Nodejs基础之Express框架和art-template引擎(四)","slug":"Nodejs基础之Express框架和art-template引擎(四)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T09:58:57.116Z","comments":true,"path":"2022/04/24/Nodejs基础之Express框架和art-template引擎(四)/","link":"","permalink":"http://example.com/2022/04/24/Nodejs%E5%9F%BA%E7%A1%80%E4%B9%8BExpress%E6%A1%86%E6%9E%B6%E5%92%8Cart-template%E5%BC%95%E6%93%8E(%E5%9B%9B)/","excerpt":"","text":"目录脑图 参考视频： Node.js 黑马程序员 Node.js大地老师讲解 Express框架Express 是一个基于Node.js 平台，快速、开放、极简的web 开发框架，它提供一系列强大的特性，帮助你创建各种Web 和移动设备应用。 英文官网：http://expressjs.com/ 中文官网：https://www.expressjs.com.cn/ Express安装 安装 Expresss 框架，就是使用 npm 的命令 1npm install express --save –save 参数，表示自动修改 package.json 文件，自动添加依赖项目 Express简单使用app.get123456789101112131415161718192021222324// 引入 express 框架const express = require(&#x27;express&#x27;);// 实例化 express 赋值给 appconst app = new express();// 配置路由,匹配URI地址实现不同的功能// app.get 主要用来显示数据app.get(&#x27;/&#x27;, function(req, res) &#123; res.send(&quot;Hello World!&quot;);&#125;)app.get(&#x27;/article&#x27;, function(req, res) &#123; res.send(&quot;新闻页面&quot;);&#125;)app.get(&#x27;/login&#x27;, function(req, res) &#123; res.send(&quot;登录页面&quot;);&#125;)app.get(&#x27;/register&#x27;, function(req, res) &#123; res.send(&quot;注册页面&quot;);&#125;)/// 监听端口app.listen(3000); app.post12345678910111213// 引入 express 框架const express = require(&#x27;express&#x27;);// 实例化 express 赋值给 appconst app = new express();// 配置路由,匹配URI地址实现不同的功能// app.post 主要用于增加数据app.post(&#x27;/doLogin&#x27;, (req, res) =&gt; &#123; res.send(&quot;执行登录&quot;);&#125;)/// 监听端口app.listen(3000); app.put12345678910111213// 引入 express 框架const express = require(&#x27;express&#x27;);// 实例化 express 赋值给 appconst app = new express();// 配置路由,匹配URI地址实现不同的功能// app.put 主要用于修改数据app.put(&#x27;/editUser&#x27;, (req, res) =&gt; &#123; res.send(&quot;修改用户&quot;);&#125;)/// 监听端口app.listen(3000); app.delete12345678910111213// 引入 express 框架const express = require(&#x27;express&#x27;);// 实例化 express 赋值给 appconst app = new express();// 配置路由,匹配URI地址实现不同的功能// app.delete 主要用于删除数据app.delete(&#x27;/deleteUser&#x27;, (req, res) =&gt; &#123; res.send(&quot;删除用户&quot;);&#125;)/// 监听端口app.listen(3000); 路由配置多级目录12345678910111213// 引入 express 框架const express = require(&#x27;express&#x27;);// 实例化 express 赋值给 appconst app = new express();// 配置路由,匹配URI地址实现不同的功能// 路由里面配置多级目录 http://localhost:3000/admin/user/editapp.get(&quot;/admin/user/add&quot;, (req, res) =&gt; &#123; res.send(&quot;admin user add&quot;)&#125;)/// 监听端口app.listen(3000); 动态路由123456789101112131415161718192021// 引入 express 框架const express = require(&#x27;express&#x27;);// 实例化 express 赋值给 appconst app = new express();// 配置路由,匹配URI地址实现不同的功能// app.get 主要用来显示数据app.get(&#x27;/article&#x27;, function(req, res) &#123; res.send(&quot;新闻页面&quot;);&#125;)//动态路由 配置路由的时候也要注意顺序app.get(&quot;/article/:id&quot;, (req, res) =&gt; &#123; var id = req.params[&quot;id&quot;]; //获取动态路由 res.send(&quot;动态路由&quot; + id);&#125;)app.get(&quot;/article/add&quot;, (req, res) =&gt; &#123; res.send(&quot;article add&quot;);&#125;)/// 监听端口app.listen(3000); GET传值1234567891011121314151617// 引入 express 框架const express = require(&#x27;express&#x27;);// 实例化 express 赋值给 appconst app = new express();// 配置路由,匹配URI地址实现不同的功能//get 传值 http://localhost:3000/product?name=zhangsan&amp;age=20app.get(&quot;/product&quot;, (req, res) =&gt; &#123; let query = req.query; //获取get传值 console.log(query); console.log(&quot;name:&quot; + query.name); console.log(&quot;age:&quot; + query.age); res.send(&quot;name:&quot; + query.name + &quot;age:&quot; + query.age);&#125;)/// 监听端口app.listen(3000); Express框架中EJS的使用EJS 是后台模板，可以把我们数据库和文件读取的数据显示到 HTML页面上面。它是一个第三方模块，需要通过 npm 安装。Express 框架里面集成了 EJS 模板引擎，所以我们来看下两者结合的使用。 安装 1npm install ejs --save 配置ejs app.set(&quot;view engine&quot;,&quot;ejs) 使用ejs（默认加载模板引擎的文件夹是views，所以 index 前面不需要加 views） 123res.render(&quot;index&quot;,&#123;&#125;) 例如： 12345678910111213141516const express = require(&quot;express&quot;);const app = express()//配置模板引擎app.set(&quot;view engine&quot;,&quot;ejs&quot;)// 访问127.0.0.1:3000/ 渲染的是index模板app.get(&quot;/&quot;,(req,res)=&gt;&#123; res.render(&quot;index&quot;,&#123; &#125;)&#125;)//监听端口 端口号建议写成3000以上app.listen(3000); 之后我们在 views 文件夹下新建 index.ejs 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;我是一个ejs模板引擎&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;1234567891011 EJS常用标签绑定数据例如： 12345678910111213141516const express = require(&quot;express&quot;);const app = express()//配置模板引擎app.set(&quot;view engine&quot;,&quot;ejs&quot;)// 访问127.0.0.1:3000/ 渲染的是index模板app.get(&quot;/&quot;,(req,res)=&gt;&#123; let title = &quot;你好ejs&quot;; // 假如这个数据是从数据库获取到的 res.render(&quot;index&quot;,&#123; title: title, // 这样就绑定到 index.ejs 模板里面了 &#125;)&#125;)//监听端口 端口号建议写成3000以上app.listen(3000); 接下来我们去 index.ejs 里面输出这个数据 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;我是一个ejs模板引擎&lt;/h2&gt; &lt;p&gt;&lt;%=title%&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 绑定对象我们也可以绑定对象中的数据并将其渲染到 html 页面。 例如： 123456789101112131415const express = require(&quot;express&quot;);const app = express()//配置模板引擎app.set(&quot;view engine&quot;, &quot;ejs&quot;)app.get(&quot;/news&quot;, (req, res) =&gt; &#123; let userinfo = &#123; username: &quot;张三&quot;, age: 20 &#125;; res.render(&quot;news&quot;, &#123; userinfo: userinfo, // 绑定 userinfo 对象数据 &#125;)&#125;)app.listen(3000); 接下来我们去 views 文件夹下新建 news.ejs 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;绑定对象中的数据&lt;/h2&gt; &lt;p&gt; &lt;%=userinfo.username%&gt;---&lt;%=userinfo.age%&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 输出 HTML标签我们也可以输出 HTML标签，既可以原格式输出，又可以解析 HTML 标签输出。 1234567891011121314151617181920212223const express = require(&quot;express&quot;);const app = express() //配置模板引擎app.set(&quot;view engine&quot;, &quot;ejs&quot;)app.get(&quot;/news&quot;, (req, res) =&gt; &#123; let article = &quot;&lt;h3&gt;我是一个h3&lt;/h3&gt;&quot; res.render(&quot;news&quot;, &#123; article: article, &#125;)&#125;)app.listen(3000); &lt;body&gt; &lt;p&gt; &lt;%=article%&gt; &lt;!-- 原格式输出 --&gt; &lt;/p&gt; &lt;p&gt; &lt;%-article%&gt; &lt;!-- 解析html标签输出 --&gt; &lt;/p&gt;&lt;/body&gt; 条件判断12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*1、安装 cnpm install ejs --save2、app.set(&quot;view engine&quot;,&quot;ejs&quot;)3、使用 (默认加载模板引擎的文件夹是views) res.render(&quot;index&quot;,&#123; &#125;)*/const express = require(&quot;express&quot;);const app = express()//配置模板引擎app.set(&quot;view engine&quot;,&quot;ejs&quot;)app.get(&quot;/&quot;,(req,res)=&gt;&#123; let title = &quot;你好ejs&quot;; res.render(&quot;index&quot;,&#123; title:title &#125;)&#125;)app.get(&quot;/news&quot;,(req,res)=&gt;&#123; res.render(&quot;news&quot;,&#123; flag:true, score:60, &#125;)&#125;)//监听端口 端口号建议写成3000以上app.listen(3000) &lt;h2&gt;条件判断&lt;/h2&gt;&lt;%if(flag==true)&#123;%&gt; &lt;strong&gt;flag=true&lt;/strong&gt;&lt;%&#125;%&gt;&lt;%if(score&gt;=60)&#123;%&gt; &lt;p&gt;及格&lt;/p&gt;&lt;%&#125;else&#123;%&gt; 不及格&lt;%&#125;%&gt; 循环遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*1、安装 cnpm install ejs --save2、app.set(&quot;view engine&quot;,&quot;ejs&quot;)3、使用 (默认加载模板引擎的文件夹是views) res.render(&quot;index&quot;,&#123; &#125;)*/const express = require(&quot;express&quot;);const app = express() //配置模板引擎app.set(&quot;view engine&quot;, &quot;ejs&quot;)app.get(&quot;/&quot;, (req, res) =&gt; &#123; let title = &quot;你好ejs&quot;; res.render(&quot;index&quot;, &#123; title: title &#125;)&#125;)app.get(&quot;/news&quot;, (req, res) =&gt; &#123; let list = [&quot;1111&quot;, &quot;22222&quot;, &quot;3333333&quot;] let newsList = [&#123; title: &quot;新闻1111&quot;, &#125;, &#123; title: &quot;新闻122222&quot;, &#125;, &#123; title: &quot;新闻33331&quot;, &#125;, &#123; title: &quot;新闻44444&quot;, &#125; ] res.render(&quot;news&quot;, &#123; list: list, newsList: newsList &#125;)&#125;)//监听端口 端口号建议写成3000以上app.listen(3000) &lt;body&gt; &lt;h2&gt;循环遍历&lt;/h2&gt; &lt;ul&gt; &lt;%for(let i=0;i&lt;list.length;i++)&#123;%&gt; &lt;li&gt; &lt;%=list[i]%&gt; &lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt; &lt;br&gt; &lt;ul&gt; &lt;%for(let i=0;i&lt;newsList.length;i++)&#123;%&gt; &lt;li&gt; &lt;%=newsList[i].title%&gt; &lt;/li&gt; &lt;%&#125;%&gt; &lt;/ul&gt;&lt;/body&gt; 引入模板1&lt;%- include(&#x27;footer.ejs&#x27;) %&gt; ejs后缀修改为html这是一个小技巧，看着.ejs 的后缀总觉得不爽，使用如下方法，可以将模板文件的后缀换成我们习惯的.html。 在 app.js 的头上定义ejs 1var ejs = require(&#x27;ejs&#x27;); 注册html 模板引擎代码如下 1app.engine(&#x27;html&#x27;,ejs__express) 将模板引擎转换成 html 代码如下 1app.set(&#x27;view engine&#x27;,&#x27;html&#x27;)==== 修改模板文件的后缀为 .html 即可 Express.static托管静态文件我们的静态资源 img、css 等要如何引入呢？ 调用 express.static 中间件 1app.use(express.static(&#x27;static&#x27;)) 现在，static 目录下面的文件就可以访问了 在 ejs 里面正常引入css 即可 Express中间件通俗的讲：中间件就是匹配路由之前或者匹配路由完成做的一系列的操作。中间件如果想往下匹配的话，那么需要写 next() 中间件可以用来做权限判断：没有登录 跳转到登录页面，登录以后就显示登录以后的页面 如果我的get、post 回调函数中，没有next 参数，那么就匹配上第一个路由，，就不会往下匹配了。如果想往下匹配的话，那么需要写 next() Express 应用可使用如下几种中间件 应用级中间件 路由级中间件（用的少） 错误处理中间件 内置中间件 第三方中间件 应用级中间件123456789101112131415161718const express = require(&quot;express&quot;);const app = express()//1、应用级中间件 (用于权限判断)app.use((req,res,next)=&gt;&#123; // 匹配任何路由 console.log(new Date()); next(); // 表示匹配完成这个中间件之后程序继续向下执行&#125;)app.get(&quot;/&quot;,(req,res)=&gt;&#123; res.send(&quot;首页&quot;)&#125;)app.get(&quot;/login&quot;,(req,res)=&gt;&#123; res.send(&quot;执行登录&quot;)&#125;)app.listen(3000); 路由中间件123456789101112131415const express = require(&quot;express&quot;);const app = express()//2、路由级中间件(用的比较少)app.get(&quot;/news/add&quot;,(req,res,next)=&gt;&#123; // res.send(&quot;执行增加新闻&quot;) console.log(&quot;执行增加新闻&quot;) next()&#125;)app.get(&quot;/news/:id&quot;,(req,res)=&gt;&#123; res.send(&quot;新闻动态路由&quot;)&#125;)app.listen(3000); 错误处理中间件123456789const express = require(&quot;express&quot;);const app = express()//3、错误处理中间件 app.use((req,res,next)=&gt;&#123; res.status(404).send(&quot;404&quot;)&#125;)app.listen(3000); 内置中间件12// 内置服务app.use(&#x27;/static&#x27;,express.static(&#x27;./static&#x27;)) 内置中间件一般用于 css、img 等静态资源的加载访问。 第三方中间件获取GET请求参数 GET 请求的参数在 URL 中，在原生 Node中，需要使用 url 模块来识别参数字符串。在 Express 中，不需要使用 url模块了，可以直接使用 req.query 对象 123456789101112131415const express = require(&quot;express&quot;);const app = express()app.get(&quot;/&quot;, (req, res) =&gt; &#123; // http://127.0.0.1:3000/?name=zhangsan&amp;age=20 let query = req.query; console.log(query); console.log(query.name); console.log(query.age); res.send(req.query);&#125;)app.listen(3000); 获取POST请求参数获取 POST 请求参数需要加载第三方中间件 body-parser 首先下载 body-parse 1npm install body-parser --save 引入中间件 1var bodyParser = require(&#x27;body-parser&#x27;) 配置中间件 123app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json()) 接收 post 数据 1req.body 1234567891011121314151617const express = require(&quot;express&quot;);const bodyParser = require(&#x27;body-parser&#x27;)const app = express()//配置第三方中间件app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json())app.post(&quot;/doLogin&quot;, (req, res) =&gt; &#123; // req.body 获取post传值 var body = req.body; res.send(body);&#125;)//监听端口 端口号建议写成3000以上app.listen(3000) Express CookieCookie简介 cookie 是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一个域名的时候共享数据。 HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何关系的。 Cookie 是一个简单到爆的想法：当访问一个页面的时候，服务器在下行HTTP 报文中，命令浏览器存储一个字符串; 浏览器再访问同一个域的时候，将把这个字符串携带到上行HTTP 请求中。第一次访问一个服务器，不可能携带cookie。必须是服务器得到这次请求，在下行响应报头中，携带cookie 信息，此后每一次浏览器往这个服务器发出的请求，都会携带这个cookie。 Cookie的特点 cookie 保存在浏览器本地 正常设置的cookie 是不加密的，用户可以自由看到 用户可以删除cookie，或者禁用它 cookie 可以被篡改 cookie 可以用于攻击 cookie 存储量很小。未来实际上要被localStorage 替代，但是后者IE9 兼容。 Cookie的使用Express 中要使用Cookie 的话，我们需要使用 cookie-parser 模块来实现 安装 1npm install cookie-parser --save 引入 1var cookieParser = require(&#x27;cookie-parser&#x27;) 设置中间件 1app.use(cookieParser()) 设置 cookie 1res.cookie(&quot;username&quot;,&quot;zhangsan&quot;,&#123;maxAge:1000*60*60&#125;) 获取 cookie 1req.cookies.username 12345678910111213141516171819202122232425262728const express = require(&#x27;express&#x27;)const cookieParser = require(&#x27;cookie-parser&#x27;)const app=express()//配置cookieParser中间件app.use(cookieParser())app.get(&quot;/&quot;,(req,res)=&gt;&#123; // 设置cookie 如果cookie没有过期的话，关闭浏览器后重新打开,cookie不会销毁 res.cookie(&quot;username&quot;,&quot;zhangsan&quot;,&#123;maxAge:1000*60*60&#125;); res.send(&quot;你好 Cookie&quot;);&#125;)app.get(&quot;/article&quot;,(req,res)=&gt;&#123; //获取cookie let username=req.cookies.username; res.send(&quot;新闻页面--&quot;+username)&#125;)app.get(&quot;/user&quot;,(req,res)=&gt;&#123; //获取cookie let username=req.cookies.username; res.send(&quot;用户--&quot;+username);&#125;)app.listen(3000); 设置Cookie 获取Cookie Cookie属性说明 属性 描述 domain🔥 域名 name = value:，是键值对，可以设置要保存 key/Value，注意这里的 name 不能和其他属性项的名字一样 Expires 过期时间（ 秒） ， 在设置的某个时间点后该Cookie 就会失效， 如 expires=Wednesday, 09-Nov-99 23:12:40 GMT maxAge 最大失效时间（毫秒），设置在多少后失效 secure 当secure 值为true 时，cookie 在HTTP 中是无效，在HTTPS 中才有效 Path🔥 表示cookie 影响到的路径，如path=/。如果路径不能匹配时，浏览器则不发送这个Cookie httpOnly 是微软对COOKIE 做的扩展。如果在COOKIE 中设置了“httpOnly”属性，则通过程序（JS 脚本、applet 等）将无法读取到COOKIE 信息，防止XSS 攻击产生 singed 表示是否签名cookie, 设为true 会对这个cookie 签名， 这样就需要用res.signedCookies 而不是res.cookies 访问它。被篡改的签名cookie 会被服务器拒绝，并且cookie 值会重置为它的原始值 多个域名共享 cookie：aaa.itying.com bbb.itying.com 下的二级域名都可以访问这个 cookie 12// 多个域名共享cookie aaa.itying.com bbb.itying.com res.cookie(&quot;username&quot;,&quot;zhangsan1111&quot;,&#123;maxAge:1000*60*60,domain:&quot;.itying.com&quot;&#125;) 中文 cookie 1res.cookie(&quot;username&quot;,&quot;张三&quot;,&#123;maxAge:1000*60*60&#125;) 设置只有 /article 路由可以访问这个cookie 1res.cookie(&quot;username&quot;,&quot;zhangsan&quot;,&#123;maxAge:1000*60*60,path:&quot;/article&quot;&#125;) Cookie的加密 配置中间件的时候需要传入加密的参数 1app.use(cookieParser(&quot;itying&quot;)) 设置加密 Cookie 1res.cookie(&quot;username&quot;,&quot;zhangsan&quot;,&#123;maxAge:1000*60*60,signed:true&#125;) 获取加密的cookie 1req.signedCookies Express SessionSession简介 session 是另一种记录客户状态的机制，不同的是Cookie 保存在客户端浏览器中，而session 保存在服务器上。 Cookie 数据存放在客户的浏览器上，Session 数据放在服务器上。Session 相比Cookie 要更安全一些 由于Session 保存到服务器上，所以当访问量增多的时候，会比较占用服务器的性能。 单个cookie 保存的数据大小不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。Session 没有这方面的限制。Session 是基于Cookie 进行工作的。 Session的工作流程当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session 对象，生成一个类似于key,value 的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应 的session(value)。 express-session 安装 1npm install express-session --save 引入 1var session = require(&#x27;express-session&#x27;) 设置官方文档提供的中间件 123456app.use(session(&#123; secret: &#x27;keyboard cat&#x27;, resave: false, saveUninitialized: true, cookie: &#123; secure: true &#125;&#125;)) 使用 1234// 设置值req.session.username = &quot;张三&quot;// 获取值req.session.username express-session的常用参数123456app.use(session(&#123; secret: &#x27;keyboard cat&#x27;, resave: false, saveUninitialized: true, cookie: &#123; secure: true &#125;&#125;)) 参数 作用 secret 一个String 类型的字符串，作为服务器端生成session 的签名 name 返回客户端的key 的名称，默认为connect.sid,也可以自己设置。 resave 强制保存session 即使它并没有变化, 。默认为false 。don’t save session if unmodified saveUninitialized 强制将未初始化的session 存储。当新建了一个session 且未设定属性或值时，它就处于未初始化状态。在设定一个cookie 前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true）。建议手动添加。 cookie 设置返回到前端key 的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false,maxAge: null }。 rolling 在每次请求时强行设置cookie，这将重置cookie 过期时间（默认：false） 1234567891011121314151617181920212223242526272829303132333435const express = require(&#x27;express&#x27;)const session = require(&#x27;express-session&#x27;)const app = express()//配置session的中间件app.use(session(&#123; secret: &#x27;this is session&#x27;, //服务器端生成 session 的签名 name: &quot;itying&quot;, //修改session对应cookie的名称 resave: false, //强制保存 session 即使它并没有变化 saveUninitialized: true, //强制将未初始化的 session 存储 cookie: &#123; maxAge: 1000 * 60 * 30, secure: false // true 表示只有https协议才能访问cookie &#125;, rolling: true //在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false）&#125;))app.get(&quot;/&quot;, (req, res) =&gt; &#123; //获取seesion if (req.session.username || req.session.age) &#123; res.send(req.session.username + &quot;--&quot; + req.session.age + &quot;-已登录&quot;) &#125; else &#123; res.send(&quot;没有登录&quot;) &#125;&#125;)app.get(&quot;/login&quot;, (req, res) =&gt; &#123; //设置seesion req.session.username = &quot;张三&quot;; req.session.age = 20; res.send(&quot;执行登录&quot;);&#125;)app.listen(3000) express-session的常用方法 设置session的过期时间为 0(它会把所有的session都销毁) 1req.session.cookie.maxAge=0 销毁指定session 1req.session.username=&quot;&quot; 销毁session 1req.session.destroy() 12345678910111213app.get(&quot;/loginOut&quot;,(req,res)=&gt;&#123; //1、设置session的过期时间为0 (它会把所有的session都销毁) // req.session.cookie.maxAge=0 //2、销毁指定session // req.session.username=&quot;&quot; //3、销毁session destroy req.session.destroy(); res.send(&quot;退出登录&quot;)&#125;) art-template模板模板引擎是第三方模块,art-template模板引擎官方网址：https://aui.github.io/art-template/zh-cn/index.html 下载 1npm install art-template --save 引入 1const template = require(&#x27;art-template&#x27;); 告诉模板引擎要拼接的数据和模板在哪 1const html = template(‘模板路径’, 数据); 使用 示例12345678910111213141516// 导入模板引擎const template = require(&#x27;art-template&#x27;);const path = require(&#x27;path&#x27;);const views = path.join(__dirname, &#x27;views&#x27;, &#x27;index.art&#x27;);// template方法是用来拼接字符串的// 1. 模板路径 绝对路径// 2. 要在模板中显示的数据 对象类型// 返回拼接好的字符串const html = template(views, &#123; name: &#x27;张三&#x27;, age: 20&#125;)console.log(html); 用模板引擎在 index.art 中接收 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;&#123; name &#125;&#125; &#123;&#123; age &#125;&#125;&lt;/body&gt;&lt;/html&gt; 模板语法 art-template同时支持两种模板语法：标准语法和原始语法 标准语法可以让模板更容易读写，原始语法具有强大的逻辑处理能力 输出 （省略，此处省略了部分知识…..）原文输出例如我们在 app.js 中放入数据： 1234567891011121314151617// 导入模板引擎const template = require(&#x27;art-template&#x27;);const path = require(&#x27;path&#x27;);const views = path.join(__dirname, &#x27;views&#x27;, &#x27;index.art&#x27;);// template方法是用来拼接字符串的// 1. 模板路径 绝对路径// 2. 要在模板中显示的数据 对象类型// 返回拼接好的字符串const html = template(views, &#123; name: &#x27;张三&#x27;, age: 20, content: &#x27;&lt;h1&gt;我是标题&lt;/h1&gt;&#x27;&#125;)console.log(html); 使用模板语法在 index.art 中接收 1234567891011121314&lt;body&gt; &lt;!-- 标准语法 --&gt; &lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; 1 + 1 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; 1 + 1 == 2 ? &#x27;相等&#x27; : &#x27;不相等&#x27; &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;@ content &#125;&#125;&lt;/p&gt; &lt;!-- 原始语法 --&gt; &lt;p&gt;&lt;%= name %&gt;&lt;/p&gt; &lt;p&gt;&lt;%= 1 + 2%&gt;&lt;/p&gt; &lt;p&gt;&lt;%= 1 + 1 == 2 ? &#x27;相等&#x27; : &#x27;不相等&#x27; %&gt;&lt;/p&gt; &lt;p&gt;&lt;%= content%&gt;&lt;/p&gt; &lt;p&gt;&lt;%- content%&gt;&lt;/p&gt;&lt;/body&gt; 条件判断1&lt;!-- 标准语法 --&gt; 123456789101112131415161718192021例如：```html&lt;!-- 标准语法 --&gt; &#123;&#123;if age &gt; 18&#125;&#125; 年龄大于18&#123;&#123;else if age &lt; 15 &#125;&#125; 年龄小于15&#123;&#123;else&#125;&#125; 年龄不符合要求&#123;&#123;/if&#125;&#125;&lt;!-- 标准语法 --&gt; &lt;% if (age &gt; 18) &#123; %&gt; 年龄大于18&lt;% &#125; else if (age &lt; 15) &#123; %&gt; 年龄小于15&lt;% &#125; else &#123; %&gt; 年龄不符合要求&lt;% &#125; %&gt; 循环 标准语法：&#123;&#123;each 数据&#125;&#125;&#123;&#123;/each&#125;&#125; 原始语法：&lt;% for() &#123;%>","categories":[{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"模块化开发","slug":"模块化开发","permalink":"http://example.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"Express框架","slug":"Express框架","permalink":"http://example.com/tags/Express%E6%A1%86%E6%9E%B6/"}]},{"title":"Vue cli笔记","slug":"vue cli笔记","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T10:30:53.304Z","comments":true,"path":"2022/04/24/vue cli笔记/","link":"","permalink":"http://example.com/2022/04/24/vue%20cli%E7%AC%94%E8%AE%B0/","excerpt":"","text":"脚手架文件结构├── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.png │ │── component: 存放组件 │ │ └── HelloWorld.vue │ │── App.vue: 汇总所有组件 │ │── main.js: 入口文件 ├── .gitignore: git版本管制忽略的配置 ├── babel.config.js: babel的配置文件 ├── package.json: 应用包配置文件 ├── README.md: 应用描述文件 ├── package-lock.json：包版本控制文件 关于不同版本的Vue vue.js与vue.runtime.xxx.js的区别： vue.js是完整版的Vue，包含：核心功能 + 模板解析器。 vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。 vue.config.js配置文件 使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。 使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh ref属性 被用来给元素或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc） 使用方式： 打标识：&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt; 或 &lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt; 获取：this.$refs.xxx props配置项 功能：让组件接收外部传过来的数据 传递数据：&lt;Demo name=&quot;xxx&quot;/&gt; 接收数据： 第一种方式（只接收）：props:[&#39;name&#39;] 第二种方式（限制类型）：props:&#123;name:String&#125; 第三种方式（限制类型、限制必要性、指定默认值）： 1234567props:&#123; name:&#123; type:String, //类型 required:true, //必要性 default:&#x27;老王&#x27; //默认值 &#125;&#125; 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。 mixin(混入) 功能：可以把多个组件共用的配置提取成一个混入对象 使用方式： 第一步定义混合： 12345&#123; data()&#123;....&#125;, methods:&#123;....&#125; ....&#125; 第二步使用混入： ​ 全局混入：Vue.mixin(xxx) ​ 局部混入：mixins:[&#39;xxx&#39;] 插件 功能：用于增强Vue 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。 定义插件： 1234567891011121314对象.install = function (Vue, options) &#123; // 1. 添加全局过滤器 Vue.filter(....) // 2. 添加全局指令 Vue.directive(....) // 3. 配置全局混入(合) Vue.mixin(....) // 4. 添加实例方法 Vue.prototype.$myMethod = function () &#123;...&#125; Vue.prototype.$myProperty = xxxx&#125; 使用插件：Vue.use() scoped样式 作用：让样式在局部生效，防止冲突。 写法：&lt;style scoped&gt; 总结TodoList案例 组件化编码流程： ​ (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。 ​ (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用： ​ 1).一个组件在用：放在组件自身即可。 ​ 2). 一些组件在用：放在他们共同的父组件上（状态提升）。 ​ (3).实现交互：从绑定事件开始。 props适用于： ​ (1).父组件 ==&gt; 子组件 通信 ​ (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数） 使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！ props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。 webStorage 存储内容大小一般支持5MB左右（不同浏览器可能还不一样） 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。 相关API： xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。 xxxxxStorage.getItem(&#39;person&#39;); ​ 该方法接受一个键名作为参数，返回键名对应的值。 xxxxxStorage.removeItem(&#39;key&#39;); ​ 该方法接受一个键名作为参数，并把该键名从存储中删除。 xxxxxStorage.clear() ​ 该方法会清空存储中的所有数据。 备注： SessionStorage存储的内容会随着浏览器窗口关闭而消失。 LocalStorage存储的内容，需要手动清除才会消失。 xxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null。 JSON.parse(null)的结果依然是null。 组件的自定义事件 一种组件间通信的方式，适用于：子组件 ===&gt; 父组件 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。 绑定自定义事件： 第一种方式，在父组件中：&lt;Demo @atguigu=&quot;test&quot;/&gt; 或 &lt;Demo v-on:atguigu=&quot;test&quot;/&gt; 第二种方式，在父组件中： 12345&lt;Demo ref=&quot;demo&quot;/&gt;......mounted()&#123; this.$refs.xxx.$on(&#x27;atguigu&#x27;,this.test)&#125; 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。 触发自定义事件：this.$emit(&#39;atguigu&#39;,数据) 解绑自定义事件this.$off(&#39;atguigu&#39;) 组件上也可以绑定原生DOM事件，需要使用native修饰符。 注意：通过this.$refs.xxx.$on(&#39;atguigu&#39;,回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！ 全局事件总线（GlobalEventBus） 一种组件间通信的方式，适用于任意组件间通信。 安装全局事件总线： 1234567new Vue(&#123; ...... beforeCreate() &#123; Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm &#125;, ......&#125;) 使用事件总线： 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。 1234567methods()&#123; demo(data)&#123;......&#125;&#125;......mounted() &#123; this.$bus.$on(&#x27;xxxx&#x27;,this.demo)&#125; 提供数据：this.$bus.$emit(&#39;xxxx&#39;,数据) 最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。 消息订阅与发布（pubsub） 一种组件间通信的方式，适用于任意组件间通信。 使用步骤： 安装pubsub：npm i pubsub-js 引入: import pubsub from &#39;pubsub-js&#39; 接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。 1234567methods()&#123; demo(data)&#123;......&#125;&#125;......mounted() &#123; this.pid = pubsub.subscribe(&#x27;xxx&#x27;,this.demo) //订阅消息&#125; 提供数据：pubsub.publish(&#39;xxx&#39;,数据) 最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅。 nextTick 语法：this.$nextTick(回调函数) 作用：在下一次 DOM 更新结束后执行其指定的回调。 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。 Vue封装的过度与动画 作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。 图示： 写法： 准备好样式： 元素进入的样式： v-enter：进入的起点 v-enter-active：进入过程中 v-enter-to：进入的终点 元素离开的样式： v-leave：离开的起点 v-leave-active：离开过程中 v-leave-to：离开的终点 使用&lt;transition&gt;包裹要过度的元素，并配置name属性： 123&lt;transition name=&quot;hello&quot;&gt; &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;&lt;/transition&gt; 备注：若有多个元素需要过度，则需要使用：&lt;transition-group&gt;，且每个元素都要指定key值。 vue脚手架配置代理方法一​ 在vue.config.js中添加如下配置： 123devServer:&#123; proxy:&quot;http://localhost:5000&quot;&#125; 说明： 优点：配置简单，请求资源时直接发给前端（8080）即可。 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源） 方法二​ 编写vue.config.js配置具体代理规则： 123456789101112131415161718192021module.exports = &#123; devServer: &#123; proxy: &#123; &#x27;/api1&#x27;: &#123;// 匹配所有以 &#x27;/api1&#x27;开头的请求路径 target: &#x27;http://localhost:5000&#x27;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: &#123;&#x27;^/api1&#x27;: &#x27;&#x27;&#125; &#125;, &#x27;/api2&#x27;: &#123;// 匹配所有以 &#x27;/api2&#x27;开头的请求路径 target: &#x27;http://localhost:5001&#x27;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125; &#125; &#125; &#125;&#125;/* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080 changeOrigin默认值为true*/ 说明： 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。 缺点：配置略微繁琐，请求资源时必须加前缀。 插槽 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 ===&gt; 子组件 。 分类：默认插槽、具名插槽、作用域插槽 使用方式： 默认插槽： 1234567891011父组件中： &lt;Category&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/Category&gt;子组件中： &lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 具名插槽： 123456789101112131415161718父组件中： &lt;Category&gt; &lt;template slot=&quot;center&quot;&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt;html结构2&lt;/div&gt; &lt;/template&gt; &lt;/Category&gt;子组件中： &lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 作用域插槽： 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定） 具体编码： 1234567891011121314151617181920212223242526272829303132333435父组件中： &lt;Category&gt; &lt;template scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是ul列表 --&gt; &lt;ul&gt; &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/Category&gt; &lt;Category&gt; &lt;template slot-scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是h4标题 --&gt; &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt; &lt;/template&gt; &lt;/Category&gt;子组件中： &lt;template&gt; &lt;div&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;], //数据在子组件自身 data() &#123; return &#123; games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;] &#125; &#125;, &#125; &lt;/script&gt; 1 Vuex1.概念​ 在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。 2.何时使用？​ 多个组件需要共享数据时 3.搭建vuex环境 创建文件：src/store/index.js 1234567891011121314151617181920//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//应用Vuex插件Vue.use(Vuex)//准备actions对象——响应组件中用户的动作const actions = &#123;&#125;//准备mutations对象——修改state中的数据const mutations = &#123;&#125;//准备state对象——保存具体的数据const state = &#123;&#125;//创建并暴露storeexport default new Vuex.Store(&#123; actions, mutations, state&#125;) 在main.js中创建vm时传入store配置项 1234567891011......//引入storeimport store from &#x27;./store&#x27;......//创建vmnew Vue(&#123; el:&#x27;#app&#x27;, render: h =&gt; h(App), store&#125;) 4.基本使用 初始化数据、配置actions、配置mutations，操作文件store.js 12345678910111213141516171819202122232425262728293031323334//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//引用VuexVue.use(Vuex)const actions = &#123; //响应组件中加的动作 jia(context,value)&#123; // console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value) context.commit(&#x27;JIA&#x27;,value) &#125;,&#125;const mutations = &#123; //执行加 JIA(state,value)&#123; // console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value) state.sum += value &#125;&#125;//初始化数据const state = &#123; sum:0&#125;//创建并暴露storeexport default new Vuex.Store(&#123; actions, mutations, state,&#125;) 组件中读取vuex中的数据：$store.state.sum 组件中修改vuex中的数据：$store.dispatch(&#39;action中的方法名&#39;,数据) 或 $store.commit(&#39;mutations中的方法名&#39;,数据) 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit 5.getters的使用 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。 在store.js中追加getters配置 12345678910111213......const getters = &#123; bigSum(state)&#123; return state.sum * 10 &#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123; ...... getters&#125;) 组件中读取数据：$store.getters.bigSum 6.四个map方法的使用 mapState方法：用于帮助我们映射state中的数据为计算属性 1234567computed: &#123; //借助mapState生成计算属性：sum、school、subject（对象写法） ...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;), //借助mapState生成计算属性：sum、school、subject（数组写法） ...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),&#125;, mapGetters方法：用于帮助我们映射getters中的数据为计算属性 1234567computed: &#123; //借助mapGetters生成计算属性：bigSum（对象写法） ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;), //借助mapGetters生成计算属性：bigSum（数组写法） ...mapGetters([&#x27;bigSum&#x27;])&#125;, mapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数 1234567methods:&#123; //靠mapActions生成：incrementOdd、incrementWait（对象形式） ...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;) //靠mapActions生成：incrementOdd、incrementWait（数组形式） ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])&#125; mapMutations方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数 1234567methods:&#123; //靠mapActions生成：increment、decrement（对象形式） ...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;), //靠mapMutations生成：JIA、JIAN（对象形式） ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),&#125; 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。 7.模块化+命名空间 目的：让代码更好维护，让多种数据分类更加明确。 修改store.js 12345678910111213141516171819202122232425const countAbout = &#123; namespaced:true,//开启命名空间 state:&#123;x:1&#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; bigSum(state)&#123; return state.sum * 10 &#125; &#125;&#125;const personAbout = &#123; namespaced:true,//开启命名空间 state:&#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; countAbout, personAbout &#125;&#125;) 开启命名空间后，组件中读取state数据： 1234//方式一：自己直接读取this.$store.state.personAbout.list//方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]), 开启命名空间后，组件中读取getters数据： 1234//方式一：自己直接读取this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]//方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;]) 开启命名空间后，组件中调用dispatch 1234//方式一：自己直接dispatchthis.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person)//方式二：借助mapActions：...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;) 开启命名空间后，组件中调用commit 1234//方式一：自己直接committhis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)//方式二：借助mapMutations：...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;), 路由 理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。 前端路由：key是路径，value是组件。 1.基本使用 安装vue-router，命令：npm i vue-router 应用插件：Vue.use(VueRouter) 编写router配置项: 12345678910111213141516171819202122//引入VueRouterimport VueRouter from &#x27;vue-router&#x27;//引入Luyou 组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;//创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123; routes:[ &#123; path:&#x27;/about&#x27;, component:About &#125;, &#123; path:&#x27;/home&#x27;, component:Home &#125; ]&#125;)//暴露routerexport default router 实现切换（active-class可配置高亮样式） 1&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt; 指定展示位置 1&lt;router-view&gt;&lt;/router-view&gt; 2.几个注意点 路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。 每个组件都有自己的$route属性，里面存储着自己的路由信息。 整个应用只有一个router，可以通过组件的$router属性获取到。 3.多级路由（多级路由） 配置路由规则，使用children配置项： 1234567891011121314151617181920routes:[ &#123; path:&#x27;/about&#x27;, component:About, &#125;, &#123; path:&#x27;/home&#x27;, component:Home, children:[ //通过children配置子级路由 &#123; path:&#x27;news&#x27;, //此处一定不要写：/news component:News &#125;, &#123; path:&#x27;message&#x27;,//此处一定不要写：/message component:Message &#125; ] &#125;] 跳转（要写完整路径）： 1&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt; 4.路由的query参数 传递参数 12345678910111213&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt; &lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; path:&#x27;/home/message/detail&#x27;, query:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 接收参数： 12$route.query.id$route.query.title 5.命名路由 作用：可以简化路由的跳转。 如何使用 给路由命名： 1234567891011121314151617&#123; path:&#x27;/demo&#x27;, component:Demo, children:[ &#123; path:&#x27;test&#x27;, component:Test, children:[ &#123; name:&#x27;hello&#x27; //给路由命名 path:&#x27;welcome&#x27;, component:Hello, &#125; ] &#125; ]&#125; 简化跳转： 12345678910111213141516&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link :to=&quot;&#123; name:&#x27;hello&#x27;, query:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 6.路由的params参数 配置路由，声明接收params参数 1234567891011121314151617181920&#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&#x27;news&#x27;, component:News &#125;, &#123; component:Message, children:[ &#123; name:&#x27;xiangqing&#x27;, path:&#x27;detail/:id/:title&#x27;, //使用占位符声明接收params参数 component:Detail &#125; ] &#125; ]&#125; 传递参数 12345678910111213&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt; &lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！ 接收参数： 12$route.params.id$route.params.title 7.路由的props配置​ 作用：让路由组件更方便的收到参数 12345678910111213141516171819&#123; name:&#x27;xiangqing&#x27;, path:&#x27;detail/:id&#x27;, component:Detail, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 // props:&#123;a:900&#125; //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件 // props:true //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props(route)&#123; return &#123; id:route.query.id, title:route.query.title &#125; &#125;&#125; 8.&lt;router-link&gt;的replace属性 作用：控制路由跳转时操作浏览器历史记录的模式 浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push 如何开启replace模式：&lt;router-link replace .......&gt;News&lt;/router-link&gt; 9.编程式路由导航 作用：不借助&lt;router-link&gt; 实现路由跳转，让路由跳转更加灵活 具体编码： 12345678910111213141516171819//$router的两个APIthis.$router.push(&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:xxx, title:xxx &#125;&#125;)this.$router.replace(&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:xxx, title:xxx &#125;&#125;)this.$router.forward() //前进this.$router.back() //后退this.$router.go() //可前进也可后退 10.缓存路由组件 作用：让不展示的路由组件保持挂载，不被销毁。 具体编码： 123&lt;keep-alive include=&quot;News&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 11.两个新的生命周期钩子 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。 具体名字： activated路由组件被激活时触发。 deactivated路由组件失活时触发。 12.路由守卫 作用：对路由进行权限控制 分类：全局守卫、独享守卫、组件内守卫 全局守卫: 123456789101112131415161718192021222324//全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach((to,from,next)=&gt;&#123; console.log(&#x27;beforeEach&#x27;,to,from) if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制 if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; //权限控制的具体规则 next() //放行 &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next(&#123;name:&#x27;guanyu&#x27;&#125;) &#125; &#125;else&#123; next() //放行 &#125;&#125;)//全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&gt;&#123; console.log(&#x27;afterEach&#x27;,to,from) if(to.meta.title)&#123; document.title = to.meta.title //修改网页的title &#125;else&#123; document.title = &#x27;vue_test&#x27; &#125;&#125;) 独享守卫: 12345678910111213beforeEnter(to,from,next)&#123; console.log(&#x27;beforeEnter&#x27;,to,from) if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制 if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; next() &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next(&#123;name:&#x27;guanyu&#x27;&#125;) &#125; &#125;else&#123; next() &#125;&#125; 组件内守卫： 123456//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125; 13.路由器的两种工作模式 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。 hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。 hash模式： 地址中永远带着#号，不美观 。 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。 兼容性较好。 history模式： 地址干净，美观 。 兼容性和hash模式相比略差。 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。","categories":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/categories/Vue2-0/"}],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/tags/Vue2-0/"},{"name":"Vue-router","slug":"Vue-router","permalink":"http://example.com/tags/Vue-router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"http://example.com/tags/Vue-Cli/"}]},{"title":"Vue全家桶之VueCLI 脚手架V2→V4版本(三)","slug":"Vue全家桶之VueCLI 脚手架V2→V4版本(三)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T10:16:03.759Z","comments":true,"path":"2022/04/24/Vue全家桶之VueCLI 脚手架V2→V4版本(三)/","link":"","permalink":"http://example.com/2022/04/24/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8BVueCLI%20%E8%84%9A%E6%89%8B%E6%9E%B6V2%E2%86%92V4%E7%89%88%E6%9C%AC(%E4%B8%89)/","excerpt":"","text":"✍、目录脑图 配套视频讲解: CoderWhy老师的Vuejs讲解 Vue组件组件化开发指的是：根据封装的思想，把页面尚可重用的 UI 结构封装为组件，从而方便项目的开发和维护 Vue 是一个支持组件化开发的前端框架 Vue中规定：组件的后缀名是 .Vue，我们之前接触的 App.vue 文件本质尚就是一个 vue 的组件。 Vue组件的三个组成部分每个 .Vue 组件都是由三部分组成，分别是 template -&gt; 组件的模板结构 script -&gt; 组件的 JavaScript 行为 style -&gt; 组件的样式 其中，每个组件中必须包含template 模板结构，而script 行为和style 样式是可选的组成部分。 templatevue 规定：每个组件对应的 模板结构，需要定义到 &lt;template&gt; 节点中。 123&lt;template&gt; &lt;!-- 当前组件的 DOM 结构,需要定义到 template 标签的内部 --&gt;&lt;/template&gt; 注意： template 是vue 提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的DOM 元素 template 中只能包含唯一的根节点 scriptvue 规定：开发者可以在&lt;script&gt; 节点中封装组件的JavaScript 业务逻辑。 12345&lt;script&gt; // 今后,组件相关的 data 数据、methods 方法等 // 都需要定义到 export default 所导出的对象中 export default &#123;&#125;&lt;/script&gt; stylevue 规定：组件内的&lt;style&gt;节点是可选的，开发者可以在&lt;style&gt; 节点中编写样式美化当前组件的UI 结构。 12345&lt;style&gt; h1&#123; font-weight: normal; &#125;&lt;/style&gt; 让style中支持less语法让 &lt;style&gt; 标签上添加 lang=&quot;less&quot; 属性,即可使用 less 语法编写组件的样式： 12345678&lt;style lang=&quot;less&quot;&gt; h1 &#123; font-weight: normal; span&#123; color: red; &#125; &#125;&lt;/style&gt; 组件之间的样式冲突问题默认情况下，写在.vue 组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。 导致组件之间样式冲突的根本原因是： 单页面应用程序中，所有组件的DOM 结构，都是基于唯一的index.html 页面进行呈现的 每个组件中的样式，都会影响整个index.html 页面中的DOM 元素 为了提高开发效率和开发体验，vue 为style 节点提供了 scoped属性，从而防止组件之间的样式冲突问题 /deep/样式穿透 如果给当前组件的style 节点添加了scoped 属性，则当前组件的样式对其子组件是不生效的。 如果想让某些样式对子组件生效，可以使用 /deep/ 深度选择器。 使用组件的三个步骤 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;h1&gt;App 根组件&lt;/h1&gt; &lt;!-- 渲染 Left 组件和 Right 组件 --&gt; &lt;div class=&quot;box&quot;&gt; &lt;!-- 3.以标签形式,使用注册好的组件 --&gt; &lt;Left&gt;&lt;/Left&gt; &lt;Right&gt;&lt;/Right&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 1.导入需要使用的 .vue组件import Left from &#x27;./components/Left&#x27;import Right from &#x27;./components/Right&#x27;export default &#123; name: &#x27;App&#x27;, // 2.注册组件 components: &#123; // &#x27;Left&#x27;: Left 简化写法如下,对象里面键值一样的话直接写一个就行 Left, Right &#125;&#125;&lt;/script&gt;&lt;style&gt;.app-container &#123; padding: 1px 20px 20px; background-color: #efefef;&#125;.box &#123; display: flex;&#125;&lt;/style&gt; 私有子组件通过 components 注册的是私有子组件 例如： 在组件A的components 节点下，注册了组件F。则组件F 只能用在组件A 中；不能被用在组件C 中。 注册全局组件在vue 项目的main.js 入口文件中，通过Vue.component() 方法，可以注册全局组件。示例代码如下： 1234567// 导入需要全局注册的组件import Count from &#x27;./components/Count.vue&#x27;// 参数1:字符串格式,表示组件的注册名称// 参数2:需要被全局注册的那个组件Vue.component(&#x27;MyCount&#x27;,Count) Vue CLI2 CLI是Command-Line Interface, 翻译为命令行界面, 但是俗称脚手架 Vue CLI是一个官方发布 vue.js 项目脚手架 使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置 Vue CLI官网：https://cli.vuejs.org/zh/ vue-cli 是Vue.js 开发的标准工具。它简化了程序员基于webpack 创建工程化的Vue 项目的过程 程序员可以专注在撰写应用上，而不必花好几天去纠结webpack 配置的问题 安装Vue脚手架全局安装 cli 1npm install -g @vue/cli 这样安装的是脚手架的最新版本，如果我们想安装脚手架 2 版本呢？ 全局安装脚手架2版本，这样的话我们就既可以用脚手架2的版本，也可以用脚手架最新的版本 1npm install -g @vue/cli-init Vue CLI2 初始化项目命令 1vue init webpack my-project Vue CLI 3 初始化项目命令 1vue create my-project 查看 VueCLI 版本（注意 V 要大写） 1vue -V Vue CLI2 初始化项目在终端输入 vue init webpack my-project 目录结构详解 运行项目我们使用脚手架初始化项目之后如何运行呢？ cd 到对应目录，在终端输入 npm run dev 就可以运行了 解释我们来看 main.js Vue实例中，我们定义了el属性，用于和index.html中的#app进行绑定，让Vue实例之后可以管理它其中的内容 而如果Vue实例中同时指定了template，那么template模板的内容会替换掉挂载的对应el的模板 template 模板也就是 App.vue 里面的内容 关闭Eslint若我们在初始化项目时候开启了 ESlint 代码检测，我们不想用的时候方法如下： Vue CLI3Vue-cli 3 与 2 版本有很大区别 vue-cli 3 是基于 webpack 4 打造，vue-cli 2 还是 webapck 3 vue-cli 3 的设计原则是“0配置”，移除的配置文件根目录下的，build和config等目录 vue-cli 3 提供了 vue ui 命令，提供了可视化配置，更加人性化 移除了static文件夹，新增了public文件夹，并且index.html移动到public中 Vue CLI 3 初始化项目命令： 1vue create my-project 目录结构详解 运行项目使用 Vue CLI3 初始化项目之后，运行项目。只需要看 package.json 下的 scripts 就知道运行命令 配置 方式一：启动图形化界面 Vue ui 方式二：自定义配置 vue.config.js 123module.exports = &#123;&#125; Vue CLI4单页面应用程序SPA单页面应用程序（英文名：Single Page Application）简称SPA，顾名思义，指的是一个Web 网站中只有唯一的一个HTML 页面，所有的功能与交互都在这唯一的一个页面内完成。 我们现在的开发模式就是单页面，一次将所有的资源请求完，这样我们点击此单页面的功能，就不会再去请求资源，极大的节约了我们的带宽。 Vue项目的运行流程在工程化的项目中，vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中。 其中： App.vue 用来编写待渲染的模板结构 index.html 中需要预留一个el 区域 main.js 把App.vue 渲染到了index.html 所预留的区域中 安装VueCLI41npm install -g @vue/cli 查看版本 1vue --version 创建项目 在控制台输入如下命令会创建 hello-world 项目 1vue create hello-world 会弹出如下选择预设 箭头上下键控制选择，选择 Manually select features 手动配置 1234? Please pick a preset: (Use arrow keys)&gt; Default ([Vue 2] babel, eslint) Default (Vue 3) ([Vue 3] babel, eslint) Manually select features 手动配置如下 箭头上下键控制选择，空格进行选中 123456789101112? Please pick a preset: Manually select features? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)&gt;(*) Choose Vue version (*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support ( ) Router ( ) Vuex ( ) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing 选项 描述 Choose Vue version 选择Vue版本 Babel vue项目中普遍使用es6语法，但有时我们的项目需要兼容低版本浏览器，这时就需要引入babel插件，将es6转成es5 TypeScript TypeScript通过添加类型来扩展JavaScript。通过了解JavaScript，TypeScript可以节省您捕获错误的时间并在运行代码之前提供修复。任何浏览器，任何操作系统，任何运行JavaScript的地方。 完全开源 Progressive Web App (PWA) Support 渐进式Web应用程序（PWA）支持 Router 路由 Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 CSS Pre-processors CSS预处理器，预处理器：比如要用sass或者cssNext就要按照人家规定的语法形式，就是用人家的语法去编写，然后人家把你编写的代码转成css。 Linter / Formatter 格式化程序 Unit Testing 单元测试 E2E Testing 端到端（end-to-end） 配置放在一个文件里面还是分不同的文件配置 12345? Please pick a preset: Manually select features? Check the features needed for your project: Babel? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)&gt; In dedicated config files In package.json 配置项是否要保存 如果保存,我们上面所选择的配置会作为以后项目的预置，我们不保存 1234? Please pick a preset: Manually select features? Check the features needed for your project: Babel? Where do you prefer placing config for Babel, ESLint, etc.? In package.json? Save this as a preset for future projects? (y/N) 这样就会进行安装了 项目目录介绍 node_module:用于存放我们项目的各种依赖 public:用于存放静态文件，是网站的根目录 favicon.ico：网站的小图标 index.html：网站的首页，是一个模板文件，作用是生成项目的入口文件，webpack打包的js,css也会自动注入到该页面中。我们浏览器访问项目的时候就会默认打开生成好的index.html src：src下就是我们写代码的地方 assets：用于存放各种静态文件，如图片 components：用于存放我们的公共组件，如 header、footer等 App.vue：主vue模块，引入其他模块，app.vue是项目的主组件，所有页面都是在app.vue下切换的 main.js：入口文件，主要作用是初始化vue实例，同时可以在此文件中引用某些组件库或者全局挂在一些变量 router.js：路由文件，这个里边可以理解为各个页面的地址路径，用于我们访问，同时可以直接在里边编写路由守卫 store.js：主要用于项目里边的一些状态的保存 gitignore:git上传需要忽略的文件格式 babel.config.js：是一个工具链，主要用于在当前和较旧的浏览器或环境中将ECMAScript 2015+代码转换为JavaScript的向后兼容版本 package.json:模块基本信息项目开发所需要模块，版本，项目名称 package-lock.json:是在 npm install时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号 vue.config.js:保存vue配置的文件，可以用于设置代理,打包配置等 运行项目 运行项目 1npm run serve 打包项目 1npm run build Runtime-Compiler和Runtime-only的区别运行时 + 编译器(Runtime + Compiler) 版本 和 只含有运行时版本(Runtime-only) 为什么存在这样的差异呢，我们先来看一下 Vue 程序运行过程，Vue中的模板如何最终渲染成真实DOM 我们的 template 被 Vue 解析成 ast，ast 经过编译再通过 render 函数转成虚拟DOM，之后再转成我们的真实DOM 运行时 + 编译器(Runtime + Compiler) 版本： ```template -&gt; ast -&gt; render -&gt; vdom -&gt; UI12345**只含有运行时版本(Runtime-only)版本**：性能更高，且代码量更少- ``` render -&gt; vdom -&gt; UI 简要总结： 如果之后的开发中，你依然使用 template，就需要选择Runtime-Compiler 如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only （推荐）","categories":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/categories/Vue2-0/"}],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/tags/Vue2-0/"},{"name":"Vue-router","slug":"Vue-router","permalink":"http://example.com/tags/Vue-router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"http://example.com/tags/Vue-Cli/"}]},{"title":"Vue全家桶之Vue组件化开发(二)","slug":"Vue全家桶之Vue组件化开发(二)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T10:11:10.663Z","comments":true,"path":"2022/04/24/Vue全家桶之Vue组件化开发(二)/","link":"","permalink":"http://example.com/2022/04/24/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8BVue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91(%E4%BA%8C)/","excerpt":"","text":"✍、目录脑图 Vue 配套视频讲解: CoderWhy老师的Vuejs讲解 组件化开发我们将一个完整的页面分成很多个组件，每个组件都用于实现页面的一个功能块，而每一个组件又可以进行细分 组件的使用步骤： 创建组件构造器： 调用 Vue.extend() 方法创建组件构造器 注册组件：调用 Vue.component() 方法注册组件 使用组件：在 Vue 实例的作用范围内使用组件 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=&quot;app&quot;&gt; &lt;!--3.使用组件--&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;div&gt; &lt;div&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.创建组件构造器对象 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt; &lt;p&gt;我是内容, 呵呵呵呵&lt;/p&gt; &lt;/div&gt; ` &#125;) // 2.注册组件 // 参数1:字符串格式,表示组件的注册名称 // 参数2:需要被全局注册的那个组件 Vue.component(&#x27;my-cpn&#x27;, cpnC) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125; &#125;)&lt;/script&gt; 步骤解析 Vue.extend(): 调用 Vue.extend() 创建的是一个组件构造器 通常在创建组件构造器时，传入 template 代表我们自定义组件的模板 该模板就是在使用到组件的地方，要显示的HTML代码 事实上，这种写法在Vue2.x的文档中几乎已经看不到了，它会直接使用下面我们会讲到的语法糖，但是在很多资料还是会提到这种方式，而且这种方式是学习后面方式的基础。 Vue.component(): 调用 Vue.component() 是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称 所以需要传递两个参数：1、注册组件的标签名。 2、组件构造器 组件必须挂载在某个Vue实例下，否则它不会生效 我们来看下面我使用了三次 &lt;my-cpn&gt;&lt;/my-cpn&gt; ,而第三次其实并没有生效 全局组件和局部组件当我们调用Vue.component()注册组件时，组件的注册是全局的 这意味着该组件可以在任意Vue示例下使用 但是如果我们注册的组件是挂载在某个实例中，那么就是一个局部组件 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app2&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.创建组件构造器 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;我是内容,哈哈哈哈啊&lt;/p&gt; &lt;/div&gt; ` &#125;) // 2.注册组件(全局组件, 意味着可以在多个Vue的实例下面使用) // Vue.component(&#x27;cpn&#x27;, cpnC) // 疑问: 怎么注册的组件才是局部组件了? // 答:将组件构造器放在实例当中 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; // 将组件构造器放在实例当中 // cpn使用组件时的标签名 cpn: cpnC &#125; &#125;) const app2 = new Vue(&#123; el: &#x27;#app2&#x27; &#125;)&lt;/script&gt; 通过Vue.component()方法注册的组件是全局组件，通过 components 注册的是私有子组件 父组件和子组件组件与组件之间存在层级关系，其中一种最重要的关系就是父子组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div id=&quot;app&quot;&gt; &lt;cpn2&gt;&lt;/cpn2&gt; &lt;!--&lt;cpn1&gt;&lt;/cpn1&gt;--&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.创建第一个组件构造器(子组件) const cpnC1 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题1&lt;/h2&gt; &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt; &lt;/div&gt; ` &#125;) // 2.创建第二个组件构造器(父组件) const cpnC2 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题2&lt;/h2&gt; &lt;p&gt;我是内容, 呵呵呵呵&lt;/p&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;/div&gt; `, components: &#123; // 在父组件中注册子组件,这样就可以在父组件里面使用子组件 // 例如上面的&lt;cpn1&gt;&lt;/cpn1&gt; cpn1: cpnC1 &#125; &#125;) // root组件 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; // cpn1子组件在cpn2父组件中注册,父组件cpn2在Vue实例里面注册 cpn2: cpnC2 &#125; &#125;)&lt;/script&gt; 父子组件的错误用法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id=&quot;app&quot;&gt; &lt;cpn2&gt;&lt;/cpn2&gt; &lt;!--父子组件的错误用法:以子组件的形式在 Vue 实例中使用--&gt; &lt;!--&lt;cpn1&gt;&lt;/cpn1&gt;--&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.创建第一个组件构造器(子组件) const cpnC1 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题1&lt;/h2&gt; &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt; &lt;/div&gt; ` &#125;) // 2.创建第二个组件构造器(父组件) const cpnC2 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题2&lt;/h2&gt; &lt;p&gt;我是内容, 呵呵呵呵&lt;/p&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;/div&gt; `, components: &#123; // 在父组件中注册子组件,这样就可以在父组件里面使用子组件 // 例如上面的&lt;cpn1&gt;&lt;/cpn1&gt; cpn1: cpnC1 &#125; &#125;) // root组件 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; // cpn1子组件在cpn2父组件中注册,父组件cpn2在Vue实例里面注册 cpn2: cpnC2 &#125; &#125;)&lt;/script&gt; 父子组件的错误用法： 以子组件的形式在 Vue 实例中使用 因为当子组件注册到父组件的 components 时，Vue 会编译好父组件的模块 该模板的内容已经决定了父组件将要渲染的 HTML(相当于父组件中已经有了子组件的内容了) &lt;cpn1&gt;&lt;/cpn1&gt; 是只能在父组件中被识别的 类似这种用法，&lt;cpn1&gt;&lt;/cpn1&gt; 是会被浏览器忽略的。 注册组件语法糖🔥 Vue 为了简化这个过程，提供了注册的语法糖 主要是省去了调用 Vue.extend() 的步骤,而是可以直接使用一个对象来代替 语法糖注册全局组件和局部组件语法糖：看图片左边 123456789101112131415161718192021222324252627282930313233343536373839&lt;div id=&quot;app&quot;&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;cpn2&gt;&lt;/cpn2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.全局组件注册的语法糖 // 1.创建组件构造器 // const cpn1 = Vue.extend() // 2.注册组件 Vue.component(&#x27;cpn1&#x27;, &#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题1&lt;/h2&gt; &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt; &lt;/div&gt; ` &#125;) // 2.注册局部组件的语法糖 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; &#x27;cpn2&#x27;: &#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题2&lt;/h2&gt; &lt;p&gt;我是内容, 呵呵呵&lt;/p&gt; &lt;/div&gt; ` &#125; &#125; &#125;)&lt;/script&gt; 模板的分离写法通过语法糖简化了 Vue 组件的注册过程，另外还有一个地方的写法比较麻烦，就是 template 模块写法 如果我们能将其中的HTML分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰 Vue 提供了两种方案来定义HTML模板内容 使用 &lt; script &gt; 标签 使用 &lt; template &gt; 标签 使用 script 标签1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;!--1.script标签, 注意:类型必须是text/x-template--&gt;&lt;script type=&quot;text/x-template&quot; id=&quot;cpn&quot;&gt;&lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;我是内容,哈哈哈&lt;/p&gt;&lt;/div&gt;&lt;/script&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.注册一个全局组件 Vue.component(&#x27;cpn&#x27;, &#123; template: &#x27;#cpn&#x27; &#125;) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125; &#125;)&lt;/script&gt; 使用template标签🔥1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;!--2.template标签--&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;我是内容,呵呵呵&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.注册一个全局组件 Vue.component(&#x27;cpn&#x27;, &#123; template: &#x27;#cpn&#x27; &#125;) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125; &#125;)&lt;/script&gt; 组件数据存放问题：组件可以访问Vue实例数据吗？我们来测试一下 结论：组件不能直接访问Vue实例中的 data 组件是一个单独功能模块的封装： 这个模块有属于自己的 HTML 模板，也应该有属于自己的数据 data 组件自己的数据存放在哪呢？ 组件对象也有一个 data 属性(也可以有 methods 属性) 只是这个 data 属性必须是一个函数 而且这个函数返回一个对象，对象内部保存着数据 1234567891011121314151617181920212223242526272829303132333435&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;!--2.template标签--&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;p&gt;我是内容,呵呵呵&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.注册一个全局组件 Vue.component(&#x27;cpn&#x27;, &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; title: &#x27;abc&#x27; &#125; &#125; &#125;) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, // title: &#x27;我是标题&#x27; &#125; &#125;)&lt;/script&gt; 为什么 data 在组件中必须是一个函数呢？ 首先，如果不算是一个函数，Vue 直接就会报错 其次，原因是在于 Vue 让每个组件对象都返回一个新的对象，因为如果是同一个对象，组件在多次使用后会相互影响 父子组件通信🔥在上一个小节中，我们提到了子组件是不能引用父组件或者Vue实例的数据的 但是，在开发中，往往一些数据确实需要从上层传递到下层 比如在一个页面中，我们从服务器请求到了很多的数据 其中的一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示 这个时候，并不会让子组件再次发送一个网络请求，而是直接让大组件(父组件) 将数据传递给小组件(子组件) 如何进行父子组件间的通信呢？ 通过 props 向子组件传递数据 通过事件向父组件发送消息 props 基本用法在组件中，使用选项 props 来声明需要从父级接收到的数据(properties) props 的值有两种方式： 方式一：字符串数组，数组中的字符串就是传递时的名称 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。 传数组123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; &lt;!-- 4.使用组件(v-bind动态绑定) --&gt; &lt;cpn :cmessage=&quot;`message`&quot; :cmovies=&quot;movies&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;!-- 2.组件构造器的模板分离写法 --&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;cmovies&#125;&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.创建组件构造器(子组件) const cpn = &#123; template: &#x27;#cpn&#x27;, props: [&#x27;cmovies&#x27;, &#x27;cmessage&#x27;] //父传子,props &#125; // 3.注册组件(将子组件在父组件里面注册) const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, movies: [&#x27;海王&#x27;, &#x27;海贼王&#x27;, &#x27;海尔兄弟&#x27;] &#125;, components: &#123; //对象字面量增强写法的属性增强写法 cpn &#125; &#125;)&lt;/script&gt; 注意：我们在使用组件时，需要用v-bind 动态绑定数据。 传对象 在前面，我们的 props 选项是使用一个数组 除了数组之外，我们也可以使用对象，当需要对props 进行类型等验证时，就需要对象写法了 验证支持的数据类型有： String Number Boolean Array Object Date Function Symbol ①类型限制我们可以在 props 里面限制父组件给子组件传递的数据类型 1234567891011121314151617181920212223242526272829303132333435363738&lt;!--父组件模板--&gt;&lt;div id=&quot;app&quot;&gt; &lt;cpn :cmessage=&quot;message&quot; :cmovies=&quot;movies&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;!--子组件模板--&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;cmovies&#125;&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 父传子: props const cpn = &#123; template: &#x27;#cpn&#x27;, props: &#123; // 1.类型限制 cmovies: Array, // 限制父组件传的是数组类型 cmessage: String, // 限制父组件传的是字符串类型 &#125; &#125; // root组件,我们当作父组件 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, movies: [&#x27;海王&#x27;, &#x27;海贼王&#x27;, &#x27;海尔兄弟&#x27;] &#125;, components: &#123; //对象字面量增强写法的属性增强写法 cpn &#125; &#125;)&lt;/script&gt; ②默认值和必传值 type : 限制的类型 ```default 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 : 如果没有传值,给一个默认值 - **注意**:类型是对象或者数组时, 默认值必须是一个函数- `required` : 必须的,即意味着这个值是必须要传递的,不传就报错```js&lt;div id=&quot;app&quot;&gt; &lt;!--在这里传值--&gt; &lt;cpn :cmessage=&quot;message&quot; :cmovies=&quot;movies&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;cmovies&#125;&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 父传子: props const cpn = &#123; template: &#x27;#cpn&#x27;, // props: [&#x27;cmovies&#x27;, &#x27;cmessage&#x27;], props: &#123; // 2.提供一些默认值, 以及必传值 cmessage: &#123; type: String, // 类型限制为 String default: &#x27;aaaaaaaa&#x27;, // 如果没有传值,则给一个默认值 required: true // required 必须的,即意味着这个值是必须要传递的,不传就报错 &#125;, // 类型是对象或者数组时, 默认值必须是一个函数 cmovies: &#123; type: Array, default() &#123; return [] &#125; &#125; &#125;, // root组件,我们当作父组件 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, movies: [&#x27;海王&#x27;, &#x27;海贼王&#x27;, &#x27;海尔兄弟&#x27;] &#125;, components: &#123; //对象字面量增强写法的属性增强写法 cpn &#125; &#125;)&lt;/script&gt; ③自定义类型当我们有自定义构造函数时,验证也支持自定义的类型 ④props驼峰标识当我们 props 里面的属性是驼峰写法的时,在传入值时需要进行 - 连接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id=&quot;app&quot;&gt; &lt;!--目前不支持直接写cInfo,驼峰得加 `-` 连接--&gt; &lt;cpn :c-info=&quot;info&quot; :child-my-message=&quot;message&quot; &gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;cInfo&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;childMyMessage&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const cpn = &#123; template: &#x27;#cpn&#x27;, props: &#123; // 驼峰写法cInfo cInfo: &#123; //类型是对象或者数组时, 默认值必须是一个函数 type: Object, default() &#123; return &#123;&#125; &#125; &#125;, childMyMessage: &#123; type: String, default: &#x27;&#x27; &#125; &#125; &#125; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; info: &#123; name: &#x27;why&#x27;, age: 18, height: 1.88 &#125;, message: &#x27;aaaaaa&#x27; &#125;, components: &#123; cpn &#125; &#125;)&lt;/script&gt; 子级向父级传递 props 用于父组件向子组件传递数据，还有一种比较常见的是子组件传递数据或事件到父组件去 这个时候，我们需要使用自定义事件来完成 什么时候需要自定义事件呢？ 当子组件需要向父组件传递数据时，就要用到自定义事件了 我们之前学习的 v-on 不仅仅可以用于监听 DOM 事件，也可以用于组件间的自定义事件 自定义事件的流程： 在子组件中，通过$emit() 来触发事件 在父组件中，通过v-on 来监听子组件事件 我们来看一个简单的例子： 我们之前做过一个两个按钮 +1 和 -1，点击后修改 counter 我们整个操作的过程还是在子组件中完成，但是之后的展示交给父组件 这样，我们就需要将子组件中的 counter，传给父组件的某个属性，比如total 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;body&gt;&lt;!--父组件模板--&gt;&lt;div id=&quot;app&quot;&gt; &lt;!-- 2.父组件里面接收子组件发出的自定义事件 值是一个方法 --&gt; &lt;cpn @item-click=&quot;cpnClick&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;!--子组件模板--&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;button v-for=&quot;item in categories&quot; @click=&quot;btnClick(item)&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 1.子组件 const cpn = &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; categories: [ &#123;id: &#x27;aaa&#x27;, name: &#x27;热门推荐&#x27;&#125;, &#123;id: &#x27;bbb&#x27;, name: &#x27;手机数码&#x27;&#125;, &#123;id: &#x27;ccc&#x27;, name: &#x27;家用家电&#x27;&#125;, &#123;id: &#x27;ddd&#x27;, name: &#x27;电脑办公&#x27;&#125;, ] &#125; &#125;, methods: &#123; btnClick(item) &#123; // console.log(item); // 1.发射事件: 自定义事件 // 第一个参数是自定义事件的名称,第二个参数是自定义事件的参数 this.$emit(&#x27;item-click&#x27;, item) &#125; &#125; &#125; // 2.父组件 const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; cpn &#125;, methods: &#123; // 3.父组件里面定义方法处理 cpnClick(item) &#123; console.log(&#x27;cpnClick&#x27;, item); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 父组件访问子组件有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问根组件。 父组件访问子组件：使用 $children 或 $refs 子组件访问父组件：使用$parent 父组件访问子组件我们先来看下$children 的访问 this.$children 是一个数组类型，它包含所有子组件对象 $children 的缺陷： 通过 $children 访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值 但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化 有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用 $refs $refs 的使用🔥 $refs 和 ref 指令通常是一起使用的 首先，我们通过 ref 给某一个子组件绑定一个特定的 ID 其次，通过 this.$refs.ID 就可以访问到该组件了 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;!--父组件的模板--&gt; &lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn ref=&quot;aaa&quot;&gt;&lt;/cpn&gt; &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;!--子组件的模板--&gt; &lt;template id=&quot;cpn&quot;&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;/template&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, methods: &#123; btnClick() &#123; // 2.$refs =&gt; 对象类型, 默认是一个空的对象 必须在组件上加 ref=&#x27;bbb&#x27; console.log(this.$refs.aaa.name); &#125; &#125;, components: &#123; cpn: &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; name: &#x27;我是子组件的name&#x27; &#125; &#125;, &#125;, &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 子组件访问父组件如果我们想在子组件中直接访问父组件，可以通过 $parent 尽管在 Vue 开发中，我们允许通过 $parent 来访问父组件，但是在真实开发中尽量不要这要做 子组件应该尽量避免直接访问父组件的数据，因为这样耦合度太高了 如果我们将子组件放入另外一个组件之内，很可能该父组件没有对应的属性，往往会引起问题 组件化高级slot插槽 在子组件中，使用特殊的元素 &lt;slot&gt;就可以为子组件开启一个插槽 该插槽插入什么内容取决于父组件如何使用 我们来看一个简单的例子，来给子组件定义一个插槽： &lt;slot&gt; 中的内容表示，如果没有在该组件中插入任何其他内容，就默认显示该内容 如果有多个值，同时放入到组件进行替换时，一起作为替换元素 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;!--父组件模板--&gt;&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;span&gt;哈哈哈&lt;/span&gt;&lt;/cpn&gt; &lt;cpn&gt; &lt;i&gt;呵呵呵&lt;/i&gt; &lt;div&gt;我是div元素&lt;/div&gt; &lt;p&gt;我是p元素&lt;/p&gt; &lt;/cpn&gt;&lt;/div&gt;&lt;!--子组件模板--&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;h2&gt;我是组件&lt;/h2&gt; &lt;slot&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; cpn: &#123; template: &#x27;#cpn&#x27; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 具名插槽slot当子组件的功能复杂时，子组件的插槽可能并非是一个。 比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。 那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？p这个时候，我们就需要给插槽起一个名字 如何给插槽起名字呢？ 给插槽起一个名字，只要给 slot 元素一个 name 属性即可 123456789101112131415161718192021222324252627282930&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;span slot=&quot;center&quot;&gt;标题&lt;/span&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;button slot=&quot;left&quot;&gt;返回&lt;/button&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;slot name=&quot;left&quot;&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt; &lt;slot name=&quot;center&quot;&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt; &lt;slot name=&quot;right&quot;&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; cpn: &#123; template: &#x27;#cpn&#x27; &#125; &#125; &#125;)&lt;/script&gt; 编译作用域我们来考虑下面的代码是否最终是可以渲染出来的： &lt; my-cpn v-show=&quot;isShow&quot;&gt;&lt;/ my-cpn &gt; 中，我们使用了 isShow 属性 isShow 属性包含在组件中，也包含在 Vue 实例中 答案：最终可以渲染出来，也就是使用的是 Vue 实例的属性 为什么呢？ 官方给出了一条准则：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在级作用域内编译 而我们在使用 &lt; my-cpn v-show=&quot;isShow&quot;&gt;&lt;/ my-cpn &gt; 的时候，整个组件的使用过程相当于在父组件中出现的 那么它的作用域就是父组件，使用的属性也是属于父组件的属性 因此 ,isShow 使用的是 Vue 实例中的属性，而不是子组件的属性 作用域插槽一句话总结：父组件替换插槽的标签，但是内容由子组件来提供 我们先提一个需求： 子组件包括一组数据 需要在多个界面进行展示 某些界面是以水平方向一一展示的 某些界面是以列表形式展示 某些界面直接展示一个数组 内容在子组件，希望父组件告诉我们如何展示，怎么办呢？ 利用 slot 作用域插槽就可以了 我们先来看看子组件的定义： 在父组件使用我们的子组件时，从子组件中拿到数据 我们通过 &lt;template slot-scope=&quot;slotProps&quot;&gt; 获取到 slotProps 属性 在通过 slotProps.data就可以获取到我们传入的 data 了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;body&gt;&lt;!--父组件模板--&gt;&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt; &lt;!--目的是获取子组件中的pLanguages--&gt; &lt;template slot-scope=&quot;slot&quot;&gt; &lt;!--&lt;span v-for=&quot;item in slot.data&quot;&gt; - &#123;&#123;item&#125;&#125;&lt;/span&gt;--&gt; &lt;span&gt;&#123;&#123;slot.data.join(&#x27; - &#x27;)&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/cpn&gt; &lt;cpn&gt; &lt;!--目的是获取子组件中的pLanguages--&gt; &lt;template slot-scope=&quot;slot&quot;&gt; &lt;!--&lt;span v-for=&quot;item in slot.data&quot;&gt;&#123;&#123;item&#125;&#125; * &lt;/span&gt;--&gt; &lt;span&gt;&#123;&#123;slot.data.join(&#x27; * &#x27;)&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/cpn&gt;&lt;/div&gt;&lt;!--子组件模板--&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;slot :data=&quot;pLanguages&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in pLanguages&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, components: &#123; cpn: &#123; template: &#x27;#cpn&#x27;, data() &#123; return &#123; pLanguages: [&#x27;JavaScript&#x27;, &#x27;C++&#x27;, &#x27;Java&#x27;, &#x27;C#&#x27;, &#x27;Python&#x27;, &#x27;Go&#x27;, &#x27;Swift&#x27;] &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 模块化开发ES6export指令 export 指令用于导出变量，比如下面的代码 1234// info.jsexport let name = &#x27;why&#x27;export let age = 18export let height = 1.88 上面的代码还有另外一种写法 123456// info.jslet name = &#x27;why&#x27;let age = 18let height = 1.88export&#123;name,age,height&#125; 导出函数或类上面我们主要是输出变量，也可以输出函数或者输出类 123456789101112export function test(content)&#123; console.log(content);&#125;export class Person &#123; constructor(name,age)&#123; this.name = name; this.age = age &#125; run()&#123; console.log(this.name + &#x27;在奔跑&#x27;); &#125;&#125; 上面的代码也可以写成这种形式 123456789101112131415function test(content) &#123; console.log(content);&#125;class Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; run() &#123; console.log(this.name + &#x27;在奔跑&#x27;) &#125;&#125;export &#123;test,Person&#125; export default 某些情况下，一个模块中包含某个功能，我们并不希望给这个功能命名，而是让导入者可以自己来命名 这个时候就可以使用 export default 1234// info.jsexport default function() &#123; console.log(&#x27;default function&#x27;)&#125; 我们来到 main.js 中，这样使用就可以了 这里的 myFunc 是我自己命名的，你可以根据需要命名它对应的名字 123import myFunc form &#x27;./info.js&#x27;myFunc() 另外，需要注意： export default 在同一个模块中，不允许同时存在多个 ES6 import的使用我们使用 export 指令导出了模块对外提供的接口，下面我们就可以通过 import 命令来加载对应的这个模块了 首先，我们需要在 HTML 代码中引入两个j文件，并且类型需要设置为 module 12&lt;script src = &quot;info.js&quot; type = &quot;module&quot;&gt;&lt;/script&gt;&lt;script src = &quot;main.js&quot; type = &quot;module&quot;&gt;&lt;/script&gt; import 指令用于导入模块中的内容，比如 main.js 的代码 123import &#123;name,age,height&#125; from &quot;./info.js&quot;console.log(name,age,height); 如果我们希望某个模块中所有的信息都导入，一个个导入显然有些麻烦 p通过*可以导入模块中所有的export变量 p但是通常情况下我们需要给*起一个别名，方便后续的使用 123import * as info from &#x27;./info.js&#x27;console.log(info.name,info.age,info.height);","categories":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/categories/Vue2-0/"}],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/tags/Vue2-0/"},{"name":"Vue-router","slug":"Vue-router","permalink":"http://example.com/tags/Vue-router/"},{"name":"VueCli4","slug":"VueCli4","permalink":"http://example.com/tags/VueCli4/"},{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"}]},{"title":"Vue3快速上手","slug":"vue3快速上手","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T10:38:09.296Z","comments":true,"path":"2022/04/24/vue3快速上手/","link":"","permalink":"http://example.com/2022/04/24/vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"","text":"Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王） 耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者 github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0 Vue3带来了什么性能的提升 打包大小减少41% 初次渲染快55%, 更新渲染快133% 内存减少54% …… 源码的升级 使用Proxy代替defineProperty实现响应式 重写虚拟DOM的实现和Tree-Shaking …… 拥抱TypeScript Vue3可以更好的支持TypeScript 新的特性 Composition API（组合API） setup配置 ref与reactive watch与watchEffect provide与inject …… 新的内置组件 Fragment Teleport Suspense 其他改变 新的生命周期钩子 data 选项应始终被声明为一个函数 移除keyCode支持作为 v-on 的修饰符 …… 创建Vue3.0工程使用 vue-cli 创建官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create 123456789## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve 使用 vite 创建官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite vite官网：https://vitejs.cn 什么是vite？—— 新一代前端构建工具。 优势如下： 开发环境中，无需打包操作，可快速的冷启动。 轻量快速的热重载（HMR）。 真正的按需编译，不再等待整个应用编译完成。 传统构建 与 vite构建对比图 12345678## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev 常用 Composition API官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html 拉开序幕的setup 理解：Vue3.0中一个新的配置项，值为一个函数。 setup是所有Composition API（组合API）“ 表演的舞台 ”。 组件中所用到的：数据、方法等等，均要配置在setup中。 setup函数的两种返回值： 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！） 若返回一个渲染函数：则可以自定义渲染内容。（了解） 注意点： 尽量不要与Vue2.x配置混用 Vue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。 但在setup中不能访问到Vue2.x配置（data、methos、computed…）。 如果有重名, setup优先。 setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合） ref函数 作用: 定义一个响应式的数据 语法: const xxx = ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。 JS中操作数据： xxx.value 模板中读取数据: 不需要.value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt; 备注： 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。 对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。 reactive函数 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数） 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象） reactive定义的响应式数据是“深层次的”。 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。 Vue3.0中的响应式原理vue2.x的响应式 实现原理： 对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。 1234Object.defineProperty(data, &#x27;count&#x27;, &#123; get () &#123;&#125;, set () &#123;&#125;&#125;) 存在问题： 新增属性、删除属性, 界面不会更新。 直接通过下标修改数组, 界面不会自动更新。 Vue3.0的响应式 实现原理: 通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。 通过Reflect（反射）: 对源对象的属性进行操作。 MDN文档中描述的Proxy与Reflect： Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect 12345678910111213141516new Proxy(data, &#123; // 拦截读取属性值 get (target, prop) &#123; return Reflect.get(target, prop) &#125;, // 拦截设置属性值或添加新属性 set (target, prop, value) &#123; return Reflect.set(target, prop, value) &#125;, // 拦截删除属性 deleteProperty (target, prop) &#123; return Reflect.deleteProperty(target, prop) &#125;&#125;)proxy.name = &#x27;tom&#x27; reactive对比ref 从定义数据角度对比： ref用来定义：基本类型数据。 reactive用来定义：对象（或数组）类型数据。 备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。 从原理角度对比： ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。 reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。 从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive定义的数据：操作数据与读取数据：均不需要.value。 setup的两个注意点 setup执行的时机 在beforeCreate之前执行一次，this是undefined。 setup的参数 props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。 context：上下文对象 attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。 slots: 收到的插槽内容, 相当于 this.$slots。 emit: 分发自定义事件的函数, 相当于 this.$emit。 计算属性与监视computed函数 与Vue2.x中computed配置功能一致 写法 1234567891011121314151617181920import &#123;computed&#125; from &#x27;vue&#x27;setup()&#123; ... //计算属性——简写 let fullName = computed(()=&gt;&#123; return person.firstName + &#x27;-&#x27; + person.lastName &#125;) //计算属性——完整 let fullName = computed(&#123; get()&#123; return person.firstName + &#x27;-&#x27; + person.lastName &#125;, set(value)&#123; const nameArr = value.split(&#x27;-&#x27;) person.firstName = nameArr[0] person.lastName = nameArr[1] &#125; &#125;)&#125; watch函数 与Vue2.x中watch配置功能一致 两个小“坑”： 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。 监视reactive定义的响应式数据中某个属性时：deep配置有效。 1234567891011121314151617181920212223242526272829303132//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123; console.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123; console.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据 若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！ 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效 watchEffect函数 watch的套路是：既要指明监视的属性，也要指明监视的回调。 watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。 watchEffect有点像computed： 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。 123456//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123; const x1 = sum.value const x2 = person.age console.log(&#x27;watchEffect配置的回调执行了&#x27;)&#125;) 生命周期vue2.x的生命周期vue3.0的生命周期 Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名： beforeDestroy改名为 beforeUnmount destroyed改名为 unmounted Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下： beforeCreate===&gt;setup() created=======&gt;setup() beforeMount ===&gt;onBeforeMount mounted=======&gt;onMounted beforeUpdate===&gt;onBeforeUpdate updated =======&gt;onUpdated beforeUnmount ==&gt;onBeforeUnmount unmounted =====&gt;onUnmounted 自定义hook函数 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。 类似于vue2.x中的mixin。 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。 toRef 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。 语法：const name = toRef(person,&#39;name&#39;) 应用: 要将响应式对象中的某个属性单独提供给外部使用时。 扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person) 其它 Composition APIshallowReactive 与 shallowRef shallowReactive：只处理对象最外层属性的响应式（浅响应式）。 shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。 什么时候使用? 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。 readonly 与 shallowReadonly readonly: 让一个响应式数据变为只读的（深只读）。 shallowReadonly：让一个响应式数据变为只读的（浅只读）。 应用场景: 不希望数据被修改时。 toRaw 与 markRaw toRaw： 作用：将一个由reactive生成的响应式对象转为普通对象。 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。 markRaw： 作用：标记一个对象，使其永远不会再成为响应式对象。 应用场景: 有些值不应被设置为响应式的，例如复杂的第三方类库等。 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。 customRef 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。 实现防抖效果： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt; &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; import &#123;ref,customRef&#125; from &#x27;vue&#x27; export default &#123; name:&#x27;Demo&#x27;, setup()&#123; // let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref //自定义一个myRef function myRef(value,delay)&#123; let timer //通过customRef去实现自定义 return customRef((track,trigger)=&gt;&#123; return&#123; get()&#123; track() //告诉Vue这个value值是需要被“追踪”的 return value &#125;, set(newValue)&#123; clearTimeout(timer) timer = setTimeout(()=&gt;&#123; value = newValue trigger() //告诉Vue去更新界面 &#125;,delay) &#125; &#125; &#125;) &#125; let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref return &#123; keyword &#125; &#125; &#125;&lt;/script&gt; provide 与 inject 作用：实现祖与后代组件间通信 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据 具体写法： 祖组件中： 123456setup()&#123; ...... let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;) provide(&#x27;car&#x27;,car) ......&#125; 后代组件中： 123456setup(props,context)&#123; ...... const car = inject(&#x27;car&#x27;) return &#123;car&#125; ......&#125; 响应式数据的判断 isRef: 检查一个值是否为一个 ref 对象 isReactive: 检查一个对象是否是由 reactive 创建的响应式代理 isReadonly: 检查一个对象是否是由 readonly 创建的只读代理 isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理 Composition API 的优势Options API 存在的问题使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。 Composition API 的优势我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。 新的组件Fragment 在Vue2中: 组件必须有一个根标签 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中 好处: 减少标签层级, 减小内存占用 Teleport 什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 12345678&lt;teleport to=&quot;移动位置&quot;&gt; &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;h3&gt;我是一个弹窗&lt;/h3&gt; &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/teleport&gt; Suspense 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 12import &#123;defineAsyncComponent&#125; from &#x27;vue&#x27;const Child = defineAsyncComponent(()=&gt;import(&#x27;./components/Child.vue&#x27;)) 使用Suspense包裹组件，并配置好default 与 fallback 12345678910111213&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h3&gt;我是App组件&lt;/h3&gt; &lt;Suspense&gt; &lt;template v-slot:default&gt; &lt;Child/&gt; &lt;/template&gt; &lt;template v-slot:fallback&gt; &lt;h3&gt;加载中.....&lt;/h3&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/div&gt;&lt;/template&gt; 其他全局API的转移 Vue 2.x 有许多全局 API 和配置。 例如：注册全局组件、注册全局指令等。 123456789101112//注册全局组件Vue.component(&#x27;MyButton&#x27;, &#123; data: () =&gt; (&#123; count: 0 &#125;), template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;&#125;)//注册全局指令Vue.directive(&#x27;focus&#x27;, &#123; inserted: el =&gt; el.focus()&#125; Vue3.0中对这些API做出了调整： 将全局的API，即：Vue.xxx调整到应用实例（app）上 2.x 全局 API（Vue） 3.x 实例 API (app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties 其他改变 data选项应始终被声明为一个函数。 过度类名的更改： Vue2.x写法 12345678.v-enter,.v-leave-to &#123; opacity: 0;&#125;.v-leave,.v-enter-to &#123; opacity: 1;&#125; Vue3.x写法 123456789.v-enter-from,.v-leave-to &#123; opacity: 0;&#125;.v-leave-from,.v-enter-to &#123; opacity: 1;&#125; 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes 移除v-on.native修饰符 父组件中绑定事件 1234&lt;my-component v-on:close=&quot;handleComponentEvent&quot; v-on:click=&quot;handleNativeClickEvent&quot;/&gt; 子组件中声明自定义事件 12345&lt;script&gt; export default &#123; emits: [&#x27;close&#x27;] &#125;&lt;/script&gt; 移除过滤器（filter） 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。 ……","categories":[{"name":"Vue3.0","slug":"Vue3-0","permalink":"http://example.com/categories/Vue3-0/"}],"tags":[{"name":"Vue-router","slug":"Vue-router","permalink":"http://example.com/tags/Vue-router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"http://example.com/tags/Vue-Cli/"},{"name":"Vue3.0","slug":"Vue3-0","permalink":"http://example.com/tags/Vue3-0/"}]},{"title":"Vue全家桶之webpack详解(四)","slug":"Vue全家桶之webpack详解(四)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T10:19:19.777Z","comments":true,"path":"2022/04/24/Vue全家桶之webpack详解(四)/","link":"","permalink":"http://example.com/2022/04/24/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8Bwebpack%E8%AF%A6%E8%A7%A3(%E5%9B%9B)/","excerpt":"","text":"Vue 配套视频讲解: CoderWhy老师的Vuejs讲解 认识webpack 在ES6之前，我们相要进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发 并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包 而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。 而且不仅仅是 JavaScript 文件，我们的CSS、图片、json文件等等在webpack中都可以被当做模块来使用 这就是webpack模块化的概念 打包 理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了 就是将webpack的各种资源模块进行打包整合成一个或多个包Bundle 并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作 但是打包的操作似乎 grunt/gulp 也可以帮助我们完成，它们有什么不同呢？ 和grunt/gulp的对比grunt / gulp 的核心是 Task 我们可以配置一系列的 task，并且定义 task 要处理的事务(例如ES6,ts转化，图片压缩，scss转成css) 之后让 grunt / gulp 来依次执行这些 task，而且让整个流程自动化 所以 grunt / gulp 也被称为前端自动化任务管理工具 我们来看一个 gulp 的task 下面的 task 就是将 src 下面的所有 js 文件转成 ES5 的语法 并且最终输出到 dist 文件夹中 什么时候用 grunt / gulp 呢？ 如果你都工程模块依赖非常简单，甚至是没有用到模块化的概念 只需要进行简单的合并、压缩，就使用 grunt / gulp 即可 但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack了 安装webpack安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm 安装node.js 老师的版本是 10.13.0 ，我自身安装的是14.15.0版本，所以需要进行卸载 所有nodejs历史版本的链接： https://nodejs.org/dist/ 找到10.13.0，里面是 nodejs V10.13.0所有类型安装文件 .msi 使用这个不用配置环境变量 .zip 解压即可用，但是需要配置环境变量 我这里下载 .msi 后缀文件 双击下载完成的 node-v10.13.0-x64.msi ,点击next 勾选同意 更改为你认为合适的安装路径 点击next npm package manage 表示 npm包管理器 online documentation shortcuts 在线文档快捷方式 Add to Path 添加 node 安装路径到环境变量 这就是.msi 不需要手动添加环境变量的原因，node已经帮我们配置好了 是否勾选工具去编译 native 模块，我们不勾选 点击 install 等待安装完毕 测试使用管理员方式打开dos窗口，输入 node -v 显示如图样式，则安装成功 更改淘宝镜像管理员方式打开DOS窗口，输入 1npm config set registry https://registry.npm.taobao.org 点击回车就更换成功了，可以通过 1npm config get registry 上面命令去查看是否成功，如果返回是 则更换成功 全局安装webpack 在DOS命令窗口中输入 npm install webpack@3.6.0 -g 安装webpack(这里指定版本号3.6.0，因为 vue cli2 依赖该版本) 其中的 -g 代表是全局安装，全局安装可以在电脑任何一个位置执行webpack指令 安装需要3~5分钟，之后出现可以让你输入的命令行就说明安装完成，如下图 在DOS命令窗口输入 1webpack --version 注意是两个横线 如果你看到3.6.0，说明你已经成功安装了webpack3.6.0 准备工作首先创建如下文件和文件夹 dist文件夹： 用于存放之后打包的文件 ```src 12345678910111213141516171819202122232425 文件夹： 用于存放我们写的源文件 - `main.js` 项目的入口文件 - `mathUtils.js` 定义了一些数学工具函数，可以在其他地方引用，并且使用。- `index.html` 浏览器打开展示的首页html- `package.json` 通过 `npm init` 生成的，npm 包管理的文件![在这里插入图片描述](https://img-blog.csdnimg.cn/22f9802338ca4cab862ae54020607e2c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55Sf5ZG95piv5pyJ5YWJ55qE,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center)## js文件的打包现在的 js 文件中使用了模块化的方式进行开发，他们可以直接使用吗？不可以。- 因为如果直接在 index.html 引入这两个 js 文件，浏览器并不识别其中的模块化代码。- 另外，在真实项目当中有许多这样的 js 文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理我们应该使用webpack工具，对多个 js 文件进行打包```jswebpack src/main.js dist/bundle.js 使用打包后的文件打包后会在 dist 文件夹下，生成一个 bundle.js 文件 此文件是 webpack 处理了项目直接文件依赖后生成的一个 js 文件，我们只需要将这个 js 文件在 index.html 中引入即可 1&lt;script src = &quot;./dist/bundle.js&quot;&gt;&lt;/script&gt; 示例例如，我们使用模块化开发两个js文件 之后在 main.js 中进行引入两个js文件，在Termial终端使用 webpack 打包main.js 12// 将src下的main.js 打包到dist目录下然后命名为bundle.jswebpack src/main.js dist/bundle.js 所以我们就知道了，我们以后在 src 下开发，之后让 webpack 打包main.js，然后我们引用打包后的js文件，这就是我们的开发模式。 webpack配置mode节点的可选值123module.exports = &#123; mode: &#x27;development&#x27;, // mode 用来指定构建模式,可选值有 development 和 production&#125; mode 节点的可选值有两个，分别是： development 开发环境 不会堆打包生成的文件进行代码压缩和性能优化 打包速度快，适合在开发阶段使用 production 生产环境 会对打包生成的文件进行代码压缩和性能优化 打包速度很慢，仅适合在项目发布阶段使用 入口和出口每次使用webpack的命令都需要写上入口和出口作为参数，非常麻烦，有没有一种方法可以将者两个参数写到配置中，在运行时，直接读取呢？ 当然可以，就是创建一个 1webpack.config.js 文件 通过 entry 节点指定打包的入口 通过 output 节点指定打包的出口 123456789101112131415const path = require(&#x27;path&#x27;)module.exports = &#123; // 入口:可以是字符串/数组/对象，我们这里的入口只有一个，所以写一个字符串即可 entry: &#x27;./src/main.js&#x27;, // entry: path.join(__dirname,&#x27;./src/index.js&#x27;) // 出口:通常是一个对象,里面至少包含两个重要属性,path 和 filename output :&#123; // 注意: path通常是一个绝对路径 path: path.resolve(__dirname,&#x27;dist&#x27;), // 输出文件目录 filename: &#x27;bundle.js&#x27; &#125;&#125; 这样配置之后我们用 webpack 打包时，就可以直接在终端输入 webpack ，就相当于 webpack src/main.js dist/bundle.js ,虽然看起来简洁，但是这不是我们最终的方式，我们最好的方式在下方有记录 webpack.config.js是 webpack 的配置文件。 webpack 在真正开始打包构建之前，会先读取这个配置文件 ， 从而基于给定的配置，对项目进行打包。 注意：由于 webpack 是基于 node.js 开发出来的打包工具，因此在它的配置文件中，支持使用 node.js 相关的语法和模块进行webpack 的 局部安装webpack既然已经全局安装了 webpack，为什么还要局部安装呢？这是因为我们需要的项目可能是从网上下载下来的，项目中使用的webpack和我们本地的webpack可能版本不同，这就需要在局部安装webpack了 目前，我们使用的webpack是全局的webpack，如果我们想使用局部来打包呢？ 因为一个项目往往依赖特定的webpack版本，全局的版本可能很这个项目的webpack版本不一致，导出打包出现问题。 所以通常一个项目，都有自己局部的webpack。 第一步，项目中需要安装自己局部的webpack 这里我们让局部安装安装 webpack3.6.0 1npm install webpack@3.6.0 --save-dev package.json中定义启动但是，每次执行都敲这么一长串有没有觉得不方便呢？OK，我们可以在package.json的scripts中定义自己的执行脚本。 package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。 首先，会寻找本地的 node_modules/.bin 路径中对应的命令。 如果没有找到，会去全局的环境变量中寻找 在 package.json 文件下有 scripts ，是脚本的意思，我们只需要在下方配置脚本 这样配置完成之后，我们在终端输入 npm run build 也就相当于执行 webpack ，也就相当于执行 webpack src/main.js dist/bundle.js webpack中的loader在实际开发过程中， webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他 非 .js 后缀名结尾的模块 ， webpack 默认处理不了， 需要调用 loader 加载器才可以正常打包 ，否则会报错 loader加载器的作用： 协助 webpack 打包处理特定的文件模块 。比如： css-loader 可以打包处理 .css 相关的文件 less-loader 可以打包处理 .less 相关的文件 babel-loader 可以打包处理 webpack 无法处理的高级 JS 语法 css-loader loader是webpack中一个非常核心的概念。 webpack用来做什么呢？ 在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。 但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。 对于webpack本身的能力来说，对于这些转化是不支持的。 那怎么办呢？给webpack扩展对应的 loader 就可以啦。 loader使用过程： 步骤一：通过 npm 安装需要使用的 loader 步骤二：在 webpack.config.js 中的 modules 关键字下进行配置 css文件处理准备工作项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。 在src目录中，创建一个css文件，其中创建一个normal.css文件。 我们也可以重新组织文件的目录结构，将零散的js文件放在一个js文件夹中。 normal.css 中的代码非常简单，就是将body设置为red 在webpack中文网中有 loader的用法：https://www.webpackjs.com/ css 文件的打包需要用到 style-loader，css-loader 先安装 style-loader，再安装 css-loader 之后在 main.js 引用我们自己的 css 文件，再打包即可 总结步骤： 首先安装 style-loader 和 css-loader 12npm install --save-dev css-loadernpm install style-loader --save-dev 在 webpack.config.js 的 module-&gt; rules 数组中，添加loader规则如下 12345678module: &#123; // 所有第三方文件模块的匹配规则 rules: [ // 文件后缀名的匹配规则 &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27; ] &#125; ] &#125; 其中， test 表示匹配的文件类型，use 表示对应要调用的 loader 注意： use 数组中指定的 loader 顺序是固定的 多个 loader 的调用顺序是：从后往前调用 less-loader如果我们希望在项目中使用less、scss、stylus来写样式，webpack是否可以帮助我们处理呢？ 我们这里以less为例，其他也是一样的。 我们还是先创建一个less文件，依然放在css文件夹中 继续在中文文档里面查看 less-loader 的用法 在 main.js 中进行引用即可 打包 图片文件处理首先，我们在项目中加入两张图片： 一张较小的图片test01.jpg(小于8kb)，一张较大的图片test02.jpeg(大于8kb) 我们会针对这两张图片进行不同的处理 我们先考虑在css样式中引用图片的情况，所以更改 normal.css 中的样式，就是使用背景图片 url-loader图片处理 我们使用 url-loader 来处理，依然先安装 url-loader，然后在 webpack.config.js 中进行配置 再次打包，运行 index.html，就会发现我们的就会发现我们的背景图片显示出来。而仔细观察，你会发现背景图是通过base64显示出来的，这也是limit属性的作用，当图片小于8kb时，对图片进行base64编码 当加载的图片, 小于limit时, 会将图片编译成base64字符串形式. 当加载的图片, 大于limit时, 需要使用file-loader模块进行加载. file-loader大于 limit 的图片，会通过file-loader进行处理 修改图片名称和路径我们发现webpack自动帮助我们生成一个非常长的名字，这是一个32位hash值，目的是防止名字重复，但是，真实开发中，我们可能对打包的图片名字有一定的要求，比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复。 所以，我们可以在options中添加上如下选项： img：文件要打包到的文件夹 name：获取图片原来的名字，放在该位置 hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位 ext：使用图片原来的扩展名 另外，默认情况下，webpack 会将生成的路径直接返回给使用者，但是，我们整个程序是打包在 dist 文件夹下的，所以需要在路径下添加 dist/ （是在出口函数处使用publicPath 设置） babel-loaderwebpack只能打包处理一部分 高级的 JavaScript 语法。对于那些 webpack 无法处理的高级 js 语法，需要借助于 babelbabel-loader 进行打包处理。 如果希望将ES6的语法转成ES5，那么就需要使用 babel-loader 进行打包处理 安装 babel-loader 1npm install -D babel-loader @babel/core @babel/preset-env webpack 配置 webpack.config.js 文件 12345678910111213141516module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /node_modules/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ [&#x27;@babel/preset-env&#x27;, &#123; targets: &quot;defaults&quot; &#125;] ] &#125; &#125; &#125; ]&#125; 重新打包，查看bundle.js文件，发现其中的内容变成了ES5的语法 webpack中的插件 plugin是插件的意思，通常是用于对某个现有的架构进行扩展。 webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等 loader 和 plugin 区别？ loader主要用于转换某些类型的模块，它是一个转换器。 plugin是插件，它是对webpack本身的扩展，是一个扩展器。 plugin 使用步骤： 步骤一：通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装) 步骤二：在webpack.config.js中的plugins中配置插件 添加版权的plugin 该插件的名字叫做 BannerPlugin，属于 webpack 自带的插件。 步骤如下： 在 webpack.config.js 中导入 webpack 1const webpack = require(&#x27;webpack&#x27;); 配置在 plugins 中 123456module.exports = &#123; ... plugins: [ new webpack.BannerPlugin(&#x27;最终版权归aaa所有&#x27;) ]&#125; 打包html的plugin目前，我们的index.html文件是存放在项目的根目录下的。我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用html-webpack-plugin插件 html-webpack-plugin 插件可以为我们做这些事情： 自动生成一个index.html文件(可以指定模板来生成) 将打包的js文件，自动通过script标签插入到body中 安装 1nom install html-webpack-plugin --save-dev 在 webpack.config.js 中导入 HTML 插件 1const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;) 使用插件，修改webpack.config.js文件中plugins部分的内容如下 这里的template表示根据什么模板来生成 index.html 另外，我们需要删除之前在output中添加的publicPath属性，否则插入的script标签中的src可能会有问题 12345678910111213// 1.导入HTML插件,得到一个构造函数const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)// 2.创建HTML插件的实例对象const htmlPlugin = new HtmlPlugin(&#123; template: &#x27;./src/index.html&#x27;, // 指定原文件的存放路径 filename: &#x27;./index.html&#x27;, // 指定生成的文件的存放路径&#125;)module.exports = &#123; mode: &#x27;development&#x27;, plugins: [htmlPlugin], // 通过 plugins 节点,使 htmlPlugin 插件生效 &#125; webpack-dev-serverwebpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。 类似于 node.js 阶段用到的 nodemon 工具，每当修改了源代码， webpack 会自动进行项目的打包和构建 它是一个单独的模块，在webpack中使用之前需要先安装它 1npm install --save-dev webpack-dev-server 修改 package.json -&gt; scripts 中的 dev 命令 open参数表示直接打开浏览器，不加 --open 表示不自动打开服务器 1&quot;dev&quot;: &quot;webpack-dev-server --open&quot; 之后我们就可以通过 npm run dev 来修改我们的代码，而不需要每次修改完代码都进行打包，修改测试完成再通过 npm run build 打包 devserver 节点也是作为webpack中的一个选项，选项本身可以设置如下属性，可以对插件进行更多的配置 12345678910module.exports = &#123; ... ... devServer: &#123; contentBase: &#x27;./dist&#x27;, // 为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist open: true, // 自动打开浏览器 host: &#x27;127.0.0.1&#x27;, // 实时打包所使用的主机地址 port: &#x27;80&#x27;, // 实时打包所使用的端口号,默认是 8080 &#125;&#125; 注意：凡是修改了 webpack.config.js 配置文件，或修改了 package.json 配置文件，必须重启实时打包的服务器，否则最新的配置文件无法生效。 js压缩的Plugin我们使用一个第三方的插件 uglifyjs-webpack-plugin，并且版本号指定 下载 1npm install uglifyjs-webpack-plugin --save-dev 修改 webpack.config.js 文件，使用插件 123456module.exports = &#123; ... plugins: [ new UglifyjsWebpackPlugin() ]&#125; 查看打包后的bunlde.js文件，是已经被压缩过了。 打包发布项目开发完成之后 ，需要使用 webpack 对项目进行打包发布 ，主要原因有以下两点： 开发环境下，打包生成的文件存放于内存中 ，无法获取到最终打包生成的文件 开发环境下，打包生成的文件 不会进行代码压缩和性能优化 为了让项目能够在生产环境中高性能的运行，因此需要对项目进行打包发布。 配置webpack的打包发布在 package.json 文件的 scripts 节点下，新增 build 命令如下 1234567&#123; ... &quot;script&quot;: &#123; &quot;dev&quot;: &quot;webpack serve&quot;, // 开发环境中,运行dev命令 &quot;build&quot;: &quot;webpack --mode production&quot; // 项目发布时,运行 build 命令 &#125;&#125; -- model 是一个参数项，用来指定 webpack 的运行模式 。production 代表生产环境，会对打包生成的文件进行代码压缩和性能优化 。 注意：通过 -- model 指定的参数项，会覆盖 webpack.config.js 中的 model 选项 把JavaScript文件统一生成到js目录中在 webpack.config.js 配置文件的 output 节点中，进行如下的配置 1234567891011121314const path = require(&#x27;path&#x27;)module.exports = &#123; // 入口:可以是字符串/数组/对象，我们这里的入口只有一个，所以写一个字符串即可 entry: path.join(__dirname,&#x27;./src/index.js&#x27;) // 出口:通常是一个对象,里面至少包含两个重要属性,path 和 filename output :&#123; // 注意: path通常是一个绝对路径 path: path.resolve(__dirname,&#x27;dist&#x27;), // 明确告诉 webpack 把生成的 bundle.js 文件存放到 dist 目录下的 js 子目录中 filename: &#x27;js/bundle.js&#x27; &#125;&#125; 把图片文件统一生成到 image 目录中修改 webpack.config.js 中的 url-loader 配置项，新增 outputPath 选项即可指定图片文件的输出路径 1234567891011&#123; test: /\\.jpg|png|gif$/, use: &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 22228, // 明确指定把打包生成的图片文件,存储到 dist 目录下的 image 文件夹中 outputPath: &#x27;image&#x27;, &#125; &#125;&#125; 自动清理 dist 目录下的旧文件为了在每次打包发布时自动清理掉 dist 目录中的旧文件 ，可以安装并配置 clean-webpack-plugin 插件 安装插件 1npm install clean-webpack-plugin --save-dev 按需导入插件，得到插件的构造函数后，创建插件的实例对象 12const &#123;CleanWebpackPlugin&#125; = require(&#x27;clean-webpack-plugin&#x27;)const cleanPlugin = new CleanWebpackPlugin() 把创建的 cleanPlugin 插件实例对象挂载到 plugins 节点中 1234567891011// 1.导入清理插件插件,得到插件的构造函数后，创建插件的实例对象const &#123;CleanWebpackPlugin&#125; = require(&#x27;clean-webpack-plugin&#x27;)// 2.创建HTML插件的实例对象const cleanPlugin = new CleanWebpackPlugin()// 3.把创建的 cleanPlugin 插件实例对象,挂载到 plugins 节点中,使插件生效module.exports = &#123; mode: &#x27;development&#x27;, plugins: [htmlPlugin,cleanPlugin], // 挂载插件 &#125; Source Map生产环境遇到的问题前端项目在投入生产环境之前，都需要对JavaScript 源代码进行 压缩混淆 ，从而减小文件的体积，提高文件的加载效率。此时就不可避免的产生了另一个问题： 对压缩混淆之后的代码除错（debug）是一件极其困难的事情 变量被替换成 没有任何语义 的名称 空行和注释被剔除 什么是SourceMap Source Map就是一个信息文件，里面储存着位置信息 也就是说， Source Map 文件中存储着压缩混淆后的代码所对应的转换前的位置 。 有了它，出错的时候，除错工具将直接显示原始代码 ，而不是转换后的代码 ，能够极大的方便后期的调试。 webpack 开发环境下的 Source Map在开发环境下，webpack 默认启用了 Source Map 功能。当程序运行出错时，可以直接在控制台提示错误行的位置，并定位到具体的源代码。 默认Source Map的问题开发环境下默认生成的 SourceMap ，记录的是 生成后的代码的位置 。会导致运行时报错的行数与源代码的行数不一致的问题。示意图如下： 解决默认Source Map的问题开发环境下，推荐在 webpack.config.js 中添加如下的配置，即可保证运行时报错的行数与源代码的行数保持一致 123456module.exports = &#123; mode: &#x27;development&#x27;, // eval-source-map 仅限在&#x27;开发模式&#x27;下使用,不建议在 &#x27;生产模式&#x27;下使用。 // 此选项生产的 Source Map 能够保证运行时报错的行数与源代码的行数保持一致 devtool: &#x27;eval-source-map&#x27;,&#125; webpack生产环境下的SourceMap在生产环境下 ，如果省略了 devtool 选项 ，则最终生成的文件中不包含 Source Map 。这能够防止原始代码通过Source Map 的形式暴露给别有所图之人。 只定位行数不暴露源码在生产环境下，如果 只想定位报错的具体行数 ，且不想暴露源码 。此时可以将 devtool 的值设置为nosources-source-map 。实际效果如图所示： 定位行数且暴露源码在生产环境下，如果想在定位报错行数的同时，展示具体报错的源码。此时可以将 devtool 的值设置为 source-map。实际效果如图所示： Source Map最佳实践 开发环境下 建议把 devtool 的值设置为 eval-source-map 好处：可以精准定位到具体的错误行 生产环境下 建议关闭 Source Map 或将 devtool 的值设置为 nosources-source-map 好处：放置源码泄露，提高网站的安全性 总结：实际开发中不需要自己配置webpack 实际开发中会使命令行工具（俗称 CLI）一键生成 带有 webpack 的项目 开箱即用，所有 webpack 配置项都是现成的 但是我们仍需要了解配置项的基本概念","categories":[{"name":"Vue2.0-webpack","slug":"Vue2-0-webpack","permalink":"http://example.com/categories/Vue2-0-webpack/"}],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/tags/Vue2-0/"},{"name":"Vue-router","slug":"Vue-router","permalink":"http://example.com/tags/Vue-router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"},{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"http://example.com/tags/Vue-Cli/"}]},{"title":"Vue全家桶之Vue-router路由(五)","slug":"Vue全家桶之Vue-router路由(五)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T10:23:07.785Z","comments":true,"path":"2022/04/24/Vue全家桶之Vue-router路由(五)/","link":"","permalink":"http://example.com/2022/04/24/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8BVue-router%E8%B7%AF%E7%94%B1(%E4%BA%94)/","excerpt":"","text":"配套视频讲解: CoderWhy老师的Vuejs讲解 ✍后端路由阶段早期的网站开发整个HTML页面是由服务器来渲染的，服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示.但是, 一个网站, 这么多页面服务器如何处理呢? 一个页面有自己对应的网址, 也就是URL. URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理. Controller进行各种处理, 最终生成HTML或者数据, 返回给前端. 这就完成了一个IO操作. 上面的这种操作, 就是后端路由 当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端 这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化. 后端路由的缺点: 一种情况是整个页面的模块由后端人员来编写和维护的. 另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码 而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情. ✍前端路由阶段前后端分离阶段： 随着Ajax的出现, 有了前后端分离的开发模式. 后端只提供API来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中. 这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上. 前端路由的核心是什么呢？ 改变URL，但是页面不进行整体的刷新。 Vue-router中的编程式声明式导航&amp;编程式导航在浏览器中，点击链接实现导航的方式，叫做声明式导航。例如： 普通网页中点击 &lt;a&gt; 链接，vue 项目中点击 &lt;router-link&gt; 都属于声明式导航 在浏览器中，调用API方法实现导航的方式，叫做编程式导航。例如： 普通网页中调用 location.href 跳转到新页面的方式，属于编程式导航 编程式导航APIvue-router 提供了许多编程式导航的 APIAPI，其中最常用 的导航 API 分别是： ```this.$router.push(‘hash地址’) 12345 - 跳转到指定 hash 地址，并增加一条历史记录- ``` this.$router.replace(&#x27;hash地址&#x27;) 跳转到指定的 hash 地址，并替换掉当前的历史记录 ```this.$router.go(数值n) 1234567891011121314151617181920212223242526272829 - 实现导航历史前进、后退### $router.push通过 `this.$router.push()` 方法，可以跳转到指定的 hash 地址，从而展示对应的组件页面。示例代码如下```html&lt;template&gt; &lt;div&gt; &lt;h3&gt;Home组件&lt;/h3&gt; &lt;button @click=&quot;gotoMovie&quot;&gt; 跳转到Movie页面&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Home&quot;, methods: &#123; gotoMovie() &#123; this.$router.push(&#x27;/movie&#x27;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; $router.replace调用 this.$router.replace() 方法，可以跳转到指定的 hash 地址，从而展示对应的组件页面。 push 和 replace 的区别： push 会增加一条历史记录 replace 不会增加历史记录，而是替换掉当前的历史记录 $router.go调用 this.$router.go() 方法，可以在浏览历史中前进和后退，示例代码如下： 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h3&gt;Home组件&lt;/h3&gt; &lt;button @click=&quot;goBack&quot;&gt; 后退 &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Home&quot;, methods: &#123; goBack()&#123; // 后退到之前的组件页面 this.$router.go(-1) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 注意，一般只会前进和后退一层页面，因此 vue-router 提供了如下两个便捷方法： ```$router.back() 12345 - 在历史记录中， 后退到上一个页面2. ``` $router.forward() 在历史记录中， 前进到下一个页面 URL的hash URL的hash也就是锚点(#), 本质上是改变 window.location 的 href 属性. 我们可以通过直接赋值 location.hash 来改变 href , 但是页面不发生刷新 HTML5的history模式history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面. pushState replaceState history.go() history.back() 等价于 history.go(-1) history.forward() 等价于 history.go(1) 这三个接口等同于浏览器界面的前进后退 认识vue-router目前前端流行的三大框架, 都有自己的路由实现: Angular的ngRouter React的ReactRouter Vue的vue-router 我们的重点是vue-router，vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。我们可以访问其官方网站对其进行学习：https://router.vuejs.org/zh/ vue-router是基于路由和组件的 路由用于设定访问路径, 将路径和组件映射起来 在vue-router的单页面应用中, 页面的路径的改变就是组件的切换 安装vue-router因为我们已经学习了webpack, 后续开发中我们主要是通过工程化的方式进行开发的.所以在后续, 我们直接使用npm来安装路由即可. 安装 vue-router 1npm install vue-router --save 在模块化工程中使用它(因为它是一个插件，所以可以通过 Vue.use() 来安装路由功能) 123456789101112131415161718// 1.导入 Vue 和 VueRouter 的包import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;// 2.调用 Vue.use() 函数,把 VueRouter 安装为 Vue 的插件Vue.use(VueRouter)// 3.创建 VueRouter 对象const routes = [ ]const router = new VueRouter(&#123; // 配置路由和组件之间的应用关系 routes&#125;)// 4.将 router 对象传入到 vue 实例export default router 使用 vue-router 的步骤 创建路由组件 配置路由映射：组件和路径映射关系 使用路由: 通过&lt;router-link&gt;和&lt;router-view&gt; 声明路由链接和占位符 使用vue-router在 src 源代码目录下，新建 router/index.js 路由模块，并初始化如下的代码： 如果我们在使用 vueCLI 初始化项目的时候安装了 router，那么就会自动生成 router 文件夹，里面有 index.js 如下 123456789101112131415161718192021222324252627// 1.导入 Vue 和 VueRouter 的包import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;// 2.调用 Vue.use() 函数,把 VueRouter 安装为 Vue 的插件Vue.use(VueRouter)// 3.创建 VueRouter 对象const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: () =&gt; import(/* webp ackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;) &#125;]const router = new VueRouter(&#123; // 配置路由和组件之间的应用关系 routes&#125;)// 4.将 router 对象传入到 vue 实例export default router 在 src/ main.js 入口文件中，导入并挂载路由模块。示例代码如下： 123456789101112import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// 1.导入路由模块import router from &#x27;./router&#x27;Vue.config.productionTip = falsenew Vue(&#123; // 2.挂载路由模块 router, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 在App.vue 主组件中使用路由 &lt;router-link&gt; 声明路由链接 &lt;router-view&gt; 占位符 123456789101112131415&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;nav&quot;&gt; &lt;!-- 1.定义路由链接 --&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;!-- 2.定义路由的占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; 声明路由匹配规则在 src/router/index.js 路由模块中，通过 routes 数组 声明路由的匹配规则。示例代码如下： 1234567891011121314const routes = [ // 在 routes 数组中,声明路由的匹配规则 &#123; // path 表示要匹配的 hash 地址,component 表示要展示的路由组件 path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, // 这种方式是路由懒加载,后面有解释 component: () =&gt; import(/* webp ackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;) &#125;] HTML5的History模式我们前面说过改变路径的方式有两种： URL 的 hash HTML5的history 默认情况下，路径的改变使用的 URL 的hash，如果希望使用 HTML5 的 history 模式，进行如下配置即可： 1const router = new VueRouter(&#123; routes, mode: &#x27;history&#x27;&#125;) router-link补充 在前面的 &lt;router-link&gt; 中,我们只是使用了一个属性：to ，用于指定跳转的路径 &lt;router-link&gt; 还有一些其他属性 tag : tag可以指定 &lt;router-link&gt; 之后渲染成什么组件，比如下面的代码会被渲染成一个 &lt;li&gt; 元素,而不是 &lt;a&gt; ```js 123456789101112131415161718192021222324252627282930313233343536 - `replace` ： replace 不会留下 history 记录，所以指定 replace 的情况下，后退键返回不能返回到上一个页面中 - `active-class` ：当 `&lt;router-link&gt;` 对应的路由匹配成功时,会自动给当前元素设置一个 `router-link-active` 的 class，设置 active-class 可以修改默认的名称(一般不需要改) - 在进行高亮显示的导航菜单或者底部tabbar时, 会使用到该类 - 但是通常不会修改类的属性, 会直接使用默认的router-link-active即可```html&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;nav&quot;&gt; &lt;!-- 1.定义路由链接 --&gt; &lt;router-link to=&quot;/&quot; tag=&#x27;li&#x27; replace &gt;Home&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;!-- 2.定义路由的占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;,&#125;&lt;/script&gt;&lt;style&gt;.router-link-active &#123; color: red&#125;&lt;/style&gt; 路由代码跳转有时候, 页面的跳转可能需要执行对应的JavaScript代码, 这个时候, 就可以使用第二种跳转方式了，也就是编程式导航。 例如，我们需要点击按钮然后进行跳转 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;nav&quot;&gt; &lt;button @click=&quot;homeClick&quot;&gt;首页&lt;/button&gt; &lt;button @click=&quot;aboutClick&quot;&gt;关于&lt;/button&gt; &lt;/button&gt; &lt;/div&gt; &lt;!-- 2.定义路由的占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, methods: &#123; homeClick()&#123; this.$router.push(&#x27;/home&#x27;) &#125;, aboutClick()&#123; this.$router.push(&#x27;/about&#x27;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Vue-router的常见用法路由重定向路由重定向 指的是：用户在访问 地址 A 的时候， 强制用户跳转 到地址 C ，从而展示特定的组件页面。 通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向： 12345678910const router = new VueRouter(&#123; // 在 routes 数组中,声明路由的匹配规则 routes: [ // 当用户访问 / 的时候,通过 redirect 属性跳转到 /home 对应的路由规则 &#123; path: &#x27;/&#x27;, redirect: &#x27;/home&#x27; &#125; ]&#125;) 路由的懒加载 首先, 我们知道路由中通常会定义很多不同的页面. 这个页面最后被打包在哪里呢? 一般情况下, 是放在一个js文件中. 但是, 页面这么多放在一个js文件中, 必然会造成这个页面非常的大 如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况. 如何避免这种情况呢? 使用路由懒加载就可以了 路由懒加载做了什么？ p路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块. 只有在这个路由被访问到的时候, 才加载对应的组件 懒加载的方式在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割 1const Home = () =&gt; import(&#x27;../components/Home.vue&#x27;) 例如： 1234567891011121314151617181920212223242526272829303132333435// 配置路由相关的信息import VueRouter from &#x27;vue-router&#x27;import Vue from &#x27;vue&#x27;// 原始路由加载// import Home from &#x27;../components/Home&#x27;// 路由懒加载(推荐)const Home = () =&gt; imports(&#x27;../components/Home&#x27;)// 1.通过Vue.use(插件), 安装插件Vue.use(VueRouter)const routes = [ // 在 routes 数组中,声明路由的匹配规则 &#123; // path 表示要匹配的 hash 地址,component 表示要展示的路由组件 path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: () =&gt; import(&#x27;../views/About.vue&#x27;) &#125;]const router = new VueRouter(&#123; // 配置路由和组件之间的应用关系 routes, mode: &#x27;history&#x27;, linkActiveClass: &#x27;active&#x27;&#125;)// 3.将router对象传入到Vue实例export default router 动态路由动态路由指的是：把 Hash 地址中可变的部分 定义为参数项 ，从而提高路由规则的复用性 。 在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径 /user/aaaa 或 /user/id 除了有前面的 /user 之外，后面还跟上了用户的 ID 这种 path 和 Component 的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式) 我们在 src/router/index.js 中配置路由 使用英文的冒号 (: ) 来定义路由的参数项 1234&#123; path: &#x27;/user/:id&#x27;, component: User&#125; 在 User.vue 组件中,可以获取到 id 的值，从而展示对应的用户详情 123456789101112131415&lt;template&gt; &lt;div class=&#x27;User-container&#x27;&gt; &lt;h2&gt;User组件 ------- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;User&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 我们也可以在主组件 App.vue 中获取到路由参数 1&lt;router-link v-bind:to=&quot; &#x27;/user&#x27; + id &quot;&gt;用户&lt;/router-link&gt; 使用props接收路由参数为了简化路由参数的获取形式，vue-router 允许在 路由规则中开启 props 传参 。 我们在 src/router/index.js 中配置路由 定义路由规则时，声明 props: true 选项 12345&#123; path: &#x27;/user/:id&#x27;, component: User, props: true&#125; 在 User.vue 组件中,可以获取到 id 的值，从而展示对应的用户详情 1234567891011121314151617&lt;template&gt; &lt;div class=&#x27;User-container&#x27;&gt; &lt;!-- 2.直接使用 props 中接收的路由参数 --&gt; &lt;h2&gt;User组件 ------- &#123;&#123;id&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;User&quot;, props: [&#x27;id&#x27;] // 1.使用 props 接收路由规则中匹配到的参数项&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在主组件 App.vue 中也可以获取到路由参数 1&lt;router-link v-bind:to=&quot; &#x27;/user&#x27; + id &quot;&gt;用户&lt;/router-link&gt; 传递参数的方式传递参数主要有两种类型: params 和 query params的类型 配置路由格式: /router/:id 传递的方式: 在path后面跟上对应的值 传递后形成的路径: /router/123, /router/abc query的类型 配置路由格式: /router, 也就是普通配置 传递的方式: 对象中使用query的key作为传递方式 传递后形成的路径: /router?id=123, /router?id=abc 例如我们在 App.vue 里面向其他路由 ‘/profile’ 传递对象参数 1234&lt;router-link :to =&quot;&#123; path:&#x27;/profile&#x27;, query:&#123;name: &#x27;why&#x27;,age: 18,height:1.88&#125;&#125;&quot;&gt; &lt;/router-link&gt; 在 Profile.vue 组件里面也可以取到传递过来的参数 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是 Profile 组件&lt;/h2&gt; &lt;h2&gt;&#123;&#123;this.$route.query&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;this.$route.query.name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;this.$route.query.age&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;this.$route.query.height&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Profile&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 嵌套路由嵌套路由是一个很常见的功能，比如在home页面中, 我们希望通过 /home/news 和 /home/message 访问一些内容， 一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件 实现嵌套路由有两个步骤： 创建对应的子组件, 并且在路由映射中配置对应的子路由.，使用 children 属性声明子路由规则 在组件内部使用&lt;router-view&gt;标签. 我们创建好 HomeNews.vue 和 HomeMessage.vue 后，在 src/router/index.js 中配置路由映射 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 配置路由相关的信息import VueRouter from &#x27;vue-router&#x27;import Vue from &#x27;vue&#x27;// 路由懒加载(推荐)const Home = () =&gt; imports(&#x27;../components/Home&#x27;)const HomeNews = () =&gt; imports(&#x27;../components/HomeNews&#x27;)const HomeMessage = () =&gt; imports(&#x27;../components/HomeMessage&#x27;)// 1.通过Vue.use(插件), 安装插件Vue.use(VueRouter)const routes = [ &#123; // Home 页面的路由规则(父级路由规则) path: &#x27;/home&#x27;, name: &#x27;Home&#x27;, component: Home, // 通过 children 属性,嵌套声明子级路由规则 children: [ &#123; // 默认路径 path: &#x27;&#x27;, redirect: &#x27;news&#x27; &#125;， &#123; path: &#x27;news&#x27;, component: HomeNews &#125;, &#123; path: &#x27;messages&#x27;, component: HomeMessage &#125; ] &#125;,]const router = new VueRouter(&#123; // 配置路由和组件之间的应用关系 routes, mode: &#x27;history&#x27;, linkActiveClass: &#x27;active&#x27;&#125;)// 3.将router对象传入到Vue实例export default router 由于我们的 HomeNews.vue 和 HomeMessage.vue 都是 Home 路由的子路由，所以我们需要在 Home.vue 进行显示 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;h2&gt;Home 组件&lt;/h2&gt; &lt;!-- 1.在 Home 组件中,声明两个子路由链接 --&gt; &lt;router-link to=&quot;/home/news&quot;&gt;新闻&lt;/router-link&gt; &lt;router-link to=&quot;/home/message&quot;&gt;消息&lt;/router-link&gt; &lt;!-- 2.在关于页面中,声明子路由的占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Home&#x27;,&#125;&lt;/script&gt;&lt;style&gt; &lt;/style&gt; $ router 和$route的区别 $router 为VueRouter实例，想要导航到不同URL，则使用$router.push方法 $route为当前 router 跳转对象里面可以获取name、path、query、params等 导航守卫 我们来考虑一个需求: 在一个SPA应用中, 如何改变网页的标题呢? 网页标题是通过&lt;title&gt;来显示的, 但是SPA只有一个固定的HTML, 切换不同的页面时, 标题并不会改变. 但是我们可以通过JavaScript来修改&lt;title&gt;的内容 window.document.title = &#39;新的标题&#39; 那么在Vue项目中, 在哪里修改? 什么时候修改比较合适呢? 普通的修改方式: 我们比较容易想到的修改标题的位置是每一个路由对应的组件.vue文件中. 通过mounted声明周期函数, 执行对应的代码进行修改即可. 但是当页面比较多时, 这种方式不容易维护(因为需要在多个页面执行类似的代码). 有没有更好的办法呢? 使用导航守卫即可. 什么是导航守卫? vue-router提供的导航守卫主要用来监听监听路由的进入和离开的. vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 配置路由相关的信息import VueRouter from &#x27;vue-router&#x27;import Vue from &#x27;vue&#x27;import Home from &#x27;../components/Home&#x27;import About from &#x27;../components/About&#x27;import User from &quot;../components/User&quot;;// 1.通过Vue.use(插件), 安装插件Vue.use(VueRouter)// 2.创建VueRouter对象const routes = [ &#123; path: &#x27;&#x27;, // redirect重定向 redirect: &#x27;/home&#x27; &#125;, &#123; path: &#x27;/home&#x27;, component: Home, meta: &#123; title: &#x27;首页&#x27; &#125; &#125;, &#123; path: &#x27;/about&#x27;, component: About, meta: &#123; title: &#x27;关于&#x27; &#125; &#125;,]const router = new VueRouter(&#123; // 配置路由和组件之间的应用关系 routes, mode: &#x27;history&#x27;,&#125;)// 前置钩子hook(前置回调)router.beforeEach((to,form,next) =&gt; &#123; // 从 from 跳转到 to window.document.title = to.meta.title next()&#125;)// 3.将router对象传入到Vue实例export default router 全局前置守卫每次发生路由的导航跳转时，都会触发全局前置守卫 。因此，在全局前置守卫中，程序员可以对每个路由进行访问权限的控制： 123456789101112const router = new VueRouter(&#123; routes,&#125;)// 调用路由实例对象的 beforeEach 方法,即可声明&quot;全局前置守卫&quot;// 每次发生路由跳转的时候,都会触发这个方法// 全局前置守卫router.beforeEach((to,from,next)=&gt; &#123; // to 是将要访问的路由的信息对象 // from 是将要离开的路由的信息对象 // next 是一个函数,调用 next()表示放行,允许这次路由导航&#125;) 导航钩子的三个参数解析： to ： 即将要进入的目标的路由对象 from：当前导航即将要离开的路由对象 next：调用该方法后，才能进入下一个钩子 注意：如果是前置钩子beforeEach，必须要调用 next() 函数，如果是后置钩子afterEach，不需要主动调用 next() 函数 next函数的三种调用方式 当前用户拥有后台主页的访问权限，直接放行： next() 当前用户没有后台主页的访问权限，强制其跳转到登录页面：next(&#39;/login&#39;) 当前用户没有后台主页的访问权限，不允许跳转到后台主页：next(false)","categories":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/categories/Vue2-0/"}],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/tags/Vue2-0/"},{"name":"Vue-router","slug":"Vue-router","permalink":"http://example.com/tags/Vue-router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"http://example.com/tags/Vue-Cli/"}]},{"title":"Vue全家桶之VueX(六)","slug":"Vue全家桶之VueX(六)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T10:24:32.899Z","comments":true,"path":"2022/04/24/Vue全家桶之VueX(六)/","link":"","permalink":"http://example.com/2022/04/24/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8BVueX(%E5%85%AD)/","excerpt":"","text":"配套视频讲解: CoderWhy老师的Vuejs讲解 Vuex什么是Vuex官方解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 状态管理到底是什么？ 状态管理模式、集中式存储管理这些名词听起来就非常高大上，让人捉摸不透。 其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。 然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。 那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？ 等等，如果是这样的话，为什么官方还要专门出一个插件Vuex呢？难道我们不能自己封装一个对象来管理吗？ 当然可以，只是我们要先想想VueJS带给我们最大的便利是什么呢？没错，就是响应式。 如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢？当然也可以，只是自己封装可能稍微麻烦一些。 不用怀疑，Vuex就是为了提供这样一个在多个组件间共享状态的插件，用它就可以了。 单界面的状态管理我们知道，要在单个组件中进行状态管理是一件非常简单的事情。 这图片中的三种东西如下： State：状态 View：视图层，可以针对 State 的变化，显示不同的信息 Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的变化 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;div&gt;当前计数:&#123;&#123;counter&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;counter+=1&quot;&gt;+1&lt;/button&gt; &lt;button @click=&quot;counter-=1&quot;&gt;-1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;HelloWorld&quot;, data() &#123; return &#123; counter: 0 &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在这个案例中，我们有木有状态需要管理呢？没错，就是个数counter。 counter需要某种方式被记录下来，也就是我们的State。 counter目前的值需要被显示在界面中，也就是我们的View部分。 界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态，也就是我们的Actions 这不就是上面的流程图了吗？ ok，先安装 vuex 1npm install vuex --save 多界面状态管理Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？ 多个视图都依赖同一个状态(一个状态改了，多个界面需要进行更新) 不同界面的 Actions 都想修改同一个状态(Home.vue 需要修改，Profile.vue 也需要修改这个状态) 也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个视图，但是也有一些状态(状态a/状态b/状态c)属于多个视图共同想要维护的 状态1/状态2/状态3 你放在自己的房间中，你自己管理自己用，没问题。 但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！ 没错，Vuex就是为我们提供这个大管家的工具。 全局单例模式(大管家) 我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。 之后，你们每个视图，按照我规定好的规定，进行访问和修改等操作。 这就是Vuex背后的基本思想。 我们创建一个文件夹 src/store，并且在其中创建一个 index.js 文件，代码如下： 12345678910111213141516171819202122232425262728293031import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state)&#123; state.count++ &#125;, decrement(state)&#123; state.count-- &#125; &#125;, actions: &#123; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;)// 导出store对象export default store 其次，我们让所有的Vue组件都可以使用这个store对象 来到 src/main.js文件，导入store对象，并且挂载到new Vue中 123456789101112import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;// 1.导入store对象import store from &#x27;./store&#x27;new Vue(&#123; el: &#x27;#app&#x27;, // 2.挂载 store store, render: h =&gt; h(App)&#125;) 这样，在其他Vue组件中，我们就可以通过 this.$store的方式，获取到这个store对象了 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt; &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-1&lt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, components: &#123; &#125;, computed: &#123; count: function() &#123; return this.$store.state.count &#125; &#125;, methods: &#123; increment: function() &#123; this.$store.commit(&#x27;increment&#x27;) &#125;, decrement: function() &#123; this.$store.commit(&#x27;decrement&#x27;) &#125; &#125;&#125;&lt;/script&gt; 使用步骤小结： 提取出一个公共的 store 对象，用于保存在多个组件中共享的状态 将 store 对象放置在 new Vue 对象中，这样可以保证在所有的组件中都可以使用到 在其他组件中使用 store 对象中保存的状态即可 通过 this.$store.state 属性的方式来访问状态 通过 this.$store.commit(&#39;mutation中方法&#39;) 来修改状态 我们通过提交 mutation 的方式，而非直接改变 store.state.count 这是因为 Vuex 可以更明确的追踪状态的变化，所以不要直接改变 store.state.count 的值 安装vue-devtools 在 Chrome 网上应用商店 搜索 devtools 选择 vue.js devtools ，添加即可 Vuex核心概念Vuex有几个比较核心的概念: State Getters Mutation Action Module State 单-状态树Vuex提出使用单一状态树, 什么是单一状态树呢？ 英文名称是Single Source of Truth，也可以翻译成单一数据源。 我用一个生活中的例子做一个简单的类比，我们知道，在国内我们有很多的信息需要被记录，比如上学时的个人档案，工作后的社保记录，公积金记录，结婚后的婚姻信息，以及其他相关的户口、医疗、文凭、房产记录等等（还有很多信息）。 这些信息被分散在很多地方进行管理，有一天你需要办某个业务时(比如入户某个城市)，你会发现你需要到各个对应的工作地点去打印、盖章各种资料信息，最后到一个地方提交证明你的信息无误。这种保存信息的方案，不仅仅低效，而且不方便管理，以及日后的维护也是一个庞大的工作(需要大量的各个部门的人力来维护，当然国家目前已经在完善我们的这个系统了)。 这个和我们在应用开发中比较类似：如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难，所以Vuex也使用了单一状态树来管理应用层级的全部状态。单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。 Getters基本使用有时候，我们需要从 store 中获取一些 state 变异后的状态，比如下面的 Store 12345678910111213141516171819202122232425262728293031323334import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; students: [ &#123;id: 100,name: &#x27;why&#x27;,age: 18&#125;, &#123;id: 111,name: &#x27;kobe&#x27;,age: 21&#125;, &#123;id: 112,name: &#x27;lucy&#x27;,age: 25&#125;, &#123;id: 113,name: &#x27;lilei&#x27;,age: 2&#125;, ] &#125;, mutations: &#123; &#125;, actions: &#123; &#125;, getters: &#123; // 获取年龄大于20的学生对象 more20stu(state)&#123; return state.students.filter(s =&gt; s.age &gt;20) &#125; &#125;, modules: &#123; &#125;&#125;)// 导出store对象export default store 这样我们在其他 .vue 组件中也可以拿到年龄大于20的学生对象 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;$store.getters.more20stu&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// @ is an alias to /srcimport HelloWorld from &#x27;@/components/HelloWorld.vue&#x27;export default &#123; name: &#x27;Home&#x27;, components: &#123; HelloWorld &#125;&#125;&lt;/script&gt; ①、Getters作为参数和传递参数如果我们已经有了一个获取所有年龄大于20岁学生的列表 getters，那么代码可以这样来写 1234567891011121314151617181920212223242526272829303132333435363738import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; students: [ &#123;id: 100,name: &#x27;why&#x27;,age: 18&#125;, &#123;id: 111,name: &#x27;kobe&#x27;,age: 21&#125;, &#123;id: 112,name: &#x27;lucy&#x27;,age: 25&#125;, &#123;id: 113,name: &#x27;lilei&#x27;,age: 2&#125;, ] &#125;, mutations: &#123; &#125;, actions: &#123; &#125;, getters: &#123; // 获取年龄大于20的学生对象 more20stu(state)&#123; return state.students.filter(s =&gt; s.age &gt;20) &#125;, // 获取年龄大于20的学生个数 more20stuLength(state,getters) &#123; return getters.more20stu.length &#125; &#125;, modules: &#123; &#125;&#125;)// 导出store对象export default store getters 默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; students: [ &#123;id: 100,name: &#x27;why&#x27;,age: 18&#125;, &#123;id: 111,name: &#x27;kobe&#x27;,age: 21&#125;, &#123;id: 112,name: &#x27;lucy&#x27;,age: 25&#125;, &#123;id: 113,name: &#x27;lilei&#x27;,age: 2&#125;, ] &#125;, mutations: &#123; &#125;, actions: &#123; &#125;, getters: &#123; // 获取年龄大于20的学生对象 more20stu(state)&#123; return state.students.filter(s =&gt; s.age &gt;20) &#125;, // 获取年龄大于20的学生个数 more20stuLength(state,getters) &#123; return getters.more20stu.length &#125;, // 让用户自己决定获取年龄大于多少 moreAgeStu(state) &#123; return function(age)&#123; return state.students.filter(s =&gt; s.age &gt; age) &#125; &#125; &#125;, modules: &#123; &#125;&#125;)// 导出store对象export default store 这样我们在其他 .vue 组件中就可以传入年龄数值筛选了 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;$store.getters.more20stu&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;$store.getters.more20stuLength&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;$store.getters.moreAgeStu(8)&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// @ is an alias to /srcimport HelloWorld from &#x27;@/components/HelloWorld.vue&#x27;export default &#123; name: &#x27;Home&#x27;, components: &#123; HelloWorld &#125;&#125;&lt;/script&gt; Mutation状态更新 Vuex的store状态的更新唯一方式：提交Mutation Mutation主要包括两部分： 字符串的事件类型（type） 一个回调函数(handler) 该回调函数的第一个参数就是 state mutation 的定义方式 12345678910111213141516171819202122232425262728293031import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state)&#123; state.count++ &#125;, decrement(state)&#123; state.count-- &#125; &#125;, actions: &#123; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;)// 导出store对象export default store 通过 mutation 更新 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-1&lt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, components: &#123; &#125;, computed: &#123; count: function() &#123; return this.$store.state.count &#125; &#125;, methods: &#123; increment: function() &#123; this.$store.commit(&#x27;increment&#x27;) &#125;, decrement: function() &#123; this.$store.commit(&#x27;decrement&#x27;) &#125; &#125;&#125;&lt;/script&gt; ①Mutation传递参数在通过mutation更新数据的时候, 有可能我们希望携带一些额外的参数，参数被称为 mutation 的载荷(Payload) 12345678910111213141516171819202122232425262728293031323334import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state)&#123; state.count++ &#125;, decrement(state)&#123; state.count-- &#125;, incrementCount(state,count)&#123; state.counter += count &#125; &#125;, actions: &#123; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;)// 导出store对象export default store 我们在其他 .vue 组件中来修改状态 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-1&lt;&lt;/button&gt; &lt;button @click=&quot;addCount(5)&quot;&gt;+5&lt;/button&gt; &lt;button @click=&quot;addCount(10)&quot;&gt;+5&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, components: &#123; &#125;, methods: &#123; increment: function() &#123; this.$store.commit(&#x27;increment&#x27;) &#125;, decrement: function() &#123; this.$store.commit(&#x27;decrement&#x27;) &#125;, addCount(count)&#123; this.$store.commit(&#x27;incrementCount&#x27;,count) &#125; &#125;&#125;&lt;/script&gt; 但是如果参数不是一个呢？ 比如我们有很多参数需要传递，这个时候，我们通常会以对象的形式传递，也就是 payload 是一个对象。 这个时候可以再从对象中取出相关的信息。 123456789101112131415161718192021222324252627282930313233import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; students: [ &#123;id: 100,name: &#x27;why&#x27;,age: 18&#125;, &#123;id: 111,name: &#x27;kobe&#x27;,age: 21&#125;, &#123;id: 112,name: &#x27;lucy&#x27;,age: 25&#125;, &#123;id: 113,name: &#x27;lilei&#x27;,age: 2&#125;, ] &#125;, mutations: &#123; &#125;, actions: &#123; &#125;, getters: &#123; &#125;, modules: &#123; addStudent(state,stu)&#123; state.students.push(stu) &#125; &#125;&#125;)// 导出store对象export default store 我们在其他 .vue 组件中来修改状态 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-1&lt;&lt;/button&gt; &lt;button @click=&quot;addCount(5)&quot;&gt;+5&lt;/button&gt; &lt;button @click=&quot;addCount(10)&quot;&gt;+5&lt;/button&gt; &lt;button @click=&quot;addStudent&quot;&gt;添加学生&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, components: &#123; &#125;, methods: &#123; increment: function() &#123; this.$store.commit(&#x27;increment&#x27;) &#125;, decrement: function() &#123; this.$store.commit(&#x27;decrement&#x27;) &#125;, addCount(count)&#123; this.$store.commit(&#x27;incrementCount&#x27;,count) &#125;, addStudent()&#123; const stu = &#123;id: 114, name: &#x27;alan&#x27;,age: 35&#125; this.$store.commit(&#x27;addStudent&#x27;,stu) &#125; &#125;&#125;&lt;/script&gt; ②Mutation提交风格上面的通过 commit 进行提交是一种普通的方式 Vue 还提供了另外一种风格，它是一个包含 type 属性的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; students: [ &#123;id: 100,name: &#x27;why&#x27;,age: 18&#125;, &#123;id: 111,name: &#x27;kobe&#x27;,age: 21&#125;, &#123;id: 112,name: &#x27;lucy&#x27;,age: 25&#125;, &#123;id: 113,name: &#x27;lilei&#x27;,age: 2&#125;, ] &#125;, mutations: &#123; &#125;, actions: &#123; &#125;, getters: &#123; &#125;, modules: &#123; incrementCount(state,payload)&#123; state.counter += payload.count &#125; &#125;&#125;)// 导出store对象export default store&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-1&lt;&lt;/button&gt; &lt;button @click=&quot;addCount(5)&quot;&gt;+5&lt;/button&gt; &lt;button @click=&quot;addCount(10)&quot;&gt;+5&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, components: &#123; &#125;, methods: &#123; increment: function() &#123; this.$store.commit(&#x27;increment&#x27;) &#125;, decrement: function() &#123; this.$store.commit(&#x27;decrement&#x27;) &#125;, addCount(count)&#123; // 1.普通的提交封装 // this.$store.commit(&#x27;incrementCount&#x27;,count) // 2.特殊的提交封装 this.&amp;store.commit(&#123; type: &#x27;incrementCount&#x27;, count &#125;) &#125;, &#125;&#125;&lt;/script&gt; ③Mutation响应规则Vuex 的 store 中的 state 是响应式的，当 state 中的数据发生改变时，Vue组件会自动更新 这就要求我们必须遵守一些Vuex对应的规则： 提前在 store 中初始化好所需的属性 当给 state 中的对象添加新属性时，使用下面的方式 方式一：使用 Vue.set(obj,&#39;newProp&#39;,123) 方式二：用新对象给就旧对象重新赋值 例如： 我们在 index.js 中增加 info 状态 12345678910111213const store = new Vuex.Store(&#123; state: &#123; info: &#123; name: &#x27;why&#x27;, age: 18 &#125; &#125;, mutations: &#123; // 方式一:Vue.set() Vue.set(state.info,&#x27;height&#x27;,payload.height) // 方式二:给 info 赋值一个新的对象 state.info = &#123;...state.info,&#x27;height&#x27;:payload.height&#125; &#125;&#125;) 我们在其他 .vue 组件中修改状态 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;我的个人信息: &#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;updateInfo&quot;&gt;更新信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, components: &#123; &#125;, computed: &#123; info()&#123; return this.$store.state.info &#125; &#125;, methods: &#123; updateInfo()&#123; this.$store.commit(&#x27;updateInfo&#x27;,&#123;height: 1.88&#125;) &#125; &#125; &#125;&lt;/script&gt; ④Mutation常量类型-概念我们来考虑下面的问题： 在 mutation 中，我们定义了很多事件类型(也就是其中的方法名称) 当我们的项目增大时，Vuex 管理的状态越来越多，需要更新状态的情况越来越多, 那么意味着 Mutation 中的方法越来越多 方法过多，使用者需要花费大量的精力的经历去记住这些方法，甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况. 如何避免上述问题呢？ 在各种Flux实现中, 一种很常见的方案就是使用常量替代 Mutation 事件的类型 我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然. 具体怎么做呢？ 我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量 定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称. 我们在src/store 下新建 mutation-types.js 1exports const UPDATA_INFO = &#x27;UPDATE_INFO&#x27; 这样的话我们在 index.js 中可以导入 1234567891011121314151617181920212223242526272829303132import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;import * as types from &#x27;./mutation-types&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; info: &#123; name: &#x27;why&#x27;, age: 18 &#125; &#125;, mutations: &#123; [tyoes.UPDATE_INFO](state,payload)&#123; state.info = &#123;...state.info,&#x27;height&#x27;:payload.height&#125; &#125; &#125;, actions: &#123; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;)// 导出store对象export default store 我们在其他 .vue 组件中也可以使用 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;我的个人信息: &#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;updateInfo&quot;&gt;更新信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;UPDATE_INFO&#125; from &quot;./store/mutation-types&quot;export default &#123; name: &#x27;App&#x27;, components: &#123; &#125;, computed: &#123; info()&#123; return this.$store.state.info &#125; &#125;, methods: &#123; updateInfo()&#123; this.$store.commit(&#x27;UPDATE_INFO&#x27;,&#123;height: 1.88&#125;) &#125; &#125; &#125;&lt;/script&gt; ⑤Mutation同步函数通常情况下，Vuex 要求我们 Mutation 中的方法必须是同步方法 主要的原因是当我们使用 devtools 时，devtools 可以帮助我们捕捉 mutation 的快照 但是如果是异步操作，那么 devtools 将不能很好的追踪这个操作什么时候会被完成。 So,通常情况下,不要在 mutation 中进行异步的操作 Action的基本定义我们强调，不要在 Mutation 中进行异步操作，但是某些情况，我们确实希望在 Vuex 中进行一些异步操作，比如网络请求，必然是异步的，Action 类似于 Mutation，但是是用来代替 Mutation 进行异步操作的。 12345678910111213141516171819202122232425262728293031import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state)&#123; state.count++ &#125; &#125;, actions: &#123; increment(context)&#123; context.commit(&#x27;increment&#x27;) &#125; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;)// 导出store对象export default store context 是什么？ context 是 store 对象具有相同方法和属性的对象 也就是说，我们可以通过 context 去进行 commit 相关的操作，也可以获取 context.state 等。 ①Action的分发在Vue组件中，如果我们调用 action 中的方法，那么就需要使用 dispatch 12345methods: &#123; increment()&#123; this.$store.dispatch(&#x27;increment&#x27;) &#125;&#125; 同样的，也是支持传递 payload 123456789101112131415161718192021222324252627282930313233343536373839methods: &#123; increment()&#123; this.$store.dispatch(&#x27;increment&#x27;, &#123;cCount: 5&#125;) &#125;&#125;import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;// 1.安装插件Vue.use(Vuex)// 2.创建对象const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state,payload)&#123; state.count += payload.cCount &#125; &#125;, actions: &#123; increment(context,payload)&#123; setTimeout(() =&gt; &#123; context.commit(&#x27;increment&#x27;,payload) &#125;,1000) &#125; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;)// 导出store对象export default store ②Action返回的Promise在 Action 中，我们可以将异步操作放在一个 Promise 中，并且在成功或者失败之后，调用对应的 resolve 或 reject 12345678910actions: &#123; increment(context)&#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; context.commit(&#x27;increment&#x27;) resolve() &#125;,1000) &#125;) &#125;&#125;, 在其他 Vue 组件中 1234567methods: &#123; increment() &#123; this.$store.dispatch(&#x27;increment&#x27;).then(res =&gt; &#123; console.log(&#x27;完成了更新操作&#x27;); &#125;) &#125;&#125; 认识 ModuleModule 是模块的意思，为什么在 Vuex 中我们要使用模块呢？ Vue 使用单一状态树，那么也意味着很多状态都会交给 Vuex 来管理 当应用变得非常复杂时， store 对象就有可能变得相当臃肿 为了解决这个问题，Vuex 允许我们将 store 分割成某块，而每个模块拥有自己的 state、mutations、action、getters等 12345678910111213141516171819202122const ModuleA = &#123; state: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, getters: &#123;&#125;&#125;const ModuleB = &#123; state: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;,&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态","categories":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/categories/Vue2-0/"}],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/tags/Vue2-0/"},{"name":"Vue-router","slug":"Vue-router","permalink":"http://example.com/tags/Vue-router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"http://example.com/tags/Vue-Cli/"}]},{"title":"Vue全家桶之Vue基础指令(一)","slug":"Vue全家桶之Vue基础指令(一)","date":"2022-04-24T05:02:11.000Z","updated":"2022-04-25T10:20:24.139Z","comments":true,"path":"2022/04/24/Vue全家桶之Vue基础指令(一)/","link":"","permalink":"http://example.com/2022/04/24/Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8BVue%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4(%E4%B8%80)/","excerpt":"","text":"✍、目录总览 配套视频讲解: CoderWhy老师的Vuejs讲解 Vue简介什么是Vue官方给出的概念： Vue 是一套 用于构建用户界面的前端框架 Vue的特性vue框架的特性，主要体现在如下两方面： 数据驱动视图 双向数据绑定 数据驱动视图在使用了 vue 的页面 中， vue 会监听数据的变化 ，从而 自动 重新渲染页面的结构。示意图如下： 好处：当页面数据发生变化时，页面会自动重新渲染！ 注意：数据驱动视图是 单向的数据绑定 。 双向数据绑定在填写表单 时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下 ，自动 把用户填写的内容 同步到 数据源中。示意图如下： 好处：开发者不再需要手动操作DOM 元素，来获取表单元素最新的值！ MVVM MVVM是 vue 实现 数据驱动视图 和双向数据绑定 的核心原理。 MVVM 指的是 Model 、View 和 ViewiewModelodel， 它把每个 HTML 页面都拆分成了这三个部分，如图所示： View 层： 视图层 在我们前端开发中，通常就是DOM层 主要的作用是给用户展示各种信息 Model层： 数据层 数据可能是我们固定的死数据，更多的是来自于我们服务器，从网络上请求下来的数据。 VueMode层： 视图模型层 视图模型层是 View 和 Model 沟通的桥梁 一方面它实现了数据绑定，将 Model 的改变实时的反应到 View 中 另一方面它实现了 DOM监听，当DOM 发生一些事件(点击、滚动等)时，可以监听到，并在现需要的情况下改变对应的 Data MVVM工作原理ViewModel作为 MVVM 的核心 ，是它把当前页面的 数据源 （ModelModel）和 页面的结构 （View ）连接在了一起。 当数据源发生变化 时，会被 ViewModel 监听到， VM 会根据最新的数源 自动更新 页面的结构 当表单元素的值发生变化 时，也会被 VM 监听到， VM 会把变化过后最新的值 自动同步 到 Model 数 Vue的版本当前， vue 共有 3 个大版本，其中： 2.x版本的 vue 是目前企业级项目开发中的主流版本 3.x版本的 vue 于 2020 -09 -19 发布，生态还不完善，尚未在企业级项目开发中普及和推广 1.x版本的 vue 几乎被淘汰，不再建议学习与使用 总结： 3.x版本的 vue 是未来企业级项目开发的趋势； 2.x版本的 vue 在未来（ 1 ~ 2 年内）会被逐渐淘汰； Vue.js安装安装Vue的方式有很多，主要有三种： 方式一：直接CDN引入方式一：直接CDN引入 你可以选择引入开发环境版本还是生产环境版本 12345&lt;!-- 开发环境版本,包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!-- 生产环境版本,优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12&quot;&gt;&lt;/script&gt;1234 方式二：下载和引入 开发环境下载：https://vuejs.org/js/vue.js 生产环境下载：https://vuejs.org/js/vue.min.js 下载完成后使用 script 标签的外部引用即可 方式三：NPM安装12# 最新稳定版$ npm install vue 后续通过 webpack 和 CLI 的使用时我们使用该方式。 Vue的基本使用 导入 vue.js 的script 的脚本文件 在页面中声明一个将要被 vue 所控制的 DOM 区域 创建 vue 实例对象 Hello Vue12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 2.在页面中声明一个将要被 vue 所控制的DOM区域 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;!-- 1.导入 vue.js 的script脚本文件 --&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 3.创建 vue 实例对象 const app = new Vue(&#123; // 3.1 指定当前 vue 实例将要控制页面的哪个区域 el: &#x27;#app&#x27;, // 3.2 指定 Model 数据源 data: &#123; message: &#x27;HelloVue！&#x27;, &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;时 我们来阅读 JavaScript 代码，会发现创建了一个 Vue 对象。 创建Vue对象的时候，传入了一些 options : 1&#123;&#125; &#123;&#125;中包含了 el 属性：该属性决定了这个 Vue对象挂载到哪一个元素上，很明显，我们这里是挂载到了 id 为 app 的元素上。 ```{} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 中包含了 data 属性：该属性中通常会存储一些数据 - 这些数据可以是我们直接定义出来的，比如像上面的 `HelloVue!` - 也可能是来自网络，从服务器加载的- 浏览器执行代码的流程： - 执行到 12~15行代码显示出对应的 HTML - 执行第20行代码创建 Vue 实例，并且对原HTML进行解析和修改- 并且，目前我们的代码是可以做到响应式的。## 基本代码与MVVM的关系![在这里插入图片描述](https://img-blog.csdnimg.cn/70aac1faedf04d99996c19f3a27553d4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA55Sf5ZG95piv5pyJ5YWJ55qE,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)## Vue列表显示现在，我们来展示一个更加复杂的数据：数据列表。比如我们现在从服务器请求过来一个列表，希望展示到HTML中。HTML代码中，使用 `v-for`指令。该指令后面会详细讲解，这里先学会使用。```html&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in movies&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, movies: [&#x27;星际穿越&#x27;, &#x27;大话西游&#x27;, &#x27;少年派&#x27;, &#x27;盗梦空间&#x27;] &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 这样我们就再也不需要在JavaScript 代码中完成DOM的拼接相关操作了。 而且，最重要的是，它还是响应式的，也就是说，当我们数组中的数据发生改变时，界面会自动改变。 创建Vue实例传入的optionsn我们在创建Vue实例的时候，传入了一个对象options，这个 options 可以包含这些选项： ```el 123456 - 类型：string | HTMLElement - 作用：决定之后 Vue实例会管理哪一个DOM- ``` data 类型：Object | Function(组件当中 data 必须是一个函数) 作用：Vue 实例对应的数据对象 ```methods 12345678910111213141516171819202122232425262728293031323334353637383940 - 类型：&#123;[key：string]: Function&#125; - 作用：定义属于 Vue 的一些方法，可以在其他地方调用，也可以在指令中使用。# Vue指令指令和 vue 为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。vue中的指令 按照不同的用途 可以分为如下6大类：- 内容渲染指令- 属性绑定指令- 事件绑定指令- 双向绑定指令- 条件渲染指令- 列表渲染指令## 内容渲染指令### v-text- `v-text` 作用和 `Mustache` 比较相似：都是用于将数据显示在界面中- v-text 通常情况下，接收一个string类型```html&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 v-text = &quot;message&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &#x27;你好啊,李银河！&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 插值 语法 v-once但是，在某些情况下，我们可能不希望界面随意的跟随改变，这个时候，我们就可以使用一个Vue的指令 v-once： 该指令后面不需要跟任何表达式(比如之前的 v-for 后面是有跟表达式的) 该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变 1234567891011121314&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2 v-once&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &#x27;亲爱的,你好呀！&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-html 可以使用v-html指令 该指令后面往往会跟上一个string类型 会将string的html解析出来并且进行性渲染 1234567891011121314151617&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 v-html = &quot;link&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; link: &#x27;&lt;a href = &quot;www.baidu.com&quot;&gt;百度一下&lt;/a&gt;&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-pre该指令的作用是用于跳过这个元素和它子元素的编译过程，用于显示原本的 Mustache 语法 比如下面的代码： 第一个 h2 元素中的内容会被编译解析出来对应的内容 第二个 h2 元素中会直接显示 12345678910111213141516&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &#x27;Hello World&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-cloak🎈 在某些情况下，我们浏览器可能会直接显示出未编译的Mustache标签。 cloak：斗篷 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; setTimeout(function()&#123; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;亲爱的&#x27; &#125; &#125;) &#125;,1000) &lt;/script&gt; 例如上述代码，当代码执行到第 2 行时，需要去解析我们的 message ，从而执行 8~15行代码。但是8 ~ 15行代码是一个定时器，需要1s后才执行，那么此时不会解析 message，从而网页中直接显示原格式 &#123;&#123;message&#125;&#125; ,之后1 s 之后再进行解析，从而显示亲爱的 我们如何解决上述问题呢？ 加上v-clock 属性,并加上css。 Vue解析之前有 v-clock 属性时，让其不显示 Vue解析之后没有v-clock 属性，再让其显示 123456789101112131415161718192021222324252627 &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot; v-cloak&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 在vue解析之前, div中有一个属性v-cloak // 在vue解析之后, div中没有一个属性v-cloak setTimeout(function () &#123; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125; &#125;) &#125;, 1000)&lt;/script&gt;&lt;/body&gt; 属性绑定指令v-bind我们可以利用 v-bind :class来绑定一些 class 属性，v-bind为元素的属性动态绑定属性值。 前面的指令主要作用是将值插入到我们的模板的内容当中，但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定。 比如动态绑定a元素的 href 属性 比如动态绑定img元素的 src 属性 这个时候，我们可以使用 v-bind 指令： 作用：动态绑定属性 缩写：: v-bind 用于绑定一个或多个属性值，或者向另一个组件传递 props 值(这个之后组件介绍) 比如通过 Vue 实例中的 data 绑定元素的 src 和 href ，代码如下 1234567891011121314151617181920&lt;body&gt; &lt;div id=&quot;app&quot; v-cloak&gt; &lt;!-- 错误的做法：这里不可以使用mustache语法 --&gt; &lt;!-- &lt;img src=&quot;&#123;&#123;logoURL&#125;&#125;&quot; alt=&quot;&quot;&gt; --&gt; &lt;!-- 正确的做法，使用v-bind指令 --&gt; &lt;a v-bind:href = &quot;link&quot;&gt;Vuejs官网&lt;/a&gt; &lt;imh v-bind:src = &quot;logoURL&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; let app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; logoURL: &#x27;https://cn.vuejs.org/images/logo.svg&#x27;, link: &#x27;https://cn.vuejs.org/&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; ①v-bind 语法糖v-bind 有一个对应的语法糖，也就是简写方式。开发中就用这个，因为这样更简洁 简写方式如下： 123456789&lt;div id=&quot;app&quot; v-cloak&gt; &lt;a v-bind:href = &quot;link&quot;&gt;Vuejs官网&lt;/a&gt; &lt;!--简写形式如下--&gt; &lt;a :href = &quot;link&quot;&gt;Vuejs官网&lt;/a&gt; &lt;imh v-bind:src = &quot;logoURL&quot; alt=&quot;&quot;&gt; &lt;!--简写形式如下--&gt; &lt;imh :src = &quot;logoURL&quot; alt=&quot;&quot;&gt; &lt;/div&gt; ②v-bind绑定class很多时候，我们希望动态的来切换 class，比如 当数据为某个状态时，字体显示红色 当数据另一个状态时，字体显示黑色 绑定 class 有两种方式： 对象语法 数组语法 对象语法 对象语法的含义是：class 后面跟的是一个对象 对象语法有下面这些用法 直接通过{}绑定一个类 123&lt;h2 :class=&quot;&#x27;&#123;active&#x27;: isActive&#125;&quot;&gt; Hello World&lt;/h2&gt; 也可以通过判断，传入多个值 123&lt;h2 :class=&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;&gt; Hello World&lt;/h2&gt; 和普通类同时存在，并不冲突 注：如果 isActive 和 isLine 都为true，那么会有 title/active/line 三个类 123&lt;h2 class=&quot;title&quot; :class=&quot;&#123;active: isActive, line: isLine&#125;&quot;&gt; Hello World&lt;/h2&gt; 如果过于复杂，可以放在一个methods或者computed中 123&lt;h2 class=&quot;title&quot; v-bind:class=&quot;getClasses()&quot;&gt; Hello World&lt;/h2&gt; 数组语法 数组语法的含义是：class 后面跟的是一个数组 数组语法有下面这些用法： 直接通过{}绑定一个类 123&lt;h2 :class=&quot;[&#x27;active&#x27;]&quot;&gt; Hello World&lt;/h2&gt; 也可以传入多个值 123&lt;h2 :class=&quot;[&#x27;active&#x27;, &#x27;line&#x27;]&quot;&gt; Hello World&lt;/h2&gt; 和普通的类同时存在，并不冲突,会有 title/active/line 三个类 123 &lt;h2 class=&quot;title&quot; :class=&quot;[active, line]&quot;&gt; Hello World&lt;/h2&gt; 如果过于复杂，可以放在一个methods或者computed中 123&lt;h2 class=&quot;title&quot; :class=&quot;getClasses()&quot;&gt; Hello World&lt;/h2&gt; ③v-bind绑定style我们可以利用 v-bind: style 来绑定一些CSS内联样式 在写CSS属性名的时候，比如 font-size 我们可以使用驼峰式：fontSize 或短横线分隔(记得用单引号括起来) &#39;font-size&#39; 绑定style有两种方式 对象语法 数组语法 对象语法 123&lt;h2 :style=&quot;&#123;fontSize: finalSize + &#x27;px&#x27;, backgroundColor: finalColor&#125;&quot;&gt; Hello World&lt;/h2&gt; style 后面跟的是一个对象类型 后面的 key 是 css 属性名称 对象的 value 是具体赋的值，值可以来自于 data 中的属性 数组语法 123&lt;h2 :style=&quot;[baseStyle, baseStyle1]&quot;&gt; &#123;&#123;message&#125;&#125;&lt;/h2&gt; style 后面跟的是一个数组类型 多个值以逗号分割即可 计算属性计算属性指的是通过一系列运算之后，最终得到一个属性值。这个动态计算出来的属性值可以被模板结构或methods 方法使用。 我们知道，在模板中可以直接通过插值语法显示一些data中的数据。 但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示 比如我们有firstName和lastName两个变量，我们需要显示完整的名称 但是如果多个地方都需要显示完整的名称，我们就需要写多个&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; 我们可以将上面的代码换成计算属性，计算属性是写在实例的computed选项中的 1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Lebron&#x27;, lastName: &#x27;James&#x27; &#125;, // computed: 计算属性() computed: &#123; fullName: function () &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125; &#125;, methods: &#123; getFullName() &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 虽然计算属性在声明的时候被定义为方法，但是计算属性的本质是一个属性 计算属性会缓存计算的结果，只有计算属性依赖的数据变化时，才会重新进行运算 ①计算属性的复杂操作12345678910111213141516171819202122232425262728293031323334353637&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;总价格: &#123;&#123;totalPrice&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; books: [ &#123;id: 110, name: &#x27;Unix编程艺术&#x27;, price: 119&#125;, &#123;id: 111, name: &#x27;代码大全&#x27;, price: 105&#125;, &#123;id: 112, name: &#x27;深入理解计算机原理&#x27;, price: 98&#125;, &#123;id: 113, name: &#x27;现代操作系统&#x27;, price: 87&#125;, ] &#125;, computed: &#123; totalPrice: function () &#123; let result = 0 for (let i=0; i &lt; this.books.length; i++) &#123; result += this.books[i].price &#125; return result // for (let i in this.books) &#123; // this.books[i] // &#125; // // for (let book of this.books) &#123; // // &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; ②计算属性的setter和getter🎈每一个计算属性都包含一个getter和一个setter，只是我们一般基本不用 setter方法 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Kobe&#x27;, lastName: &#x27;Bryant&#x27; &#125;, computed: &#123; // 之前的写法 // fullName: function () &#123; // return this.firstName + &#x27; &#x27; + this.lastName // &#125; // 计算属性一般是没有set方法, 只读属性. // 完整写法 fullName: &#123; set: function() &#123; &#125;, get: function () &#123; return this.firstName + &#x27; &#x27; + this.lastName &#125; &#125;, &#125; &#125;)&lt;/script&gt; ③计算属性的缓存我们可能会考虑这样的一个问题： methods 和 computed 看起来都可以实现我们的功能，那么为什么还要多一个计算属性这个东西呢？ 原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=&quot;app&quot;&gt; &lt;!--1.直接拼接: 语法过于繁琐--&gt; &lt;h2&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;&lt;/h2&gt; &lt;!--2.通过定义methods--&gt; &lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--&lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;--&gt; &lt;!--3.通过computed--&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Kobe&#x27;, lastName: &#x27;Bryant&#x27; &#125;, methods: &#123; getFullName: function () &#123; console.log(&#x27;getFullName&#x27;); return this.firstName + &#x27; &#x27; + this.lastName &#125; &#125;, computed: &#123; fullName: function () &#123; console.log(&#x27;fullName&#x27;); return this.firstName + &#x27; &#x27; + this.lastName &#125; &#125; &#125;)&lt;/script&gt; 事件监听指令在前端开发中，我们经常需要监听点击、拖拽、键盘事件等等，这个时候需要使用 v-on 作用：绑定事件监听器 缩写：@ DOM对象 vue事件绑定 onclick v-on:click oninput v-on:input onkeyup v-on:keyup 注意：通过 v-on 绑定的事件处理函数，需要 在 methods 节点 中进行声明 v-on基础这里，我们用一个监听按钮的点击事件，来简单看看 v-on 的使用 下面的代码中，我们使用了 v-on:click=&quot;counter++&quot; 另外，我们可以将事件指向一个在 methods 中定义的函数 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;!--方式一:直接绑定事件--&gt; &lt;button v-on:click=&quot;counter++&quot;&gt;+&lt;/button&gt; &lt;button v-on:click=&quot;counter--&quot;&gt;-&lt;/button&gt; &lt;!--方式二:将事件指向在methods中定义的函数--&gt; &lt;button v-on:click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;!-- 语法糖 --&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; counter: 0 &#125;, methods: &#123; // v-on绑定的事件处理函数,需要在 methods 中进行声明 increment() &#123; // 事件处理函数的名字 this.counter++ // this表示当前new出来的 vue实例对象,通过this可以访问到data中的数据 &#125;, decrement() &#123; this.counter-- &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-on①事件参数对象当通过 methods 中定义方法，以供 @click 调用时，需要注意参数问题 在原生的 DOM 事件绑定中，可以在事件处理函数的形参处，接收事件参数对象 event 。同理，在 v-on 指令 （简写为 @)所绑定的事件处理函数中，同样可以接收到事件参数对象 event ，示例代码如下 123456789101112131415161718192021222324&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;count 的值为 &#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;button v-on:click=&quot;addCount&quot;&gt; +1 &lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; counter: 0 &#125;, methods: &#123; // v-on绑定的事件处理函数,需要在 methods 中进行声明 addCount(e)&#123; // 接收事件参数对象 event,简写为e const nowBgColor = e.target.style.backgroundColor e.target.style.backgroundColor = nowBgColor === &#x27;red&#x27;?&#x27;&#x27; : &#x27;red&#x27; this.count += 1 &#125; &#125; &#125;) &lt;/script&gt; ②绑定事件并传参在使用 v-on 指令绑定事件时，可以使用 ( 进行传参，示例代码如下： 1234567891011121314151617181920212223&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;count 的值为 &#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;addNewCount(2)&quot;&gt; +2 &lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; counter: 0 &#125;, methods: &#123; // v-on绑定的事件处理函数,需要在 methods 中进行声明 addNewCount(step)&#123; // 在形参处用 step 接收传递过来的参数值 this.count += step &#125; &#125;) &lt;/script&gt;&lt;/body&gt; ③$event$event 是 vue 提供的 特殊变量 ，用来表示 原生的事件参数对象 event 。$event 可以解决事件参数对象 event 被覆盖的问题。示例用法如下： 12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h3&gt;count 的值为 &#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;addNewCount(2,$event)&quot;&gt; +2 &lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; counter: 0 &#125;, methods: &#123; // v-on绑定的事件处理函数,需要在 methods 中进行声明 addNewCount(step,e)&#123; // 在形参处用 e 接收传递过来的原生事件参数对象 $event const nowBgColor = e.target.style.backgroundColor e.target.style.backgroundColor = nowBgColor === &#x27;red&#x27;?&#x27;&#x27; : &#x27;red&#x27; this.count += 1 &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 这里借用 coderwhy老师的讲解记录： 情况一： 如果该方法不需要额外参数，那么方法后的（）可以不添加 注意：如果方法本身中有一个参数，那么会默认将原生事件 event 参数传递进去 情况二：如果需要同时传入某个参数，同时需要 event 时，可以通过 $event 传入事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id=&quot;app&quot;&gt; &lt;!--1.事件调用的方法没有参数--&gt; &lt;button @click=&quot;btn1Click()&quot;&gt;按钮1&lt;/button&gt; &lt;button @click=&quot;btn1Click&quot;&gt;按钮1&lt;/button&gt; &lt;!--2.在事件定义时, 写方法时省略了小括号, 但是方法本身是需要一个参数的, 这个时候, Vue会默认将浏览器生产的event事件对象作为参数传入到方法--&gt; &lt;button @click=&quot;btn2Click(123)&quot;&gt;按钮2.1&lt;/button&gt; &lt;button @click=&quot;btn2Click()&quot;&gt;按钮2.2&lt;/button&gt; &lt;button @click=&quot;btn2Click&quot;&gt;按钮2&lt;/button&gt; &lt;!--3.方法定义时, 我们需要event对象, 同时又需要其他参数--&gt; &lt;!-- 在调用方式, 如何手动的获取到浏览器参数的event对象: $event--&gt; &lt;button @click=&quot;btn3Click(abc, $event)&quot;&gt;按钮3&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, abc: 123 &#125;, methods: &#123; btn1Click() &#123; console.log(&quot;btn1Click&quot;); &#125;, btn2Click(event) &#123; console.log(&#x27;--------&#x27;, event); &#125;, btn3Click(abc, event) &#123; console.log(&#x27;++++++++&#x27;, abc, event); &#125; &#125; &#125;) // 如果函数需要参数,但是没有传入, 那么函数的形参为undefined // function abc(name) &#123; // console.log(name); // &#125; // // abc()&lt;/script&gt;&lt;/body&gt; v-on修饰符在某些情况下，我们拿到 event 的目的可能是进行一些事件处理，Vue 提供了修饰符来帮助我们方便的处理一些事件 .stop - 调用 event.stopPropagation() .prevent - 调用 event.preventDefault() .&#123;keyCode|keyAlias&#125; - 只当事件是从特定键触发时才触发回调 .native - 监听组件根元素的原生事件 .once - 只触发一次回调 123456789&lt;!-- 触发click点击事件,组织 a 链接的默认跳转行为--&gt;&lt;a href = &quot;https://www.baidu.com&quot; @click.prevent=&quot;onLinkClick&quot;&gt;百度首页&lt;/a&gt;&lt;!-- 按键修饰符 --&gt;&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt;&lt;!-- 只有在 `key` 是 `Esc` 时调用 `vm.clearInput()` --&gt;&lt;input @keyup.esc=&quot;clearInput&quot;&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--1. .stop修饰符的使用--&gt; &lt;div @click=&quot;divClick&quot;&gt; aaaaaaa &lt;button @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;!--2. .prevent修饰符的使用--&gt; &lt;br&gt; &lt;form action=&quot;baidu&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click.prevent=&quot;submitClick&quot;&gt; &lt;/form&gt; &lt;!--3. .监听某个键盘的键帽,这里只监听了enter回车键--&gt; &lt;input type=&quot;text&quot; @keyup.enter=&quot;keyUp&quot;&gt; &lt;!--4. .once修饰符的使用--&gt; &lt;button @click.once=&quot;btn2Click&quot;&gt;按钮2&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27; &#125;, methods: &#123; btnClick() &#123; console.log(&quot;btnClick&quot;); &#125;, divClick() &#123; console.log(&quot;divClick&quot;); &#125;, submitClick() &#123; console.log(&#x27;submitClick&#x27;); &#125;, keyUp() &#123; console.log(&#x27;keyUp&#x27;); &#125;, btn2Click() &#123; console.log(&#x27;btn2Click&#x27;); &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 条件渲染指令条件渲染指令用来辅助开发者按需控制 DOM 的显示与隐藏 。 1v - if`、`v-else-if`、`v-else 这三个指令与JavaScript的条件语句 if、else、else if 类似 Vue 的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件 v-if12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2 v-if=&quot;isShow&quot;&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, isShow: true &#125; &#125;) &lt;/script&gt;&lt;/body&gt; v-if的原理： v-if 后面的条件为 false时，对应的元素以及子元素不会渲染 也就是根本没有对应的标签出现在DOM中 v-else12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;h2 v-if=&quot;isShow&quot;&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &lt;div&gt;abc&lt;/div&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt; &lt;h1 v-else&gt;isShow为false时, 显示我&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, isShow: false &#125; &#125;)&lt;/script&gt; v-if和v-else-if和v-else1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt; &lt;h2 v-if=&quot;score&gt;=90&quot;&gt;优秀&lt;/h2&gt; &lt;h2 v-else-if=&quot;score&gt;=80&quot;&gt;良好&lt;/h2&gt; &lt;h2 v-else-if=&quot;score&gt;=60&quot;&gt;及格&lt;/h2&gt; &lt;h2 v-else&gt;不及格&lt;/h2&gt; &lt;h1&gt;&#123;&#123;result&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; score: 99 &#125;, computed: &#123; result() &#123; let showMessage = &#x27;&#x27;; if (this.score &gt;= 90) &#123; showMessage = &#x27;优秀&#x27; &#125; else if (this.score &gt;= 80) &#123; showMessage = &#x27;良好&#x27; &#125; // ... return showMessage &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 条件渲染案例我们来做一个简单的小案例： 用户再登录时，可以切换使用用户账号登录还是邮箱地址登录 12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;span v-if=&quot;isUser&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户账号&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;用户账号&quot;&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for=&quot;email&quot;&gt;用户邮箱&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;用户邮箱&quot;&gt; &lt;/span&gt; &lt;button @click=&quot;isUser = !isUser&quot;&gt;切换类型&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isUser: true &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 案例小问题 上述案例有一个小问题： 如果我们在输入内容的情况下，切换了类型，我们会发现文字依然显示之前输入的内容，但是按到道理讲，我们应该切换到另一个 input 元素中了，在另一个 input元素中，我们并没有输入内容，为什么会出现这个问题呢？ 问题解答： 这是因为 Vue 在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素 在上面的案例中，Vue内部会发现原来的input元素不再使用，直接作为else中的input来使用了。 解决方案： 如果我们不希望 Vue 出现类似重复利用的问题，可以给对应的 input 添加 key 并且我们需要保证 key 的不同 12345678910111213141516171819202122232425&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;span v-if=&quot;isUser&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户账号&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;用户账号&quot; key=&quot;username&quot;&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for=&quot;email&quot;&gt;用户邮箱&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;用户邮箱&quot; key=&quot;email&quot;&gt; &lt;/span&gt; &lt;button @click=&quot;isUser = !isUser&quot;&gt;切换类型&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isUser: true &#125; &#125;)&lt;/script&gt;&lt;/body&gt; v-showv-show的用法和v-if非常相似，也用于决定一个元素是否渲染： v-if 指令会 动态地创建或移除 DOM 元素 ，从而控制元素在页面上的显示与隐藏 v-show 指令会动态为元素 添加或移除 style=“display: none;” 样式 ，从而控制元素的显示与隐藏 开发中如何选择呢？ 当需要在显示与隐藏之间切片很频繁时，使用 v-show 当只有一次切换时，通过 v-if 列表渲染指令 vue提供了 v-for 列表渲染指令，用来辅助开发者基于一个数组来循环渲染一个列表结构 v-for 指令需要使 用 item in items 形式的特殊语法，其中： items 是待循环的数组 item 是被循环的每一项 12345678910111213141516171819202122&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;姓名是: &#123;&#123;tiem.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [ //列表数据 &#123;id:1 ,name: &#x27;zhangsan&#x27;&#125; &#123;id:2 ,name: &#x27;lisi&#x27;&#125; ] &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 遍历数组当我们有一组数据需要进行渲染时，就可以使用v-for来完成 v-for的语法类似于 JavaScript 中的 for 循环,v-for 指令还支持一个 可选的 第二个参数，即 当前项的索引 格式： item in items (item,index) in items 12345678910111213141516171819202122&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in list&quot;&gt;索引是:&#123;&#123;index&#125;&#125;,姓名是: &#123;&#123;tiem.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [ //列表数据 &#123;id:1 ,name: &#x27;zhangsan&#x27;&#125; &#123;id:2 ,name: &#x27;lisi&#x27;&#125; ] &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;!--1.在遍历的过程中,没有使用索引值(下标值)--&gt; &lt;ul&gt; &lt;li v-for=&quot;item in names&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--2.在遍历的过程中, 获取索引值--&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in names&quot;&gt; &#123;&#123;index+1&#125;&#125;.&#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; names: [&#x27;why&#x27;, &#x27;kobe&#x27;, &#x27;james&#x27;, &#x27;curry&#x27;] &#125; &#125;)&lt;/script&gt; 注意： v-for 指令中的 item 项和 index 索引 都是形参，可以根据需要进行 重命名 。例如 (user ,i)in userlist 遍历对象比如某个对象中存储着你的个人信息，我们希望以列表的形式显示出来 1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt; &lt;!--1.在遍历对象的过程中, 如果只是获取一个值, 那么获取到的是value--&gt; &lt;ul&gt; &lt;li v-for=&quot;item in info&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--2.获取key和value 格式: (value, key) --&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key) in info&quot;&gt;&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!--3.获取key和value和index 格式: (value, key, index) --&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key, index) in info&quot;&gt;&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;index&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; info: &#123; name: &#x27;why&#x27;, age: 18, height: 1.88 &#125; &#125; &#125;)&lt;/script&gt; 组件的Key属性当列表的数据变化时，默认情况下， vue 会尽可能的复用已存在的 DOM 元素，从而提升渲染的性能 。但这种默认的性能优化策略，会导致有状态的列表无法被正确更新 。为了给 vue 一个提示，以便它能跟踪每个节点的身份， 从而在保证有状态的列表被正确更新的前提下， 提升渲染的性能 。此时，需要为每项提供一个唯一的 key 属性 ： 官方推荐我们在使用 v-for时，给对应的元素或组件加上一个 :key属性，key的作用主要是为了高效的更新虚拟DOM 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in letters&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; letters: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;] &#125; &#125;)&lt;/script&gt; key的注意事项 key 的值只能是字符串或数字类型 key 的值必须具有唯一性(即：key 的值不能重复) 建议把 数据项 id 属性的值 作为 key 的值（因为 id 属性的值具有唯一性) 使用 index 的值当作 key 的值没有任何意义(因为 index 的值不具有唯一性) 建议使用 v-for 指令时一定要指定 key 的值(既提升性能、又防止列表状态紊乱) 检测数组更新因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。 Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新。 push()：在数组后新增一个元素 pop()：删除数组中的最后一个元素 shift()：删除数组中的第一个元素 unshift()：在数组最前面添加元素 splice()：删除元素/插入元素/替换元素 sort()：按升序排序数组元素 reverse()：反转数组元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in letters&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; letters: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] &#125;, methods: &#123; btnClick() &#123; // 1.push方法 // this.letters.push(&#x27;aaa&#x27;) // this.letters.push(&#x27;aaaa&#x27;, &#x27;bbbb&#x27;, &#x27;cccc&#x27;) // 2.pop(): 删除数组中的最后一个元素 // this.letters.pop(); // 3.shift(): 删除数组中的第一个元素 // this.letters.shift(); // 4.unshift(): 在数组最前面添加元素 // this.letters.unshift() // this.letters.unshift(&#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;ccc&#x27;) // 5.splice作用: 删除元素/插入元素/替换元素 // 删除元素: 第二个参数传入你要删除几个元素(如果没有传,就删除后面所有的元素) // 替换元素: 第二个参数, 表示我们要替换几个元素, 后面是用于替换前面的元素 // 插入元素: 第二个参数, 传入0, 并且后面跟上要插入的元素 // splice(start) // splice(start): this.letters.splice(1, 3, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;l&#x27;, &#x27;x&#x27;) // this.letters.splice(1, 0, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;) // 5.sort() // this.letters.sort() // 6.reverse(): 反转数组 // this.letters.reverse() // 注意: 通过索引值修改数组中的元素 // this.letters[0] = &#x27;bbbbbb&#x27;; // this.letters.splice(0, 1, &#x27;bbbbbb&#x27;) // set(要修改的对象, 索引值, 修改后的值) // Vue.set(this.letters, 0, &#x27;bbbbbb&#x27;) &#125; &#125; &#125;) 双向绑定指令双向绑定指令也叫表单元素绑定，vue提供了 v-model 双向数据绑定 指令，用来辅助开发者在 不操作 DOM 的前提下， 快速获取表单的数据。 vue中使用 v-model 指令来实现表单元素和数据的双向绑定，经常用于表单 input 和 textarea 元素。 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;&#x27; &#125; &#125;)&lt;/script&gt; 理解双向绑定： 我们来看上述代码，当我们在输入框输入内容时 因为 input 中的 v-model 绑定了message，所以会实时的将输入的内容传递给 message，message发生改变。 当message 发生改变时，因为上面我们使用 Mustache 语法，将 message 的值插入到 DOM 中，所以 DOM 会发生响应的改变。 所以，通过 v-model 实现了 双向的绑定 v-model原理v-model 其实是一个语法糖，它的背后本质上是包含两个操作： v-bind 绑定一个 value 属性 v-on 指令给当前元素绑定 input 事件 也就是说下面的代码，等同于下面的代码： 123&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;!-- 等同于 --&gt;&lt;input type=&quot;text&quot; v-bind:value=&quot;message&quot; v-on:input=&quot;message = $event.target.value&quot; v-moduel：radio当存在多个单选框时： 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;label for=&quot;male&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;男 &lt;/label&gt; &lt;label for=&quot;female&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;女 &lt;/label&gt; &lt;h2&gt;您选择的性别是: &#123;&#123;sex&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, sex: &#x27;女&#x27; &#125; &#125;)&lt;/script&gt; v-moduel：checkbox复选框分为两种情况：单个勾选框和多个勾选框 单个勾选框 v-moduel 即为布尔值 此时 input 的 value 并不影响v-model的值 多个复选框 当是多个复选框时，因为可以选中多个，所以对应的 data 中属性是一个数组 当选中某一个时，就会将 input 的 value 添加到数组中 1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt;&lt;!-- 1.checkbox单选框--&gt; &lt;label for=&quot;agree&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;agree&quot; v-model=&quot;isAgree&quot;&gt;同意协议 &lt;/label&gt; &lt;h2&gt;您选择的是: &#123;&#123;isAgree&#125;&#125;&lt;/h2&gt; &lt;button :disabled=&quot;!isAgree&quot;&gt;下一步&lt;/button&gt; &lt;!--2.checkbox多选框--&gt; &lt;input type=&quot;checkbox&quot; value=&quot;篮球&quot; v-model=&quot;hobbies&quot;&gt;篮球 &lt;input type=&quot;checkbox&quot; value=&quot;足球&quot; v-model=&quot;hobbies&quot;&gt;足球 &lt;input type=&quot;checkbox&quot; value=&quot;乒乓球&quot; v-model=&quot;hobbies&quot;&gt;乒乓球 &lt;input type=&quot;checkbox&quot; value=&quot;羽毛球&quot; v-model=&quot;hobbies&quot;&gt;羽毛球 &lt;h2&gt;您的爱好是: &#123;&#123;hobbies&#125;&#125;&lt;/h2&gt; &lt;label v-for=&quot;item in originHobbies&quot; :for=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot; :value=&quot;item&quot; :id=&quot;item&quot; v-model=&quot;hobbies&quot;&gt;&#123;&#123;item&#125;&#125; &lt;/label&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, isAgree: false, // 单选框 hobbies: [], // 多选框, originHobbies: [&#x27;篮球&#x27;, &#x27;足球&#x27;, &#x27;乒乓球&#x27;, &#x27;羽毛球&#x27;, &#x27;台球&#x27;, &#x27;高尔夫球&#x27;] &#125; &#125;)&lt;/script&gt; v-moduel：select和 checkbox 一样，select 也分单选和多选两种情况 单选：只能选中一个值 v-model 绑定的是一个值 当我们选中 option 中的一个时，会将它对应的 vaule 赋值到 mySelect 中 多选：可以选中多个值 v-model 绑定的是一个数组 当选中多个值时，就会将选中的 option 对应的 value 添加到数组 mySelects中 12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;!--1.选择一个--&gt; &lt;select name=&quot;abc&quot; v-model=&quot;fruit&quot;&gt; &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt; &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;您选择的水果是: &#123;&#123;fruit&#125;&#125;&lt;/h2&gt; &lt;!--2.选择多个--&gt; &lt;select name=&quot;abc&quot; v-model=&quot;fruits&quot; multiple&gt; &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt; &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;您选择的水果是: &#123;&#123;fruits&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, fruit: &#x27;香蕉&#x27;, fruits: [] &#125; &#125;)&lt;/script&gt; 修饰符为了方便对用户输入的内容进行处理，vue 为 v-model 指令提供了 3 个修饰符 修饰符 作用 示例 .number 自动将用户的输入值转化为数值类型 &lt;input v-model.number = &quot;age&quot; /&gt; .trim 自动过滤用户输入的首尾空白字符 &lt;input v-module.trim = &quot;msg&quot; /&gt; .lazy 在 change 时而非 input 时更新 &lt;input v-model.lazy = &quot;msg&quot; /&gt; lazy修饰符 默认情况下， v-model 默认是在 input 事件中同步输入框的数据的。 也就是说，一旦有数据发生改变对应的 data 中的数据就会自动发生改变 lazy 修饰符可以让数据在失去焦点或者回车时才会更新 number修饰符 默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当作字符串类型进行处理 但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理 number 修饰符可以让在输入框中输入的内容自动转换成数字类型 trim 修饰符 如果输入的内容首尾有很多空格，通常我们希望将其去除 trim 修饰符可以过滤内容左右两边的空格 123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;!--1.修饰符: lazy--&gt; &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--2.修饰符: number--&gt; &lt;input type=&quot;number&quot; v-model.number=&quot;age&quot;&gt; &lt;h2&gt;&#123;&#123;age&#125;&#125;-&#123;&#123;typeof age&#125;&#125;&lt;/h2&gt; &lt;!--3.修饰符: trim--&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;name&quot;&gt; &lt;h2&gt;您输入的名字:&#123;&#123;name&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;你好啊&#x27;, age: 0, name: &#x27;&#x27; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/categories/Vue2-0/"}],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/tags/Vue2-0/"},{"name":"Vue-router","slug":"Vue-router","permalink":"http://example.com/tags/Vue-router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"http://example.com/tags/Vue-Cli/"}]}],"categories":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/categories/HTML/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://example.com/categories/Bootstrap/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/categories/ES6/"},{"name":"BOM","slug":"BOM","permalink":"http://example.com/categories/BOM/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"},{"name":"JS面向对象","slug":"JS面向对象","permalink":"http://example.com/categories/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"DOM","slug":"DOM","permalink":"http://example.com/categories/DOM/"},{"name":"JQuery","slug":"JQuery","permalink":"http://example.com/categories/JQuery/"},{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/categories/AJAX/"},{"name":"Node","slug":"Node","permalink":"http://example.com/categories/Node/"},{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/categories/Vue2-0/"},{"name":"Vue3.0","slug":"Vue3-0","permalink":"http://example.com/categories/Vue3-0/"},{"name":"Vue2.0-webpack","slug":"Vue2-0-webpack","permalink":"http://example.com/categories/Vue2-0-webpack/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://example.com/tags/Bootstrap/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"BOM","slug":"BOM","permalink":"http://example.com/tags/BOM/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"JS面向对象","slug":"JS面向对象","permalink":"http://example.com/tags/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"DOM","slug":"DOM","permalink":"http://example.com/tags/DOM/"},{"name":"JQuery","slug":"JQuery","permalink":"http://example.com/tags/JQuery/"},{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"},{"name":"Node","slug":"Node","permalink":"http://example.com/tags/Node/"},{"name":"模块化开发","slug":"模块化开发","permalink":"http://example.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"},{"name":"Express框架","slug":"Express框架","permalink":"http://example.com/tags/Express%E6%A1%86%E6%9E%B6/"},{"name":"Vue2.0","slug":"Vue2-0","permalink":"http://example.com/tags/Vue2-0/"},{"name":"Vue-router","slug":"Vue-router","permalink":"http://example.com/tags/Vue-router/"},{"name":"Vuex","slug":"Vuex","permalink":"http://example.com/tags/Vuex/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"http://example.com/tags/Vue-Cli/"},{"name":"VueCli4","slug":"VueCli4","permalink":"http://example.com/tags/VueCli4/"},{"name":"Vue3.0","slug":"Vue3-0","permalink":"http://example.com/tags/Vue3-0/"},{"name":"Webpack","slug":"Webpack","permalink":"http://example.com/tags/Webpack/"}]}